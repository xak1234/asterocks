<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Asterocks ‚Äî Multiplayer Asteroid Game</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial; }
    body {
      margin: 0;
      padding: 24px;
      background: #08101a;
      color: #e6eef8;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      position: relative;
    }
    #asteroidCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
    }
    .container {
      max-width: 900px;
      width: 100%;
      position: relative;
      z-index: 1;
      display: none;
      flex-direction: column;
      gap: 20px;
      background: rgba(8, 16, 26, 0.5);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 30px;
      border: 2px solid rgba(126, 200, 255, 0.3);
    }
    .card {
      background: rgba(15, 27, 42, 0.8);
      backdrop-filter: blur(8px);
      border-radius: 12px;
      padding: 28px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(126, 200, 255, 0.2);
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
      margin-bottom: 28px;
    }
    .header-left h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 600;
    }
    .header-left .sub {
      color: #93aecd;
      font-size: 12px;
      margin-top: 4px;
    }
    .header-left .sub code {
      background: rgba(255, 255, 255, 0.05);
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 11px;
    }
    .header-right {
      text-align: right;
    }
    .header-right > div {
      color: #93aecd;
      font-size: 12px;
      line-height: 1.6;
    }
    .status {
      color: #7ec8ff;
    }

    .content {
      display: grid;
      grid-template-columns: 1fr 2fr;
      gap: 24px;
    }

    /* Comet tracking styles removed */
    .observations {
      display: none;
    }

    /* Joystick Control Panel */
    #controlPanel {
      position: fixed;
      bottom: 15px;
      right: 15px;
      display: none;
      z-index: 1000;
      background: rgba(15, 27, 42, 0.95);
      border-radius: 12px;
      padding: 15px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.8);
      border: 2px solid rgba(126, 200, 255, 0.5);
    }

    #controlPanel.active {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      animation: panelFadeIn 0.3s ease-out;
    }

    @keyframes panelFadeIn {
      from {
        opacity: 0;
        transform: scale(0.8);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .joystick-container {
      display: grid;
      grid-template-columns: repeat(3, 50px);
      grid-template-rows: repeat(3, 50px);
      gap: 5px;
    }

    .direction-btn {
      background: rgba(126, 200, 255, 0.3);
      border: 2px solid rgba(126, 200, 255, 0.6);
      border-radius: 8px;
      color: #7ec8ff;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .direction-btn:active {
      background: rgba(126, 200, 255, 0.5);
      transform: scale(0.95);
    }

    .direction-btn.up { grid-column: 2; grid-row: 1; }
    .direction-btn.left { grid-column: 1; grid-row: 2; }
    .direction-btn.right { grid-column: 3; grid-row: 2; }
    .direction-btn.down { grid-column: 2; grid-row: 3; }

    .fire-btn {
      width: 70px;
      height: 70px;
      background: linear-gradient(145deg, #ff6b6b, #ff4444);
      border: 3px solid rgba(255, 107, 107, 0.8);
      border-radius: 50%;
      color: white;
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 3px 10px rgba(255, 107, 107, 0.5);
      transition: all 0.15s ease;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .fire-btn:active {
      background: linear-gradient(145deg, #ff4444, #ff2222);
      transform: scale(0.95);
      box-shadow: 0 1px 3px rgba(255, 107, 107, 0.7);
    }

    .hyperspace-btn {
      width: 70px;
      height: 40px;
      background: linear-gradient(145deg, #7ec8ff, #5ea8df);
      border: 3px solid rgba(126, 200, 255, 0.8);
      border-radius: 8px;
      color: white;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 3px 10px rgba(126, 200, 255, 0.5);
      transition: all 0.15s ease;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .hyperspace-btn:active {
      background: linear-gradient(145deg, #5ea8df, #4e98cf);
      transform: scale(0.95);
      box-shadow: 0 1px 3px rgba(126, 200, 255, 0.7);
    }

    .close-panel-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 15px;
      height: 15px;
      background: rgba(255, 107, 107, 0.3);
      border: 1px solid rgba(255, 107, 107, 0.5);
      border-radius: 50%;
      color: #ff9b9b;
      font-size: 9px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .close-panel-btn:active {
      background: rgba(255, 107, 107, 0.5);
      transform: scale(0.95);
    }

    .drag-handle {
      position: absolute;
      top: 5px;
      left: 5px;
      width: 20px;
      height: 20px;
      background: rgba(126, 200, 255, 0.3);
      border: 1px solid rgba(126, 200, 255, 0.5);
      border-radius: 4px;
      cursor: move;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 2px;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .drag-handle::before,
    .drag-handle::after {
      content: '';
      width: 12px;
      height: 2px;
      background: rgba(126, 200, 255, 0.6);
      border-radius: 1px;
    }

    .drag-handle:active {
      background: rgba(126, 200, 255, 0.5);
      cursor: grabbing;
    }

    @media (max-width: 720px) {
      .content {
        grid-template-columns: 1fr;
      }
      body {
        padding: 16px;
      }
      
      /* Optimize joystick for mobile */
      #controlPanel {
        bottom: 20px;
        right: 20px;
        padding: 20px;
        border-radius: 16px;
      }
      
      .joystick-container {
        grid-template-columns: repeat(3, 60px);
        grid-template-rows: repeat(3, 60px);
        gap: 8px;
      }
      
      .direction-btn {
        font-size: 24px;
        border-radius: 8px;
        border: 3px solid rgba(126, 200, 255, 0.6);
      }
      
      .fire-btn {
        width: 90px;
        height: 90px;
        font-size: 16px;
        border: 4px solid rgba(255, 107, 107, 0.8);
        box-shadow: 0 4px 12px rgba(255, 107, 107, 0.5);
      }
      
      .hyperspace-btn {
        width: 90px;
        height: 50px;
        font-size: 13px;
        border: 3px solid rgba(126, 200, 255, 0.8);
      }
      
      .close-panel-btn {
        width: 24px;
        height: 24px;
        font-size: 14px;
        top: 8px;
        right: 8px;
        border: 2px solid rgba(255, 107, 107, 0.5);
      }
      
      .drag-handle {
        width: 28px;
        height: 28px;
        top: 8px;
        left: 8px;
        border: 2px solid rgba(126, 200, 255, 0.5);
        border-radius: 6px;
      }
      
      .drag-handle::before,
      .drag-handle::after {
        width: 16px;
        height: 3px;
      }
    }

    /* ===== SCREEN SAVER STYLES ===== */
    #screenSaverOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #08101a 0%, #0a1428 50%, #08101a 100%);
      display: none;
      z-index: 2000;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
      pointer-events: none;
    }

    #screenSaverOverlay.active {
      display: flex;
      opacity: 1;
      pointer-events: auto;
    }

    .screensaver-content {
      text-align: center;
      color: #e6eef8;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial;
      z-index: 2001;
      position: relative;
    }

    .screensaver-logo {
      font-size: 64px;
      font-weight: 800;
      margin-bottom: 20px;
      letter-spacing: 3px;
      animation: screenSaverPulse 3s ease-in-out infinite;
      text-shadow: 0 0 20px rgba(126, 240, 163, 0.5);
    }

    .screensaver-subtitle {
      font-size: 20px;
      color: #93aecd;
      margin-bottom: 40px;
      letter-spacing: 1px;
      font-weight: 300;
    }

    .screensaver-status {
      font-size: 16px;
      color: #7ec8ff;
      margin-bottom: 30px;
      min-height: 24px;
      font-weight: 500;
    }

    .screensaver-hint {
      font-size: 13px;
      color: #86a6c5;
      margin-top: 80px;
      animation: screenSaverFade 2s ease-in-out infinite;
    }

    /* ===== RADAR SYSTEM ===== */
    #radarContainer {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 200px;
      height: 200px;
      background: rgba(15, 27, 42, 0.9);
      border-radius: 50%;
      border: 3px solid rgba(126, 200, 255, 0.5);
      box-shadow: 0 0 20px rgba(126, 200, 255, 0.3);
      z-index: 1000;
    }

    #radarCanvas {
      width: 100%;
      height: 100%;
      border-radius: 50%;
    }

    .radar-label {
      position: absolute;
      bottom: -30px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(126, 200, 255, 0.8);
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* ===== PLAYER LIST (ANYPLAYER MODE) ===== */
    #playerList {
      position: fixed;
      top: 150px;
      right: 20px;
      background: rgba(15, 27, 42, 0.6);
      border: 2px solid rgba(126, 200, 255, 0.5);
      border-radius: 6px;
      padding: 9px 12px;
      min-width: 80px;
      max-height: 300px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6);
    }

    #playerList.active {
      display: block;
    }

    .player-list-title {
      font-size: 10.5px;
      font-weight: 700;
      color: rgba(255, 200, 100, 0.9);
      text-transform: uppercase;
      letter-spacing: 0.75px;
      margin-bottom: 7.5px;
      text-align: center;
      border-bottom: 1px solid rgba(126, 200, 255, 0.3);
      padding-bottom: 4.5px;
    }

    .player-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4.5px 6px;
      margin-bottom: 3px;
      background: rgba(8, 16, 26, 0.6);
      border-radius: 3px;
      border-left: 2.25px solid;
    }

    .player-item.me {
      background: rgba(126, 240, 163, 0.15);
      border-left-color: rgba(126, 240, 163, 0.8);
    }

    .player-icon {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .player-info {
      flex: 1;
      font-size: 9px;
    }

    .player-name {
      color: rgba(255, 255, 255, 0.9);
      font-weight: 600;
    }

    .player-score {
      color: rgba(255, 200, 100, 0.8);
      font-size: 8.25px;
    }

    /* ===== CONTROL BUTTONS ===== */
    .control-buttons {
      position: fixed;
      top: 70px;
      right: 20px;
      display: flex;
      gap: 10px;
      z-index: 1000;
    }

    .control-btn {
      width: 50px;
      height: 50px;
      background: rgba(15, 27, 42, 0.9);
      border: 2px solid rgba(126, 200, 255, 0.5);
      border-radius: 8px;
      color: rgba(126, 200, 255, 0.9);
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
      user-select: none;
    }

    .control-btn:hover {
      background: rgba(15, 27, 42, 1);
      border-color: rgba(126, 240, 163, 0.8);
      color: rgba(126, 240, 163, 1);
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(126, 200, 255, 0.3);
    }

    .control-btn:active {
      transform: scale(0.95);
    }

    .control-btn.active {
      background: rgba(126, 200, 255, 0.2);
      border-color: rgba(126, 240, 163, 0.8);
      color: rgba(126, 240, 163, 1);
    }

    .control-btn.muted {
      background: rgba(255, 107, 107, 0.2);
      border-color: rgba(255, 107, 107, 0.5);
      color: rgba(255, 107, 107, 0.8);
    }

    #keyLegend {
      position: fixed;
      bottom: 22px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 11px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      background: rgba(6, 12, 20, 0.78);
      border: 1px solid rgba(126, 200, 255, 0.35);
      border-radius: 10px;
      padding: 10px 16px;
      color: #cdd9ef;
      z-index: 1200;
      display: flex;
      flex-direction: column;
      gap: 4px;
      pointer-events: none;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.55);
    }

    #keyLegend .legend-row {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 14px;
    }

    #keyLegend .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      white-space: nowrap;
    }

    #keyLegend .legend-key {
      font-weight: 700;
      color: #7ec8ff;
    }

    #keyLegend .legend-action {
      color: #9fb8d7;
    }

    @media (max-width: 720px) {
      #keyLegend {
        font-size: 9px;
        padding: 8px 10px;
        width: calc(100% - 40px);
      }
    }

    .pause-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(8, 16, 26, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1500;
      backdrop-filter: blur(5px);
    }

    .pause-overlay.active {
      display: flex;
    }

    .pause-content {
      text-align: center;
      color: #e6eef8;
    }

    .pause-title {
      font-size: 64px;
      font-weight: 800;
      color: rgba(126, 240, 163, 0.9);
      text-shadow: 0 0 20px rgba(126, 240, 163, 0.5);
      margin-bottom: 20px;
      animation: pausePulse 2s ease-in-out infinite;
    }

    .pause-subtitle {
      font-size: 20px;
      color: #93aecd;
      letter-spacing: 1px;
    }

    @keyframes pausePulse {
      0%, 100% {
        opacity: 0.7;
      }
      50% {
        opacity: 1;
      }
    }

    /* ===== LOBBY SYSTEM STYLES ===== */
    .lobby-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('assets/back.png') center center / cover no-repeat, rgba(8, 16, 26, 0.7);
      background-attachment: fixed;
      background-blend-mode: overlay;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2500;
      backdrop-filter: blur(10px);
    }

    .lobby-overlay.active {
      display: flex;
    }

    .lobby-content {
      text-align: center;
      color: #e6eef8;
      background: rgba(15, 27, 42, 0.9);
      border-radius: 8px;
      padding: 20px 30px;
      border: 2px solid rgba(126, 200, 255, 0.5);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
      min-width: 200px;
    }

    .lobby-title {
      font-size: 16px;
      font-weight: 800;
      color: rgba(126, 240, 163, 0.9);
      text-shadow: 0 0 20px rgba(126, 240, 163, 0.5);
      margin-bottom: 10px;
      letter-spacing: 2px;
    }

    .lobby-status {
      font-size: 8px;
      color: #93aecd;
      margin-bottom: 15px;
      min-height: 12px;
    }

    .lobby-options {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 10px;
    }

    .lobby-btn {
      padding: 8px 15px;
      font-size: 8px;
      font-weight: 600;
      border: 2px solid rgba(126, 200, 255, 0.5);
      border-radius: 4px;
      background: rgba(15, 27, 42, 0.8);
      color: rgba(126, 200, 255, 0.9);
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .lobby-btn:hover:not(:disabled) {
      background: rgba(126, 200, 255, 0.2);
      border-color: rgba(126, 240, 163, 0.8);
      color: rgba(126, 240, 163, 1);
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(126, 200, 255, 0.3);
    }

    .lobby-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .lobby-btn-primary {
      background: rgba(126, 240, 163, 0.2);
      border-color: rgba(126, 240, 163, 0.6);
      color: rgba(126, 240, 163, 1);
    }

    .lobby-btn-primary:hover:not(:disabled) {
      background: rgba(126, 240, 163, 0.3);
      box-shadow: 0 4px 12px rgba(126, 240, 163, 0.4);
    }

    .lobby-btn-vs {
      background: rgba(255, 107, 107, 0.2);
      border-color: rgba(255, 107, 107, 0.6);
      color: rgba(255, 107, 107, 1);
    }

    .lobby-btn-vs:hover:not(:disabled) {
      background: rgba(255, 107, 107, 0.3);
      box-shadow: 0 4px 12px rgba(255, 107, 107, 0.4);
    }

    .lobby-btn-any {
      background: rgba(255, 165, 0, 0.2);
      border-color: rgba(255, 165, 0, 0.6);
      color: rgba(255, 200, 100, 1);
      position: relative;
    }

    .lobby-btn-any:hover:not(:disabled) {
      background: rgba(255, 165, 0, 0.3);
      box-shadow: 0 4px 12px rgba(255, 165, 0, 0.4);
      border-color: rgba(255, 200, 100, 0.8);
    }
    
    .player-count-badge {
      display: none;
      background: rgba(255, 215, 0, 0.9);
      color: #000;
      font-weight: bold;
      font-size: 11px;
      padding: 2px 7px;
      border-radius: 10px;
      margin-left: 6px;
      box-shadow: 0 2px 8px rgba(255, 215, 0, 0.4);
      animation: pulse 2s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .lobby-hint {
      font-size: 7px;
      color: #86a6c5;
      font-style: italic;
    }

    /* ===== JOIN REQUEST POPUP ===== */
    .join-request-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(8, 16, 26, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 3000;
      backdrop-filter: blur(8px);
    }

    .join-request-overlay.active {
      display: flex;
      animation: popupFadeIn 0.3s ease-out;
    }

    @keyframes popupFadeIn {
      from {
        opacity: 0;
        transform: scale(0.9);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .join-request-content {
      text-align: center;
      color: #e6eef8;
      background: linear-gradient(145deg, rgba(255, 200, 100, 0.15), rgba(255, 160, 80, 0.1));
      border-radius: 16px;
      padding: 40px 60px;
      border: 3px solid rgba(255, 200, 100, 0.6);
      box-shadow: 0 8px 32px rgba(255, 200, 100, 0.3);
      min-width: 400px;
      animation: pulseBorder 2s ease-in-out infinite;
    }

    @keyframes pulseBorder {
      0%, 100% {
        border-color: rgba(255, 200, 100, 0.6);
        box-shadow: 0 8px 32px rgba(255, 200, 100, 0.3);
      }
      50% {
        border-color: rgba(255, 200, 100, 0.9);
        box-shadow: 0 8px 32px rgba(255, 200, 100, 0.5);
      }
    }

    .join-request-title {
      font-size: 28px;
      font-weight: 800;
      color: rgba(255, 200, 100, 1);
      text-shadow: 0 0 20px rgba(255, 200, 100, 0.6);
      margin-bottom: 20px;
      letter-spacing: 2px;
      animation: textPulse 1.5s ease-in-out infinite;
    }

    @keyframes textPulse {
      0%, 100% {
        opacity: 0.9;
      }
      50% {
        opacity: 1;
      }
    }

    .join-request-message {
      font-size: 18px;
      color: #e6eef8;
      margin-bottom: 15px;
      font-weight: 500;
    }

    .join-request-mode {
      font-size: 16px;
      color: #ffd166;
      margin-bottom: 25px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .join-request-buttons {
      display: flex;
      gap: 20px;
      justify-content: center;
    }

    .join-request-btn {
      padding: 15px 40px;
      font-size: 16px;
      font-weight: 700;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      border: none;
    }

    .join-request-accept {
      background: linear-gradient(145deg, #7ef0a3, #5ed18a);
      color: #0a1428;
      box-shadow: 0 4px 12px rgba(126, 240, 163, 0.4);
    }

    .join-request-accept:hover {
      background: linear-gradient(145deg, #8ff5b0, #6ed998);
      transform: scale(1.05);
      box-shadow: 0 6px 16px rgba(126, 240, 163, 0.6);
    }

    .join-request-decline {
      background: linear-gradient(145deg, #ff9b9b, #ff6b6b);
      color: #0a1428;
      box-shadow: 0 4px 12px rgba(255, 107, 107, 0.4);
    }

    .join-request-decline:hover {
      background: linear-gradient(145deg, #ffb0b0, #ff8080);
      transform: scale(1.05);
      box-shadow: 0 6px 16px rgba(255, 107, 107, 0.6);
    }

    @keyframes screenSaverPulse {
      0%, 100% {
        opacity: 0.6;
        transform: scale(1);
      }
      50% {
        opacity: 1;
        transform: scale(1.08);
      }
    }

    @keyframes screenSaverFade {
      0%, 100% {
        opacity: 0.3;
      }
      50% {
        opacity: 0.9;
      }
    }

    .screensaver-particles {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 2000;
    }

    .screensaver-particle {
      position: absolute;
      width: 2px;
      height: 2px;
      background: rgba(126, 240, 163, 0.7);
      border-radius: 50%;
      box-shadow: 0 0 4px rgba(126, 240, 163, 0.8);
    }
  </style>
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js';
    import {
      getFirestore,
      doc,
      setDoc,
      onSnapshot,
      serverTimestamp,
      deleteDoc,
      collection
    } from 'https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js';

    const firebaseConfig = {
      apiKey: 'AIzaSyCJ262M1S7RnjIF8hxF54bPHLrBxiDT4B4',
      authDomain: 'asterocks-91329.firebaseapp.com',
      projectId: 'asterocks-91329',
      storageBucket: 'asterocks-91329.firebasestorage.app',
      messagingSenderId: '324936164220',
      appId: '1:324936164220:web:e7ace192f67db6899fbaf9'
    };

    const firebaseApp = initializeApp(firebaseConfig);
    const firebaseDb = getFirestore(firebaseApp);
    window.firebaseApp = firebaseApp;
    window.firebaseDb = firebaseDb;
    window.getFirebaseApp = () => firebaseApp;
    window.getFirebaseDb = () => firebaseDb;
    window.firebaseHelpers = {
      getFirestore,
      doc,
      setDoc,
      onSnapshot,
      serverTimestamp,
      deleteDoc,
      collection
    };
  </script>
  
  <!-- Configuration -->
  <script src="config.js"></script>
</head>
<body>
  <canvas id="asteroidCanvas"></canvas>
  
  <!-- Joystick Control Panel (DISABLED) -->
  <div id="controlPanel" style="display: none !important;">
    <div class="drag-handle" id="dragHandle"></div>
    <div class="close-panel-btn" id="closePanelBtn">√ó</div>
    <div class="joystick-container">
      <button class="direction-btn up" id="upBtn">‚ñ≤</button>
      <button class="direction-btn left" id="leftBtn">‚óÑ</button>
      <button class="direction-btn right" id="rightBtn">‚ñ∫</button>
      <button class="direction-btn down" id="downBtn">‚ñº</button>
    </div>
    <button class="fire-btn" id="fireBtn">FIRE</button>
    <button class="hyperspace-btn" id="hyperspaceBtn">HYPER</button>
  </div>
  
  <!-- Radar System -->
  <div id="radarContainer">
    <canvas id="radarCanvas" width="200" height="200"></canvas>
    <div class="radar-label">RADAR</div>
  </div>
  
  <!-- Control Buttons -->
  <div class="control-buttons">
    <button class="control-btn" id="soundBtn" title="Toggle Sound Effects">üîä</button>
    <button class="control-btn" id="pauseBtn" title="Pause Game">‚è∏</button>
  </div>
  
  <!-- Pause Overlay -->
  <div class="pause-overlay" id="pauseOverlay">
    <div class="pause-content">
      <div class="pause-title">PAUSED</div>
      <div class="pause-subtitle">Press P or click Pause button to resume</div>
    </div>
  </div>
  
  <!-- 2-Player Co-op Lobby -->
  <div class="lobby-overlay" id="lobbyOverlay">
    <div class="lobby-content">
      <div class="lobby-title">ASTEROCKS</div>
      <div class="lobby-status" id="lobbyStatus">Connecting...</div>
      <div class="lobby-options" id="lobbyOptions">
        <button class="lobby-btn" id="soloPlayBtn">Play Solo</button>
        <button class="lobby-btn lobby-btn-primary" id="coopPlayBtn" disabled>Co-op Mode</button>
        <button class="lobby-btn lobby-btn-vs" id="vsPlayBtn" disabled>VS Mode (PvP)</button>
        <button class="lobby-btn lobby-btn-any" id="anyPlayerBtn">Any Player (Battle Royale) <span class="player-count-badge" id="anyPlayerCount">0</span></button>
      </div>
      <div class="lobby-hint">Co-op: Team up | VS: 1v1 Battle | Any Player: Join anyone's fight!</div>
      <div style="position: absolute; bottom: 15px; right: 20px; font-size: 10px; color: #ffd700; opacity: 0.7;">franksgames2025</div>
    </div>
  </div>
  
  <!-- Join Request Popup -->
  <div class="join-request-overlay" id="joinRequestOverlay">
    <div class="join-request-content">
      <div class="join-request-title">INCOMING TRANSMISSION</div>
      <div class="join-request-message" id="joinRequestMessage">Another player wants to join your game!</div>
      <div class="join-request-mode" id="joinRequestMode"></div>
      <div class="join-request-buttons">
        <button class="join-request-btn join-request-accept" id="acceptJoinBtn">Accept</button>
        <button class="join-request-btn join-request-decline" id="declineJoinBtn">Decline</button>
      </div>
    </div>
  </div>
  
  <!-- Player List (Battle Royale) -->
  <div id="playerList">
    <div class="player-list-title">Battle Royale</div>
    <div id="playerListContent"></div>
  </div>

  <!-- Key Legend -->
  <div id="keyLegend">
    <div class="legend-row">
      <span class="legend-item"><span class="legend-key">‚Üê / ‚Üí</span><span class="legend-action">Rotate</span></span>
      <span class="legend-item"><span class="legend-key">‚Üë</span><span class="legend-action">Thrust</span></span>
      <span class="legend-item"><span class="legend-key">‚Üì</span><span class="legend-action">Brake</span></span>
    </div>
    <div class="legend-row">
      <span class="legend-item"><span class="legend-key">Space</span><span class="legend-action">Fire</span></span>
      <span class="legend-item"><span class="legend-key">S</span><span class="legend-action">Heat Seeker</span></span>
      <span class="legend-item"><span class="legend-key">B</span><span class="legend-action">Bomb</span></span>
    </div>
    <div class="legend-row">
      <span class="legend-item"><span class="legend-key">H</span><span class="legend-action">Hyperspace</span></span>
      <span class="legend-item"><span class="legend-key">P</span><span class="legend-action">Pause</span></span>
      <span class="legend-item"><span class="legend-key">Q</span><span class="legend-action">Exit Royale</span></span>
    </div>
  </div>
  
  <!-- Screen Saver Overlay -->
  <div id="screenSaverOverlay">
    <div class="screensaver-particles" id="screensaverParticles"></div>
    <div class="screensaver-content">
      <div class="screensaver-logo">ASTEROCKS</div>
      <div class="screensaver-subtitle">Multiplayer Asteroid Game</div>
      <div class="screensaver-status" id="screensaverStatus">Monitoring...</div>
      <div class="screensaver-hint">Move mouse or press any key to resume</div>
    </div>
  </div>
  
  <div class="container">
  </div>

<script>
// Asterocks - Multiplayer Asteroid Battle Game

// ===== DOUBLE-TAP/DOUBLE-CLICK JOYSTICK CONTROL SYSTEM (DISABLED - KEYBOARD ONLY) =====
(function() {
  let lastTapTime = 0;
  const DOUBLE_TAP_DELAY = 300; // milliseconds
  const controlPanel = document.getElementById('controlPanel');
  const closePanelBtn = document.getElementById('closePanelBtn');
  const dragHandle = document.getElementById('dragHandle');
  let isManualControl = true; // Always true for keyboard control
  
  // Drag state
  let isDragging = false;
  let dragOffsetX = 0;
  let dragOffsetY = 0;
  
  // Helper function to toggle control panel
  function toggleControlPanel() {
    if (controlPanel.classList.contains('active')) {
      controlPanel.classList.remove('active');
      isManualControl = false;
    } else {
      controlPanel.classList.add('active');
      isManualControl = true;
    }
  }
  
  // Auto-enable on mobile devices
  if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
    controlPanel.classList.add('active');
    isManualControl = true;
    console.log('Mobile controls enabled');
  }
  
  // Double-click detection (DISABLED)
  // document.addEventListener('dblclick', function(e) { });
  
  // Double-tap detection (DISABLED)
  // document.addEventListener('touchstart', function(e) { });
  
  // Close button
  closePanelBtn.addEventListener('click', function() {
    controlPanel.classList.remove('active');
    isManualControl = false;
  });
  
  // Drag functionality
  function startDrag(e) {
    e.preventDefault();
    isDragging = true;
    
    const rect = controlPanel.getBoundingClientRect();
    const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
    const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
    
    dragOffsetX = clientX - rect.left;
    dragOffsetY = clientY - rect.top;
    
    dragHandle.style.cursor = 'grabbing';
  }
  
  function drag(e) {
    if (!isDragging) return;
    e.preventDefault();
    
    const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
    const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
    
    let newLeft = clientX - dragOffsetX;
    let newTop = clientY - dragOffsetY;
    
    // Keep panel within viewport bounds
    const maxLeft = window.innerWidth - controlPanel.offsetWidth;
    const maxTop = window.innerHeight - controlPanel.offsetHeight;
    
    newLeft = Math.max(0, Math.min(newLeft, maxLeft));
    newTop = Math.max(0, Math.min(newTop, maxTop));
    
    controlPanel.style.left = newLeft + 'px';
    controlPanel.style.top = newTop + 'px';
    controlPanel.style.right = 'auto';
    controlPanel.style.bottom = 'auto';
  }
  
  function stopDrag(e) {
    if (isDragging) {
      e.preventDefault();
      isDragging = false;
      dragHandle.style.cursor = 'move';
    }
  }
  
  // Touch events
  dragHandle.addEventListener('touchstart', startDrag);
  document.addEventListener('touchmove', drag);
  document.addEventListener('touchend', stopDrag);
  
  // Mouse events
  dragHandle.addEventListener('mousedown', startDrag);
  document.addEventListener('mousemove', drag);
  document.addEventListener('mouseup', stopDrag);
  
  // Joystick controls
  const upBtn = document.getElementById('upBtn');
  const downBtn = document.getElementById('downBtn');
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const fireBtn = document.getElementById('fireBtn');
  
  // Keyboard state tracking
  const keyboardState = {
    ArrowUp: false,
    ArrowDown: false,
    ArrowLeft: false,
    ArrowRight: false,
    ' ': false, // Spacebar
    'b': false, // Bomb drop
    'B': false, // Bomb drop (uppercase)
    'h': false, // Hyperspace
    'H': false, // Hyperspace (uppercase)
    's': false, // Heat seeker
    'S': false  // Heat seeker (uppercase)
  };

  // Listen for keyboard events
  document.addEventListener('keydown', function(e) {
    if (e.key in keyboardState) {
      keyboardState[e.key] = true;
      e.preventDefault();
    }
  });

  document.addEventListener('keyup', function(e) {
    if (e.key in keyboardState) {
      keyboardState[e.key] = false;
      e.preventDefault();
    }
  });

  // Export manual control state and button states for game to use
  window.joystickControl = {
    isManualControl: () => isManualControl,
    getThrust: () => false,
    getRotation: () => 0,
    getFire: () => false,
    pressedButtons: {
      up: false,
      down: false,
      left: false,
      right: false,
      fire: false,
      hyperspace: false
    },
    keyboardState: keyboardState
  };
  
  // Button event handlers
  function setupButton(btn, key) {
    btn.addEventListener('touchstart', function(e) {
      e.preventDefault();
      window.joystickControl.pressedButtons[key] = true;
    });
    
    btn.addEventListener('touchend', function(e) {
      e.preventDefault();
      window.joystickControl.pressedButtons[key] = false;
    });
    
    btn.addEventListener('mousedown', function(e) {
      e.preventDefault();
      window.joystickControl.pressedButtons[key] = true;
    });
    
    btn.addEventListener('mouseup', function(e) {
      e.preventDefault();
      window.joystickControl.pressedButtons[key] = false;
    });
  }
  
  setupButton(upBtn, 'up');
  setupButton(downBtn, 'down');
  setupButton(leftBtn, 'left');
  setupButton(rightBtn, 'right');
  setupButton(fireBtn, 'fire');
  
  // Hyperspace button handler
  const hyperspaceBtn = document.getElementById('hyperspaceBtn');
  if (hyperspaceBtn) {
    hyperspaceBtn.addEventListener('touchstart', function(e) {
      e.preventDefault();
      window.joystickControl.pressedButtons.hyperspace = true;
    });
    
    hyperspaceBtn.addEventListener('touchend', function(e) {
      e.preventDefault();
      window.joystickControl.pressedButtons.hyperspace = false;
    });
    
    hyperspaceBtn.addEventListener('mousedown', function(e) {
      e.preventDefault();
      window.joystickControl.pressedButtons.hyperspace = true;
    });
    
    hyperspaceBtn.addEventListener('mouseup', function(e) {
      e.preventDefault();
      window.joystickControl.pressedButtons.hyperspace = false;
    });
  }
})();

// ===== ARCADE SOUND EFFECTS SYSTEM =====
class ArcadeSound {
  constructor(audioContext) {
    this.ctx = audioContext;
  }
  
  playShoot() {
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    
    osc.frequency.setValueAtTime(400, this.ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 0.1);
    
    gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
    
    osc.start(this.ctx.currentTime);
    osc.stop(this.ctx.currentTime + 0.1);
  }
  
  playAsteroidHit(baseFreq = 150) {
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    
    osc.type = 'square';
    osc.frequency.setValueAtTime(baseFreq, this.ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(baseFreq / 2, this.ctx.currentTime + 0.15);
    
    gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
    
    osc.start(this.ctx.currentTime);
    osc.stop(this.ctx.currentTime + 0.15);
  }
  
  playExplosion() {
    // Create a noise burst for explosion
    const bufferSize = this.ctx.sampleRate * 0.5; // 0.5 seconds
    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < bufferSize; i++) {
      data[i] = Math.random() * 2 - 1;
    }
    
    const source = this.ctx.createBufferSource();
    source.buffer = buffer;
    
    const gain = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();
    
    source.connect(filter);
    filter.connect(gain);
    gain.connect(this.ctx.destination);
    
    filter.type = 'highpass';
    filter.frequency.setValueAtTime(200, this.ctx.currentTime);
    filter.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.5);
    
    gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
    
    source.start(this.ctx.currentTime);
    source.stop(this.ctx.currentTime + 0.5);
  }
  
  playHyperspace() {
    // Classic oscillating "whoosh" sound
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    
    osc.type = 'triangle';
    
    // Pitch sweep: low to high to low
    const duration = 0.4;
    osc.frequency.setValueAtTime(100, this.ctx.currentTime);
    osc.frequency.linearRampToValueAtTime(800, this.ctx.currentTime + duration / 2);
    osc.frequency.linearRampToValueAtTime(100, this.ctx.currentTime + duration);
    
    gain.gain.setValueAtTime(0.25, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
    
    osc.start(this.ctx.currentTime);
    osc.stop(this.ctx.currentTime + duration);
  }
  
  playUfoTheme() {
    // Classic UFO "beep-boop" sound
    const osc1 = this.ctx.createOscillator();
    const osc2 = this.ctx.createOscillator();
    const gain1 = this.ctx.createGain();
    const gain2 = this.ctx.createGain();
    const mainGain = this.ctx.createGain();
    
    osc1.connect(gain1);
    osc2.connect(gain2);
    gain1.connect(mainGain);
    gain2.connect(mainGain);
    mainGain.connect(this.ctx.destination);
    
    osc1.frequency.setValueAtTime(400, this.ctx.currentTime);
    osc2.frequency.setValueAtTime(300, this.ctx.currentTime);
    
    gain1.gain.setValueAtTime(0.15, this.ctx.currentTime);
    gain2.gain.setValueAtTime(0.15, this.ctx.currentTime);
    
    mainGain.gain.setValueAtTime(0.2, this.ctx.currentTime);
    mainGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
    
    osc1.start(this.ctx.currentTime);
    osc2.start(this.ctx.currentTime);
    osc1.stop(this.ctx.currentTime + 0.3);
    osc2.stop(this.ctx.currentTime + 0.3);
  }
  
  playUfoBullet() {
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    
    osc.frequency.setValueAtTime(600, this.ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(300, this.ctx.currentTime + 0.08);
    
    gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.08);
    
    osc.start(this.ctx.currentTime);
    osc.stop(this.ctx.currentTime + 0.08);
  }
  
  playThrust() {
    // Subtle rumble for engine thrust
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    
    osc.type = 'square';
    osc.frequency.setValueAtTime(80, this.ctx.currentTime);
    osc.frequency.linearRampToValueAtTime(120, this.ctx.currentTime + 0.1);
    osc.frequency.linearRampToValueAtTime(80, this.ctx.currentTime + 0.2);
    
    gain.gain.setValueAtTime(0.03, this.ctx.currentTime);
    gain.gain.linearRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
    
    osc.start(this.ctx.currentTime);
    osc.stop(this.ctx.currentTime + 0.2);
  }

  playPowerup() {
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.connect(gain);
    gain.connect(this.ctx.destination);

    osc.type = 'sine';
    osc.frequency.setValueAtTime(500, this.ctx.currentTime);
    osc.frequency.linearRampToValueAtTime(900, this.ctx.currentTime + 0.2);

    gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.25);

    osc.start(this.ctx.currentTime);
    osc.stop(this.ctx.currentTime + 0.25);
  }

  playLaser() {
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    const mod = this.ctx.createOscillator();
    const modGain = this.ctx.createGain();

    modGain.gain.value = 150;
    mod.connect(modGain);
    modGain.connect(osc.frequency);

    osc.connect(gain);
    gain.connect(this.ctx.destination);

    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(700, this.ctx.currentTime);
    mod.type = 'triangle';
    mod.frequency.value = 20;

    gain.gain.setValueAtTime(0.25, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.02, this.ctx.currentTime + 0.3);

    osc.start(this.ctx.currentTime);
    mod.start(this.ctx.currentTime);
    osc.stop(this.ctx.currentTime + 0.3);
    mod.stop(this.ctx.currentTime + 0.3);
  }

}

// Initialize audio context
let audioContext = null;
let arcadeSound = null;
let soundEnabled = true; // Global sound state

function initAudio() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    arcadeSound = new ArcadeSound(audioContext);
  }
}

// Sound playback helpers
function playSound(soundName) {
  if (!soundEnabled) return; // Don't play if sound is disabled
  if (!arcadeSound) initAudio();
  
  // Resume audio context if suspended (required on some browsers)
  if (audioContext.state === 'suspended') {
    audioContext.resume();
  }
  
  switch(soundName) {
    case 'shoot': arcadeSound.playShoot(); break;
    case 'hit': arcadeSound.playAsteroidHit(); break;
    case 'explosion': arcadeSound.playExplosion(); break;
    case 'hyperspace': arcadeSound.playHyperspace(); break;
    case 'ufo': arcadeSound.playUfoTheme(); break;
    case 'ufobullet': arcadeSound.playUfoBullet(); break;
    case 'thrust': arcadeSound.playThrust(); break;
    case 'powerup': arcadeSound.playPowerup(); break;
    case 'laser': arcadeSound.playLaser(); break;
  }
}

const assetAudioSources = {
  seek: 'assets/seek.mp3',
  countdown: 'assets/2sec.mp3',
  bomb: 'assets/bomb.mp3',
  hyper: 'assets/hyper.mp3',
  powerup: 'assets/powerup.mp3',
  ufo: 'assets/ufo.mp3',
  laser: 'assets/laser.mp3',
  powerupinside: 'assets/powerupinside.mp3'
};

const assetAudioCache = {};

function playAssetAudio(name) {
  if (!soundEnabled) return;
  const src = assetAudioSources[name];
  if (!src) return;
  if (!assetAudioCache[name]) {
    const audio = new Audio(src);
    audio.preload = 'auto';
    assetAudioCache[name] = audio;
  }
  const playable = assetAudioCache[name].cloneNode(true);
  playable.currentTime = 0;
  const playAttempt = playable.play();
  if (playAttempt && typeof playAttempt.catch === 'function') {
    playAttempt.catch(err => {
      console.warn(`Audio playback blocked for ${name}`, err);
    });
  }
}

// ===== ASTEROID GAME BACKGROUND ANIMATION =====
(function() {
  const canvas = document.getElementById('asteroidCanvas');
  const ctx = canvas.getContext('2d');
  
  // Set canvas size to match window
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  
  // Game state
  const ship = {
    x: canvas.width / 2,
    y: canvas.height / 2,
    angle: 0,
    velocity: { x: 0, y: 0 },
    size: 15,
    thrust: false,
    rotation: 0,
    exploded: false,
    respawnTime: 0,
    lastHeatSeekerState: false,
    lastHyperspaceState: false
  };
  
  const asteroids = [];
  const bullets = [];
  const particles = [];
  const stars = [];
  const ufos = [];
  const ufoBullets = [];
  const aliens = []; // Rare powerful aliens
  const shootingStars = []; // Fast-moving medium asteroids
  const SHOOTING_STARS_ENABLED = false;
  const bombs = []; // Bombs for anyplayer mode
  const MAX_BOMBS = 5; // Maximum bombs per player
  let bombCount = 0; // Current number of active bombs
  let lastBombRefreshTime = Date.now(); // Track bomb refresh timer
  const BOMB_REFRESH_INTERVAL = 20000; // 20 seconds
  const heatSeekers = []; // Active heat seeker missiles
  let heatSeekerCharges = 0; // Stored charges for launching missiles
  let nextHeatSeekerId = 1;
  const HEAT_SEEKER_MAX_CHARGES = 3;
  const HEAT_SEEKER_DURATION = 8000; // ms lifetime
  const HEAT_SEEKER_SPEED = 6.2;
  const HEAT_SEEKER_TURN_RATE = 0.14;
  const HEAT_SEEKER_DETONATION_RADIUS = 28;
  let lastHugeAsteroidTime = Date.now();
  const HUGE_ASTEROID_INTERVAL = 20000; // 20 seconds
  let lastUfoTime = Date.now();
  let nextUfoInterval = 20000 + Math.random() * 15000; // 20-35 seconds
  let lastAlienTime = Date.now();
  let nextAlienInterval = 45000 + Math.random() * 30000; // 45-75 seconds (rare)
  let lastShootingStarTime = Date.now();
  let nextShootingStarInterval = 12000 + Math.random() * 6000;
  const SHOOTING_STAR_SPEED = 10; // ~5x normal asteroid drift
  const SHOOTING_STAR_SIZE_RANGE = { min: 24, max: 34 };
  const SHOOTING_STAR_OUT_OF_BOUNDS = 180;
  let lastHyperspaceTime = 0;
  const HYPERSPACE_COOLDOWN = 8000; // 8 seconds
  
  // Game state
  let score = 0;
  let lives = 3;
  let nextExtraLifeAt = 1000; // Score threshold for next extra life
  let gameOver = false;
  let gamePaused = false;
  // soundEnabled is global (defined outside this scope)
  let dualCannon = false; // Powerup from destroying UFO
  let laserCanon = false; // Super laser powerup
  let lastLaserShot = 0;
  const LASER_COOLDOWN = 350; // ms between beams
  const LASER_SPEED = 9;
  const LASER_LENGTH = 45;
  const LASER_WIDTH = 4;
  const LASER_LIFE = 90;
  const LASER_MUZZLE_OFFSET = ship.size * 1.8;
  const LASER_BEAM_COUNT = 3;
  const LASER_SPREAD = 0.08; // Radians between adjacent laser jets
  let vsKills = 0; // Kill counter for VS mode
  let playerKills = 0; // Battle Royale kills counter
  let playerDeaths = 0; // Battle Royale deaths counter
  
  // Super Bonuses for Battle Royale
  let superBonuses = [];
  let lastSuperBonusTime = Date.now();
  const SUPER_BONUS_INTERVAL = 15000; // Spawn every 15 seconds in Battle Royale
  const SUPER_BONUS_TYPES = [
    { type: 'dualCannon', color: 'rgba(255, 100, 100, ', icon: '‚öîÔ∏è', name: 'DUAL' },
    { type: 'forcefield', color: 'rgba(100, 180, 255, ', icon: 'üõ°Ô∏è', name: 'SHIELD' },
    { type: 'dualThruster', color: 'rgba(100, 255, 150, ', icon: 'üöÄ', name: 'BOOST' },
    { type: 'laserCanon', color: 'rgba(255, 80, 200, ', icon: 'üî´', name: 'LASER' },
    { type: 'heatSeeker', color: 'rgba(255, 200, 120, ', icon: 'üéØ', name: 'SEEKER' }
  ];
  const SUPER_BONUS_EXPANSION_TIME = 5000;
  const SUPER_BONUS_SHRINK_TIME = 4000;
  
  // Create background stars - fills entire window
  function generateStarfield() {
    stars.length = 0; // Clear existing stars
    const starCount = Math.ceil((window.innerWidth * window.innerHeight) / 8000); // ~1 star per 8000px
    for (let i = 0; i < starCount; i++) {
      stars.push({
        x: Math.random() * window.innerWidth,
        y: Math.random() * window.innerHeight,
        size: Math.random() * 1.5 + 0.5,
        opacity: Math.random() * 0.5 + 0.3
      });
    }
  }
  generateStarfield();
  
  // Regenerate stars on window resize
  window.addEventListener('resize', generateStarfield);
  
  // Track red asteroid fragments
  let redAsteroidFragments = new Set(); // IDs of fragments from red asteroid
  let redAsteroidId = 0; // Counter for unique IDs
  let dualThruster = false; // Dual thruster powerup state
  let thrusterPower = 1; // Thruster power multiplier
  let tripleCannon = false; // Triple cannon powerup (from alien)
  let cannonRange = 1; // Bullet range multiplier
  let largerForcefield = false; // Larger forcefield from alien
  
  // Track blue asteroid fragments
  let blueAsteroidFragments = new Set(); // IDs of fragments from blue asteroid
  let blueAsteroidId = 0; // Counter for unique IDs
  let energyForcefield = false; // Energy forcefield powerup state

  // Spawn Super Bonus for Battle Royale
  function spawnSuperBonus() {
    const bonusType = SUPER_BONUS_TYPES[Math.floor(Math.random() * SUPER_BONUS_TYPES.length)];
    const padding = 100;
    superBonuses.push({
      x: padding + Math.random() * (canvas.width - padding * 2),
      y: padding + Math.random() * (canvas.height - padding * 2),
      type: bonusType.type,
      color: bonusType.color,
      icon: bonusType.icon,
      name: bonusType.name,
      pulsePhase: Math.random() * Math.PI * 2,
      baseSize: 20,
      createdAt: Date.now(),
      ttl: 5000,
      expirePhase: 'active',
      expireStart: null
    });
  }

  function getSuperBonusVisualState(bonus, now) {
    let scale = 1;
    let fade = 1;

    if (bonus.expirePhase === 'expanding' && bonus.expireStart) {
      const progress = Math.min((now - bonus.expireStart) / SUPER_BONUS_EXPANSION_TIME, 1);
      scale = 1 + progress;
    } else if (bonus.expirePhase === 'shrinking' && bonus.expireStart) {
      const progress = Math.min((now - bonus.expireStart) / SUPER_BONUS_SHRINK_TIME, 1);
      scale = Math.max(0, 2 - progress * 2);
      fade = Math.max(0, 1 - progress);
    }

    return {
      radius: bonus.baseSize * scale,
      alpha: fade
    };
  }
  
  // Update Super Bonuses
  function updateSuperBonuses() {
    const gameMode = window.getGameMode ? window.getGameMode() : 'solo';
    if (gameMode !== 'anyplayer' || ship.exploded) return;
    
    const now = Date.now();

    // Check for collection or expiration
    for (let i = superBonuses.length - 1; i >= 0; i--) {
      const bonus = superBonuses[i];
      if (bonus.expirePhase === 'active' && bonus.createdAt && now - bonus.createdAt >= bonus.ttl) {
        bonus.expirePhase = 'expanding';
        bonus.expireStart = now;
      } else if (bonus.expirePhase === 'expanding' && bonus.expireStart) {
        const progress = (now - bonus.expireStart) / SUPER_BONUS_EXPANSION_TIME;
        if (progress >= 1) {
          bonus.expirePhase = 'shrinking';
          bonus.expireStart = now;
        }
      } else if (bonus.expirePhase === 'shrinking' && bonus.expireStart) {
        const progress = (now - bonus.expireStart) / SUPER_BONUS_SHRINK_TIME;
        if (progress >= 1) {
          superBonuses.splice(i, 1);
          continue;
        }
      }

      const { radius: currentRadius } = getSuperBonusVisualState(bonus, now);
      const effectiveRadius = currentRadius || bonus.baseSize;
      const dx = ship.x - bonus.x;
      const dy = ship.y - bonus.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      if (distance < ship.size + effectiveRadius) {
        // Collect the bonus
        if (bonus.type === 'dualCannon') {
          dualCannon = true;
          console.log('‚öîÔ∏è DUAL CANNON ACTIVATED! Active until death.');
        } else if (bonus.type === 'forcefield') {
          energyForcefield = true;
          console.log('üõ°Ô∏è FORCE FIELD ACTIVATED! Active until death.');
        } else if (bonus.type === 'dualThruster') {
          dualThruster = true;
          thrusterPower = 5;
          console.log('üöÄ DUAL THRUSTER ACTIVATED! 5X thrust until death.');
        } else if (bonus.type === 'laserCanon') {
          laserCanon = true;
          lastLaserShot = 0;
          tripleCannon = false;
          dualCannon = false;
          cannonRange = 1;
          console.log('üî´ LASER CANON ACTIVATED! Long-range beams ready.');
        } else if (bonus.type === 'heatSeeker') {
          heatSeekerCharges = Math.min(heatSeekerCharges + 2, HEAT_SEEKER_MAX_CHARGES);
          console.log(`üéØ HEAT SEEKERS READY! Charges: ${heatSeekerCharges}. Press S to launch.`);
        }
        
        playSound('powerup');
        playAssetAudio('powerup');
        
        // Create collection particles
        for (let j = 0; j < 20; j++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 3 + 1;
          particles.push({
            x: bonus.x,
            y: bonus.y,
            velocity: {
              x: Math.cos(angle) * speed,
              y: Math.sin(angle) * speed
            },
            life: 1,
            size: Math.random() * 3 + 1
          });
        }
        
        superBonuses.splice(i, 1);
      }
    }
  }
  
  // Draw Super Bonuses
  function drawSuperBonuses() {
    const gameMode = window.getGameMode ? window.getGameMode() : 'solo';
    if (gameMode !== 'anyplayer') return;

    const now = Date.now();
    superBonuses.forEach(bonus => {
      const { radius, alpha } = getSuperBonusVisualState(bonus, now);
      if (!radius || alpha <= 0) return;
      bonus.pulsePhase += 0.05;
      const pulse = Math.sin(bonus.pulsePhase) * 0.3 + 0.7;
      const glowSize = Math.max(1, radius + Math.sin(bonus.pulsePhase * 2) * 5);
      const visiblePulse = Math.min(1, pulse * alpha);

      ctx.save();

      // Outer glow
      const gradient = ctx.createRadialGradient(bonus.x, bonus.y, 0, bonus.x, bonus.y, glowSize);
      gradient.addColorStop(0, bonus.color + (visiblePulse * 0.8) + ')');
      gradient.addColorStop(0.5, bonus.color + (visiblePulse * 0.4) + ')');
      gradient.addColorStop(1, bonus.color + '0)');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(bonus.x, bonus.y, glowSize, 0, Math.PI * 2);
      ctx.fill();

      // Core circle
      ctx.fillStyle = bonus.color + visiblePulse + ')';
      ctx.strokeStyle = 'rgba(255, 255, 255, ' + visiblePulse + ')';
      ctx.lineWidth = 2;
      ctx.shadowColor = bonus.color + '0.8)';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(bonus.x, bonus.y, radius * pulse, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      ctx.shadowBlur = 0;

      // Icon
      ctx.font = 'bold 20px system-ui';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = 'rgba(255, 255, 255, ' + visiblePulse + ')';
      ctx.fillText(bonus.icon, bonus.x, bonus.y);

      // Label below
      ctx.font = 'bold 10px system-ui';
      ctx.fillStyle = 'rgba(255, 255, 255, ' + (visiblePulse * 0.8) + ')';
      ctx.fillText(bonus.name, bonus.x, bonus.y + radius + 15);

      ctx.restore();
    });
  }
  
  // Helper function to check if player is leading in anyplayer mode
  function isLeadingPlayer() {
    const allPlayers = window.getAllPlayers ? window.getAllPlayers() : {};
    const myScore = score;
    
    // Check if we have the highest score
    for (const player of Object.values(allPlayers)) {
      if (player.score > myScore) {
        return false;
      }
    }
    
    return Object.keys(allPlayers).length > 0; // Only show if there are other players
  }

  // Helper function to get the leading player ID in anyplayer mode
  function getLeadingPlayerId() {
    const allPlayers = window.getAllPlayers ? window.getAllPlayers() : {};
    const myPlayerId = window.getMyPlayerId ? window.getMyPlayerId() : null;
    const myKills = window.getPlayerKills ? window.getPlayerKills() : 0;
    
    let leadingPlayerId = myPlayerId;
    let maxKills = myKills;
    
    // Check all other players
    for (const [playerId, player] of Object.entries(allPlayers)) {
      const playerKills = player.kills || 0;
      if (playerKills > maxKills) {
        maxKills = playerKills;
        leadingPlayerId = playerId;
      }
    }
    
    // Only return if there are multiple players
    return Object.keys(allPlayers).length > 0 || myKills > 0 ? leadingPlayerId : null;
  }
  
  window.getLeadingPlayerId = getLeadingPlayerId;

  // Powerup sync functions for co-op
  window.getPowerups = () => {
    return {
      dualCannon,
      dualThruster,
      thrusterPower,
      energyForcefield,
      tripleCannon,
      cannonRange,
      largerForcefield,
      laserCanon,
      heatSeekerCharges
    };
  };

  function hasActivePowerups(powerups) {
    if (!powerups) return false;
    return Boolean(
      powerups.dualCannon ||
      powerups.dualThruster ||
      powerups.tripleCannon ||
      powerups.energyForcefield ||
      powerups.largerForcefield ||
      powerups.laserCanon ||
      (powerups.thrusterPower && powerups.thrusterPower > 1) ||
      (powerups.cannonRange && powerups.cannonRange > 1) ||
      (powerups.heatSeekerCharges && powerups.heatSeekerCharges > 0)
    );
  }

  function transmitPowerupsToPlayer(targetPlayerId, context = {}) {
    if (!targetPlayerId || !window.broadcastPowerupTransfer) return;
    const snapshot = window.getPowerups ? window.getPowerups() : null;
    if (!hasActivePowerups(snapshot)) return;
    window.broadcastPowerupTransfer(targetPlayerId, snapshot, context);
  }
  
  window.syncPowerups = (powerups, options = {}) => {
    if (!powerups) return;
    const mode = options.mode || (window.getGameMode ? window.getGameMode() : 'coop');
    if (mode === 'coop' || mode === 'inherit') {
      dualCannon = dualCannon || powerups.dualCannon;
      dualThruster = dualThruster || powerups.dualThruster;
      tripleCannon = tripleCannon || powerups.tripleCannon;
      thrusterPower = Math.max(thrusterPower, powerups.thrusterPower || 1);
      cannonRange = Math.max(cannonRange, powerups.cannonRange || 1);
      energyForcefield = energyForcefield || powerups.energyForcefield;
      largerForcefield = largerForcefield || powerups.largerForcefield;
      laserCanon = laserCanon || powerups.laserCanon;
      heatSeekerCharges = Math.max(heatSeekerCharges, powerups.heatSeekerCharges || 0);
    } else if (mode === 'vs') {
      dualCannon = !!powerups.dualCannon;
      dualThruster = !!powerups.dualThruster;
      tripleCannon = !!powerups.tripleCannon;
      thrusterPower = powerups.thrusterPower || 1;
      cannonRange = powerups.cannonRange || 1;
      energyForcefield = !!powerups.energyForcefield;
      largerForcefield = !!powerups.largerForcefield;
      laserCanon = !!powerups.laserCanon;
      heatSeekerCharges = powerups.heatSeekerCharges || 0;
    }
  };

  function resetOffensivePowerups() {
    dualCannon = false;
    dualThruster = false;
    thrusterPower = 1;
    tripleCannon = false;
    cannonRange = 1;
    energyForcefield = false;
    largerForcefield = false;
    laserCanon = false;
    lastLaserShot = 0;
    heatSeekerCharges = 0;
    heatSeekers.length = 0;
  }
  
  // Handle being hit by other player in VS or anyplayer mode
  window.handlePlayerHit = (attackerId = null) => {
    const gameMode = window.getGameMode ? window.getGameMode() : 'solo';
    if ((gameMode === 'vs' || gameMode === 'anyplayer') && !ship.exploded) {
      const myId = window.getMyPlayerId ? window.getMyPlayerId() : null;
      if (attackerId && myId && attackerId !== myId) {
        transmitPowerupsToPlayer(attackerId, { mode: gameMode });
      }
      lives--;
      
      // In royal mode, track deaths instead of lives
      if (gameMode === 'anyplayer') {
        playerDeaths++;
        console.log(`Hit by other player! Deaths: ${playerDeaths}/50`);
      } else {
        console.log(`Hit by other player! Lives remaining: ${lives}`);
      }
      
      resetOffensivePowerups();
      ship.exploded = true;
      ship.respawnTime = Date.now() + 3000;
      createParticles(ship.x, ship.y, 30);
      playSound('explosion');
      
      // Check game over conditions
      const shouldGameOver = gameMode === 'anyplayer' ? playerDeaths >= 50 : lives <= 0;
      
      if (shouldGameOver) {
        // Opponent killed us - they get a kill
        if (window.broadcastKill) {
          window.broadcastKill();
        }
        gameOver = true;
        const modeText = gameMode === 'anyplayer' ? 'Battle Royale' : 'VS Mode';
        console.log(`GAME OVER - Defeated in ${modeText}!`);
      }
    }
  };

  // Create initial asteroids
  function createAsteroid(x, y, size, velocity, isRed = false, fragmentId = null, isBlue = false, blueFragmentId = null) {
    // Determine if this asteroid has a prize word (only large asteroids)
    let prizeWord = null;
    const asteroidSize = size || Math.random() * 30 + 20;
    if (asteroidSize >= 60 && !isRed && !isBlue && Math.random() < 0.3) { // 30% chance for large asteroids
      const prizes = ['LASER', 'FORCE', 'THRUST'];
      prizeWord = prizes[Math.floor(Math.random() * prizes.length)];
    }

    if (prizeWord) {
      playAssetAudio('powerupinside');
    }
    
    return {
      x: x || Math.random() * canvas.width,
      y: y || Math.random() * canvas.height,
      velocity: velocity || {
        x: (Math.random() - 0.5) * 2,
        y: (Math.random() - 0.5) * 2
      },
      size: asteroidSize,
      angle: Math.random() * Math.PI * 2,
      rotation: (Math.random() - 0.5) * 0.05,
      points: generateAsteroidShape(),
      isRed: isRed,
      fragmentId: fragmentId, // Tracks which red asteroid this belongs to
      isBlue: isBlue,
      blueFragmentId: blueFragmentId, // Tracks which blue asteroid this belongs to
      prizeWord: prizeWord // Prize word for large asteroids
    };
  }
  
  // Create huge asteroid entering from edge
  function spawnHugeAsteroid() {
    const edge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
    let x, y, velocity;
    const speed = 3 + Math.random() * 2; // Faster than normal
    const size = 80 + Math.random() * 40; // Much larger (80-120)
    
    if (edge === 0) { // top
      x = Math.random() * canvas.width;
      y = -size;
      velocity = { x: (Math.random() - 0.5) * 2, y: speed };
    } else if (edge === 1) { // right
      x = canvas.width + size;
      y = Math.random() * canvas.height;
      velocity = { x: -speed, y: (Math.random() - 0.5) * 2 };
    } else if (edge === 2) { // bottom
      x = Math.random() * canvas.width;
      y = canvas.height + size;
      velocity = { x: (Math.random() - 0.5) * 2, y: -speed };
    } else { // left
      x = -size;
      y = Math.random() * canvas.height;
      velocity = { x: speed, y: (Math.random() - 0.5) * 2 };
    }
    
    // 20% chance to spawn as red asteroid, 15% chance for blue
    const rand = Math.random();
    const isRed = rand < 0.2;
    const isBlue = !isRed && rand < 0.35; // 15% chance (0.2 to 0.35)
    const fragmentId = isRed ? ++redAsteroidId : null;
    const blueFragmentId = isBlue ? ++blueAsteroidId : null;
    
    if (isRed) {
      redAsteroidFragments.add(fragmentId);
    }
    if (isBlue) {
      blueAsteroidFragments.add(blueFragmentId);
    }
    
    asteroids.push(createAsteroid(x, y, size, velocity, isRed, fragmentId, isBlue, blueFragmentId));
    console.log(`Huge asteroid spawned! Size: ${size.toFixed(0)}${isRed ? ' (RED - Dual Thruster!)' : isBlue ? ' (BLUE - Energy Forcefield!)' : ''}`);
  }
  
  // Spawn UFO
  function spawnUfo() {
    const edge = Math.floor(Math.random() * 2); // 0=left, 1=right
    const y = Math.random() * (canvas.height * 0.8) + canvas.height * 0.1; // Middle 80% of screen
    let x, velocityX;
    
    if (edge === 0) { // left side, moving right
      x = -60;
      velocityX = 2.5 + Math.random() * 1.5; // Slower (was 5-8, now 2.5-4)
    } else { // right side, moving left
      x = canvas.width + 60;
      velocityX = -(2.5 + Math.random() * 1.5); // Slower (was 5-8, now 2.5-4)
    }
    
    ufos.push({
      x,
      y,
      velocityX,
      velocityY: 0,
      targetY: y,
      size: 30,
      bobOffset: Math.random() * Math.PI * 2,
      glowPhase: 0,
      lastShotTime: Date.now(),
      aggressionLevel: Math.random() // 0-1, higher = more aggressive
    });
    playSound('ufo');
    playAssetAudio('ufo');
    console.log('UFO spawned!');
  }
  
  // Spawn rare Alien spacecraft
  function spawnAlien() {
    const edge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
    let x, y, velocityX, velocityY;
    const speed = 6 + Math.random() * 4; // Fast moving
    
    if (edge === 0) { // top
      x = Math.random() * canvas.width;
      y = -80;
      velocityX = (Math.random() - 0.5) * 4;
      velocityY = speed;
    } else if (edge === 1) { // right
      x = canvas.width + 80;
      y = Math.random() * canvas.height;
      velocityX = -speed;
      velocityY = (Math.random() - 0.5) * 4;
    } else if (edge === 2) { // bottom
      x = Math.random() * canvas.width;
      y = canvas.height + 80;
      velocityX = (Math.random() - 0.5) * 4;
      velocityY = -speed;
    } else { // left
      x = -80;
      y = Math.random() * canvas.height;
      velocityX = speed;
      velocityY = (Math.random() - 0.5) * 4;
    }
    
    aliens.push({
      x,
      y,
      velocityX,
      velocityY,
      size: 40,
      rotationAngle: 0,
      glowPhase: 0,
      pulsePhase: 0,
      health: 5 // Takes 5 hits to destroy
    });
    playSound('ufo');
    console.log('üõ∏ RARE ALIEN SPACECRAFT DETECTED!');
  }

  function spawnShootingStar() {
    if (!SHOOTING_STARS_ENABLED) return;
    const edge = Math.floor(Math.random() * 4);
    let x, y;
    if (edge === 0) { // top
      x = Math.random() * canvas.width;
      y = -SHOOTING_STAR_OUT_OF_BOUNDS;
    } else if (edge === 1) { // right
      x = canvas.width + SHOOTING_STAR_OUT_OF_BOUNDS;
      y = Math.random() * canvas.height;
    } else if (edge === 2) { // bottom
      x = Math.random() * canvas.width;
      y = canvas.height + SHOOTING_STAR_OUT_OF_BOUNDS;
    } else {
      x = -SHOOTING_STAR_OUT_OF_BOUNDS;
      y = Math.random() * canvas.height;
    }

    const target = {
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height
    };
    const angle = Math.atan2(target.y - y, target.x - x);
    const velocityX = Math.cos(angle) * SHOOTING_STAR_SPEED;
    const velocityY = Math.sin(angle) * SHOOTING_STAR_SPEED;
    const size = SHOOTING_STAR_SIZE_RANGE.min + Math.random() * (SHOOTING_STAR_SIZE_RANGE.max - SHOOTING_STAR_SIZE_RANGE.min);
    shootingStars.push({
      x,
      y,
      velocity: { x: velocityX, y: velocityY },
      size,
      angle,
      rotation: (Math.random() - 0.5) * 0.15,
      trailPhase: Math.random() * Math.PI * 2
    });
    console.log('‚ú® Shooting star rock inbound!');
  }
  
  // Update Aliens
  function updateAliens() {
    aliens.forEach((alien, index) => {
      alien.x += alien.velocityX;
      alien.y += alien.velocityY;
      alien.rotationAngle += 0.03;
      alien.glowPhase += 0.08;
      alien.pulsePhase += 0.05;
      
      // Check collision with player bullets
      bullets.forEach((bullet, bIndex) => {
        const dx = bullet.x - alien.x;
        const dy = bullet.y - alien.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < alien.size) {
          // Alien hit!
          alien.health--;
          createParticles(alien.x, alien.y, 10);
          bullets.splice(bIndex, 1);
          playSound('hit');
          
          if (alien.health <= 0) {
            // Alien destroyed! Award powerful powerups
            createParticles(alien.x, alien.y, 40);
            aliens.splice(index, 1);
            playSound('explosion');
            score += 1000; // Huge points for alien!
            
            // Award triple cannon with 2x range
            tripleCannon = true;
            cannonRange = 2;
            
            // Award super thrusters (5x power)
            dualThruster = true;
            thrusterPower = 5;
            
            // Award larger forcefield
            energyForcefield = true;
            largerForcefield = true;
            
            console.log('üéâ ALIEN DESTROYED! ULTIMATE POWERUPS UNLOCKED!');
            console.log('‚ö° Triple Cannon (2x Range) | üöÄ Super Thrusters (5x) | üõ°Ô∏è Larger Forcefield');
          }
        }
      });
      
      // Remove if off screen
      if (alien.x < -150 || alien.x > canvas.width + 150 || 
          alien.y < -150 || alien.y > canvas.height + 150) {
        aliens.splice(index, 1);
        console.log('Alien escaped!');
      }
    });
  }
  
  // Draw Aliens
  function drawAliens() {
    aliens.forEach(alien => {
      ctx.save();
      ctx.translate(alien.x, alien.y);
      ctx.rotate(alien.rotationAngle);
      
      // Powerful glow effect
      const glowIntensity = 0.5 + Math.sin(alien.glowPhase) * 0.3;
      const pulseSize = 1 + Math.sin(alien.pulsePhase) * 0.1;
      
      ctx.shadowColor = `rgba(255, 100, 255, ${glowIntensity})`;
      ctx.shadowBlur = 30;
      
      // Outer ring (rotating)
      ctx.strokeStyle = 'rgba(255, 100, 255, 0.8)';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(0, 0, alien.size * pulseSize, 0, Math.PI * 2);
      ctx.stroke();
      
      // Inner crystal core
      ctx.fillStyle = 'rgba(200, 50, 255, 0.7)';
      ctx.strokeStyle = 'rgba(255, 150, 255, 0.9)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        const r = alien.size * 0.5 * pulseSize;
        const x = Math.cos(angle) * r;
        const y = Math.sin(angle) * r;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Energy beams
      for (let i = 0; i < 3; i++) {
        const beamAngle = (i / 3) * Math.PI * 2 + alien.rotationAngle * 2;
        ctx.strokeStyle = `rgba(255, 100, 255, ${0.4 + glowIntensity * 0.3})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(beamAngle) * alien.size * 0.8, Math.sin(beamAngle) * alien.size * 0.8);
        ctx.stroke();
      }
      
      // Health indicator
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(255, 100, 255, 0.9)';
      ctx.font = 'bold 10px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText(`HP: ${alien.health}`, 0, alien.size + 15);
      
      ctx.restore();
      
      // Label
      ctx.fillStyle = 'rgba(255, 100, 255, 0.9)';
      ctx.font = 'bold 11px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('üõ∏ ALIEN', alien.x, alien.y - alien.size - 10);
    });
  }
  
  // Update UFOs
  function updateUfos() {
    ufos.forEach((ufo, index) => {
      ufo.x += ufo.velocityX;
      ufo.bobOffset += 0.05;
      ufo.glowPhase += 0.1;
      
      // Erratic vertical movement - track player
      if (!ship.exploded && ufo.x > 50 && ufo.x < canvas.width - 50) {
        // Change target Y occasionally for unpredictable movement
        if (Math.random() < 0.02) {
          // Sometimes chase player, sometimes random
          if (Math.random() < 0.7 + ufo.aggressionLevel * 0.3) {
            // Chase player Y position
            ufo.targetY = ship.y + (Math.random() - 0.5) * 100;
          } else {
            // Random Y position
            ufo.targetY = Math.random() * canvas.height;
          }
          // Keep within bounds
          ufo.targetY = Math.max(50, Math.min(canvas.height - 50, ufo.targetY));
        }
        
        // Move toward target Y
        const yDiff = ufo.targetY - ufo.y;
        ufo.velocityY = yDiff * 0.05; // Smooth movement
        ufo.y += ufo.velocityY;
      }
      
      // Check collision with ship - UFOs destroy on contact
      if (!ship.exploded && !gameOver) {
        const bobY = ufo.y + Math.sin(ufo.bobOffset) * 3;
        const dx = ship.x - ufo.x;
        const dy = ship.y - bobY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < ufo.size + ship.size) {
          if (energyForcefield) {
            // Forcefield absorbs hit and is destroyed
            energyForcefield = false;
            createParticles(ship.x, ship.y, 20);
            playSound('hit');
            console.log('üõ°Ô∏è FORCEFIELD ABSORBED UFO COLLISION!');
            // Push UFO away
            const pushAngle = Math.atan2(ufo.y - ship.y, ufo.x - ship.x);
            ufo.x += Math.cos(pushAngle) * 50;
            ufo.y += Math.sin(pushAngle) * 50;
          } else {
            // Ship destroyed by UFO collision
            lives--;
            resetOffensivePowerups();
            ship.exploded = true;
            ship.respawnTime = Date.now() + 3000;
            createParticles(ship.x, ship.y, 30);
            playSound('explosion');
            
            const currentGameMode = window.getGameMode ? window.getGameMode() : 'solo';
            if (currentGameMode === 'anyplayer') {
              playerDeaths++;
              console.log(`Ship destroyed by UFO collision! Deaths: ${playerDeaths}/50`);
              if (playerDeaths >= 50) {
                gameOver = true;
                console.log('GAME OVER!');
              }
            } else {
              console.log(`Ship destroyed by UFO collision! Lives remaining: ${lives}`);
              if (lives <= 0) {
                gameOver = true;
                console.log('GAME OVER!');
              }
            }
          }
        }
      }
      
      // Shoot at ship if not exploded and on screen - more aggressive
      if (!ship.exploded && ufo.x > 0 && ufo.x < canvas.width) {
        const now = Date.now();
        const shootInterval = 1500 - (ufo.aggressionLevel * 500); // 1.5s to 1s based on aggression
        if (now - ufo.lastShotTime > shootInterval) {
          const bobY = ufo.y + Math.sin(ufo.bobOffset) * 5;
          const dx = ship.x - ufo.x;
          const dy = ship.y - bobY;
          const angle = Math.atan2(dy, dx);
          
          ufoBullets.push({
            x: ufo.x,
            y: bobY,
            velocity: {
              x: Math.cos(angle) * 4,
              y: Math.sin(angle) * 4
            },
            life: 120
          });
          playSound('ufobullet');
          ufo.lastShotTime = now;
        }
      }
      
      // Check collision with player bullets
      bullets.forEach((bullet, bIndex) => {
        const bobY = ufo.y + Math.sin(ufo.bobOffset) * 5;
        const dx = bullet.x - ufo.x;
        const dy = bullet.y - bobY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < ufo.size) {
          // UFO destroyed!
          createParticles(ufo.x, bobY, 20);
          bullets.splice(bIndex, 1);
          ufos.splice(index, 1);
          playSound('explosion');
          score += 200; // Big points for UFO!
          dualCannon = true; // Award dual cannon powerup
          console.log('UFO destroyed! Dual cannon activated!');
        }
      });
      
      // Remove if off screen
      if (ufo.x < -100 || ufo.x > canvas.width + 100) {
        ufos.splice(index, 1);
      }
    });
  }
  
  // Update UFO bullets
  function updateUfoBullets() {
    ufoBullets.forEach((bullet, index) => {
      bullet.x += bullet.velocity.x;
      bullet.y += bullet.velocity.y;
      bullet.life--;
      
      // Check collision with ship - UFO bullets always destroy
      if (!ship.exploded) {
        const dx = bullet.x - ship.x;
        const dy = bullet.y - ship.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < ship.size) {
          // Ship hit by UFO bullet - always destroyed!
          lives--;
          resetOffensivePowerups();
          ship.exploded = true;
          ship.respawnTime = Date.now() + 3000;
          createParticles(ship.x, ship.y, 30);
          ufoBullets.splice(index, 1);
          playSound('explosion');
          
          const currentGameMode = window.getGameMode ? window.getGameMode() : 'solo';
          if (currentGameMode === 'anyplayer') {
            playerDeaths++;
            
            // Lose all powerups on death
            dualCannon = false;
            energyForcefield = false;
            dualThruster = false;
            thrusterPower = 1;
            
            console.log(`Ship destroyed by UFO bullet! Deaths: ${playerDeaths}/50`);
            if (playerDeaths >= 50) {
              gameOver = true;
              console.log('GAME OVER!');
            }
          } else {
            console.log(`Ship destroyed by UFO bullet! Lives remaining: ${lives}`);
            if (lives <= 0) {
              gameOver = true;
              console.log('GAME OVER!');
            }
          }
          return;
        }
      }
      
      if (bullet.life <= 0 || bullet.x < 0 || bullet.x > canvas.width || 
          bullet.y < 0 || bullet.y > canvas.height) {
        ufoBullets.splice(index, 1);
      }
    });
  }
  
  // Draw UFOs
  function drawUfos() {
    ufos.forEach(ufo => {
      const bobY = ufo.y + Math.sin(ufo.bobOffset) * 3; // Reduced bob for more aggressive look
      
      ctx.save();
      ctx.translate(ufo.x, bobY);
      
      // Glow effect
      const glowIntensity = 0.3 + Math.sin(ufo.glowPhase) * 0.2;
      ctx.shadowColor = `rgba(126, 240, 163, ${glowIntensity})`;
      ctx.shadowBlur = 20;
      
      // UFO dome (top)
      ctx.fillStyle = 'rgba(126, 240, 163, 0.7)';
      ctx.beginPath();
      ctx.ellipse(0, -5, ufo.size * 0.4, ufo.size * 0.3, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // UFO body (disc)
      ctx.fillStyle = 'rgba(126, 200, 255, 0.6)';
      ctx.strokeStyle = 'rgba(126, 240, 163, 0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(0, 0, ufo.size, ufo.size * 0.3, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // Windows
      ctx.fillStyle = 'rgba(255, 255, 100, 0.9)';
      for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2;
        const wx = Math.cos(angle) * ufo.size * 0.5;
        const wy = Math.sin(angle) * ufo.size * 0.15;
        ctx.beginPath();
        ctx.arc(wx, wy, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Light beam (occasionally)
      if (Math.sin(ufo.glowPhase) > 0.5) {
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(126, 240, 163, 0.15)';
        ctx.beginPath();
        ctx.moveTo(-10, ufo.size * 0.3);
        ctx.lineTo(-15, 80);
        ctx.lineTo(15, 80);
        ctx.lineTo(10, ufo.size * 0.3);
        ctx.closePath();
        ctx.fill();
      }
      
      ctx.restore();
    });
  }
  
  function generateAsteroidShape() {
    const points = [];
    const numPoints = Math.floor(Math.random() * 4) + 6;
    for (let i = 0; i < numPoints; i++) {
      const angle = (i / numPoints) * Math.PI * 2;
      const radius = 0.7 + Math.random() * 0.3;
      points.push({ angle, radius });
    }
    return points;
  }
  
  // Initialize asteroids (4 small ones) - spawn them closer and faster initially
  for (let i = 0; i < 4; i++) {
    const asteroid = createAsteroid(null, null, Math.random() * 20 + 15); // Small: 15-35px
    // Make initial asteroids faster so game feels more active at start
    asteroid.velocity = {
      x: (Math.random() - 0.5) * 4,  // Double the speed
      y: (Math.random() - 0.5) * 4
    };
    asteroids.push(asteroid);
  }
  
  // Spawn a huge asteroid right away so player sees action immediately
  console.log('Spawning initial huge asteroid...');
  spawnHugeAsteroid();
  
  // Create particle effect
  function createParticles(x, y, count) {
    // Cap total particles to 500 for performance
    if (particles.length > 500) {
      particles.splice(0, count + 50); // Remove oldest particles
    }
    for (let i = 0; i < count; i++) {
      particles.push({
        x,
        y,
        velocity: {
          x: (Math.random() - 0.5) * 4,
          y: (Math.random() - 0.5) * 4
        },
        life: 1,
        size: Math.random() * 2 + 1
      });
    }
  }
  
  function createBombExplosion(x, y) {
    playAssetAudio('bomb');
    // Create expanding shockwave rings
    const shockwaveCount = 3;
    for (let ring = 0; ring < shockwaveCount; ring++) {
      const angleCount = 16 + (ring * 8); // More particles in outer rings
      const delay = ring * 50; // Stagger the rings
      
      for (let i = 0; i < angleCount; i++) {
        const angle = (Math.PI * 2 * i) / angleCount;
        const speed = 3 + ring * 1.5; // Outer rings move faster
        
        particles.push({
          x,
          y,
          velocity: {
            x: Math.cos(angle) * speed,
            y: Math.sin(angle) * speed
          },
          life: 1 - (ring * 0.15), // Outer rings fade faster
          size: 3 - ring * 0.5,
          delay: delay
        });
      }
    }
    
    // Add some random debris in center
    for (let i = 0; i < 30; i++) {
      particles.push({
        x,
        y,
        velocity: {
          x: (Math.random() - 0.5) * 6,
          y: (Math.random() - 0.5) * 6
        },
        life: 1,
        size: Math.random() * 3 + 1
      });
    }
  }
  
  function distancePointToSegment(px, py, x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    if (dx === 0 && dy === 0) {
      return Math.hypot(px - x1, py - y1);
    }
    const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy)));
    const closestX = x1 + t * dx;
    const closestY = y1 + t * dy;
    return Math.hypot(px - closestX, py - closestY);
  }

  function laserHitsCircle(bullet, targetX, targetY, targetRadius) {
    if (!bullet || bullet.type !== 'laser') {
      return false;
    }
    const dirX = bullet.dirX || 0;
    const dirY = bullet.dirY || 0;
    if (dirX === 0 && dirY === 0) {
      return false;
    }
    const length = bullet.length || LASER_LENGTH;
    const headX = bullet.x;
    const headY = bullet.y;
    const tailX = headX - dirX * length;
    const tailY = headY - dirY * length;
    const distance = distancePointToSegment(targetX, targetY, tailX, tailY, headX, headY);
    const effectiveRadius = (bullet.width || LASER_WIDTH) + targetRadius;
    return distance <= effectiveRadius;
  }

  function acquireHeatSeekerTarget() {
    const mode = window.getGameMode ? window.getGameMode() : 'solo';
    if (mode !== 'anyplayer' && mode !== 'vs') {
      return null;
    }

    if (mode === 'vs') {
      const otherShip = window.getOtherPlayerShip ? window.getOtherPlayerShip() : null;
      const otherId = window.getOtherPlayerId ? window.getOtherPlayerId() : null;
      if (otherShip && otherId && !otherShip.exploded) {
        const dx = otherShip.x - ship.x;
        const dy = otherShip.y - ship.y;
        return {
          playerId: otherId,
          x: otherShip.x,
          y: otherShip.y,
          distance: Math.sqrt(dx * dx + dy * dy)
        };
      }
      return null;
    }

    const allPlayers = window.getAllPlayers ? window.getAllPlayers() : {};
    let closest = null;
    for (const [playerId, player] of Object.entries(allPlayers)) {
      if (!player || player.exploded) continue;
      const dx = player.x - ship.x;
      const dy = player.y - ship.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (!closest || distance < closest.distance) {
        closest = { playerId, x: player.x, y: player.y, distance };
      }
    }
    return closest;
  }

  function createHeatSeekerMissile(targetInfo) {
    const ownerId = window.getMyPlayerId ? (window.getMyPlayerId() || 'local') : 'local';
    const missile = {
      id: `hs_${ownerId}_${Date.now()}_${nextHeatSeekerId++}`,
      ownerId,
      targetId: targetInfo.playerId,
      x: ship.x,
      y: ship.y,
      velocity: {
        x: Math.cos(ship.angle) * HEAT_SEEKER_SPEED,
        y: Math.sin(ship.angle) * HEAT_SEEKER_SPEED
      },
      angle: ship.angle,
      speed: HEAT_SEEKER_SPEED,
      turnRate: HEAT_SEEKER_TURN_RATE,
      detonationRadius: HEAT_SEEKER_DETONATION_RADIUS,
      expiresAt: Date.now() + HEAT_SEEKER_DURATION,
      createdAt: Date.now(),
      auraPhase: 0,
      lastKnownTarget: { x: targetInfo.x, y: targetInfo.y }
    };
    heatSeekers.push(missile);
    if (window.broadcastHeatSeeker) {
      window.broadcastHeatSeeker(missile);
    }
    return missile;
  }

  function launchHeatSeeker() {
    const isMulti = window.isMultiplayerActive ? window.isMultiplayerActive() : false;
    const target = acquireHeatSeekerTarget();
    if (!isMulti || !target) {
      console.log('üéØ Heat seeker launch aborted (no valid multiplayer target).');
      return false;
    }
    createParticles(ship.x, ship.y, 12);
    createHeatSeekerMissile(target);
    playSound('laser');
    playAssetAudio('seek');
    console.log(`üéØ HEAT SEEKER LAUNCHED at ${target.playerId || 'target'}!`);
    return true;
  }

  function resolveHeatSeekerTargetEntity(missile) {
    const myId = window.getMyPlayerId ? window.getMyPlayerId() : null;
    if (missile.targetId && myId && missile.targetId === myId) {
      return ship.exploded ? null : ship;
    }
    const allPlayers = window.getAllPlayers ? window.getAllPlayers() : {};
    if (missile.targetId && allPlayers[missile.targetId]) {
      const target = allPlayers[missile.targetId];
      if (!target.exploded) {
        return target;
      }
    }
    const otherPlayerId = window.getOtherPlayerId ? window.getOtherPlayerId() : null;
    if (missile.targetId && otherPlayerId && missile.targetId === otherPlayerId) {
      const otherShip = window.getOtherPlayerShip ? window.getOtherPlayerShip() : null;
      if (otherShip && !otherShip.exploded) {
        return otherShip;
      }
    }
    return null;
  }

  function handleHeatSeekerImpact(missile, targetEntity, index) {
    createParticles(missile.x, missile.y, 25);
    playSound('explosion');
    heatSeekers.splice(index, 1);
    const myId = window.getMyPlayerId ? window.getMyPlayerId() : null;
    const mode = window.getGameMode ? window.getGameMode() : 'solo';
    if (missile.ownerId && myId && missile.ownerId === myId && window.broadcastPlayerHit) {
      if (mode === 'anyplayer') {
        playerKills++;
        score += 1500;
        console.log(`üéØ Heat seeker elimination! Kills: ${playerKills}`);
      }
      window.broadcastPlayerHit(missile.targetId);
    }
  }

  function updateHeatSeekers() {
    const now = Date.now();
    for (let i = heatSeekers.length - 1; i >= 0; i--) {
      const missile = heatSeekers[i];
      missile.auraPhase = (missile.auraPhase || 0) + 0.2;
      if (!missile.velocity) {
        const fallbackAngle = missile.angle || 0;
        const fallbackSpeed = missile.speed || HEAT_SEEKER_SPEED;
        missile.velocity = {
          x: Math.cos(fallbackAngle) * fallbackSpeed,
          y: Math.sin(fallbackAngle) * fallbackSpeed
        };
      }
      const target = resolveHeatSeekerTargetEntity(missile);
      if (target) {
        missile.lastKnownTarget = { x: target.x, y: target.y };
        const dx = target.x - missile.x;
        const dy = target.y - missile.y;
        const desiredAngle = Math.atan2(dy, dx);
        const currentAngle = typeof missile.angle === 'number'
          ? missile.angle
          : Math.atan2(missile.velocity.y, missile.velocity.x);
        let angleDiff = desiredAngle - currentAngle;
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
        const maxTurn = missile.turnRate || HEAT_SEEKER_TURN_RATE;
        angleDiff = Math.max(-maxTurn, Math.min(maxTurn, angleDiff));
        const newAngle = currentAngle + angleDiff;
        missile.angle = newAngle;
        const speed = missile.speed || HEAT_SEEKER_SPEED;
        missile.velocity.x = Math.cos(newAngle) * speed;
        missile.velocity.y = Math.sin(newAngle) * speed;
      } else if (missile.lastKnownTarget) {
        const dx = missile.lastKnownTarget.x - missile.x;
        const dy = missile.lastKnownTarget.y - missile.y;
        const fallbackAngle = Math.atan2(dy, dx);
        missile.velocity.x = Math.cos(fallbackAngle) * (missile.speed || HEAT_SEEKER_SPEED);
        missile.velocity.y = Math.sin(fallbackAngle) * (missile.speed || HEAT_SEEKER_SPEED);
        missile.angle = fallbackAngle;
      }

      missile.x += missile.velocity.x;
      missile.y += missile.velocity.y;
      if (missile.x < -60) missile.x = canvas.width + 60;
      if (missile.x > canvas.width + 60) missile.x = -60;
      if (missile.y < -60) missile.y = canvas.height + 60;
      if (missile.y > canvas.height + 60) missile.y = -60;

      if (target) {
        const detonationRadius = missile.detonationRadius || HEAT_SEEKER_DETONATION_RADIUS;
        const distance = Math.hypot(target.x - missile.x, target.y - missile.y);
        if (distance <= detonationRadius) {
          handleHeatSeekerImpact(missile, target, i);
          continue;
        }
      }

      if (now >= missile.expiresAt) {
        heatSeekers.splice(i, 1);
      }
    }
  }

  function drawHeatSeekers() {
    heatSeekers.forEach(missile => {
      const pulse = 0.6 + Math.sin(missile.auraPhase || 0) * 0.3;
      ctx.save();
      ctx.translate(missile.x, missile.y);
      ctx.rotate(missile.angle || 0);
      ctx.shadowColor = 'rgba(255, 200, 120, 0.7)';
      ctx.shadowBlur = 18;
      ctx.strokeStyle = `rgba(255, 200, 120, ${pulse})`;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(14, 0);
      ctx.lineTo(-12, -7);
      ctx.lineTo(-4, 0);
      ctx.lineTo(-12, 7);
      ctx.closePath();
      ctx.stroke();
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.beginPath();
      ctx.arc(0, 0, 4, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      ctx.shadowBlur = 0;
    });
  }

  // Autonomous ship AI or Manual Control
  function updateShipAI() {
    // Check if ship should respawn
    if (ship.exploded) {
      if (!gameOver && Date.now() >= ship.respawnTime) {
        ship.exploded = false;
        ship.x = canvas.width / 2;
        ship.y = canvas.height / 2;
        ship.velocity = { x: 0, y: 0 };
        ship.angle = 0;
        console.log('Ship respawned!');
      }
      return; // Don't update AI while exploded
    }
    
    // Keyboard control is always active
    const buttons = window.joystickControl.pressedButtons;
    const keyboard = window.joystickControl.keyboardState;
    const isManual = true; // Always use keyboard control
    
    if (isManual) {
      // Handle rotation (joystick or keyboard)
      if (buttons.left || keyboard.ArrowLeft) {
        ship.angle -= 0.1;
      }
      if (buttons.right || keyboard.ArrowRight) {
        ship.angle += 0.1;
      }
      
      // Handle thrust (joystick or keyboard)
      ship.thrust = buttons.up || keyboard.ArrowUp;
      if (ship.thrust) {
        ship.velocity.x += Math.cos(ship.angle) * 0.25 * thrusterPower;
        ship.velocity.y += Math.sin(ship.angle) * 0.25 * thrusterPower;
      }
      
      // Handle reverse thrust (joystick or keyboard)
      if (buttons.down || keyboard.ArrowDown) {
        ship.velocity.x -= Math.cos(ship.angle) * 0.12 * thrusterPower;
        ship.velocity.y -= Math.sin(ship.angle) * 0.12 * thrusterPower;
      }
      
      // Clamp maximum velocity for balanced gameplay
      const maxSpeed = 8;
      const speed = Math.sqrt(ship.velocity.x * ship.velocity.x + ship.velocity.y * ship.velocity.y);
      if (speed > maxSpeed) {
        const scale = maxSpeed / speed;
        ship.velocity.x *= scale;
        ship.velocity.y *= scale;
      }
      
      // Handle fire (joystick or keyboard spacebar)
      const firePressed = buttons.fire || keyboard[' '];
      const now = Date.now();
      if (laserCanon) {
        if (firePressed && now - lastLaserShot >= LASER_COOLDOWN) {
          const beamCount = Math.max(1, LASER_BEAM_COUNT);
          const midIndex = (beamCount - 1) / 2;
          const normalAngle = ship.angle + Math.PI / 2;
          for (let beamIndex = 0; beamIndex < beamCount; beamIndex++) {
            const offsetIndex = beamIndex - midIndex;
            const angleOffset = offsetIndex * LASER_SPREAD;
            const beamAngle = ship.angle + angleOffset;
            const dirX = Math.cos(beamAngle);
            const dirY = Math.sin(beamAngle);
            const lateralOffset = offsetIndex * ship.size * 0.4;
            const startX = ship.x + Math.cos(beamAngle) * LASER_MUZZLE_OFFSET + Math.cos(normalAngle) * lateralOffset;
            const startY = ship.y + Math.sin(beamAngle) * LASER_MUZZLE_OFFSET + Math.sin(normalAngle) * lateralOffset;
            const laser = {
              type: 'laser',
              x: startX,
              y: startY,
              velocity: {
                x: dirX * LASER_SPEED,
                y: dirY * LASER_SPEED
              },
              dirX,
              dirY,
              length: LASER_LENGTH,
              width: LASER_WIDTH,
              life: LASER_LIFE,
              owner: 'me'
            };
            bullets.push(laser);
            if (window.broadcastBullet) {
              window.broadcastBullet(laser);
            }
          }
          lastLaserShot = now;
          playSound('laser');
          playAssetAudio('laser');
        }
        if (!firePressed) {
          ship.lastFireState = false;
        }
      } else if (firePressed && !ship.lastFireState) {
        if (tripleCannon) {
          // Fire three bullets (center + wings) with extended range
          const leftAngle = ship.angle - Math.PI / 2;
          const rightAngle = ship.angle + Math.PI / 2;
          const offset = ship.size * 0.5;
          
          const bulletLife = 60 * cannonRange; // Extended range
          
          // Center bullet
          const centerBullet = {
            x: ship.x + Math.cos(ship.angle) * ship.size,
            y: ship.y + Math.sin(ship.angle) * ship.size,
            velocity: {
              x: Math.cos(ship.angle) * 6,
              y: Math.sin(ship.angle) * 6
            },
            life: bulletLife,
            owner: 'me'
          };
          bullets.push(centerBullet);
          
          // Left bullet
          const leftBullet = {
            x: ship.x + Math.cos(ship.angle) * ship.size + Math.cos(leftAngle) * offset,
            y: ship.y + Math.sin(ship.angle) * ship.size + Math.sin(leftAngle) * offset,
            velocity: {
              x: Math.cos(ship.angle) * 6,
              y: Math.sin(ship.angle) * 6
            },
            life: bulletLife,
            owner: 'me'
          };
          bullets.push(leftBullet);
          
          // Right bullet
          const rightBullet = {
            x: ship.x + Math.cos(ship.angle) * ship.size + Math.cos(rightAngle) * offset,
            y: ship.y + Math.sin(ship.angle) * ship.size + Math.sin(rightAngle) * offset,
            velocity: {
              x: Math.cos(ship.angle) * 6,
              y: Math.sin(ship.angle) * 6
            },
            life: bulletLife,
            owner: 'me'
          };
          bullets.push(rightBullet);
          
          // Broadcast bullets to other player
          if (window.broadcastBullet) {
            window.broadcastBullet(centerBullet);
            window.broadcastBullet(leftBullet);
            window.broadcastBullet(rightBullet);
          }
        } else if (dualCannon) {
          // Fire two bullets from wing positions
          const leftAngle = ship.angle - Math.PI / 2;
          const rightAngle = ship.angle + Math.PI / 2;
          const offset = ship.size * 0.5;
          
          const bullet1 = {
            x: ship.x + Math.cos(ship.angle) * ship.size + Math.cos(leftAngle) * offset,
            y: ship.y + Math.sin(ship.angle) * ship.size + Math.sin(leftAngle) * offset,
            velocity: {
              x: Math.cos(ship.angle) * 6,
              y: Math.sin(ship.angle) * 6
            },
            life: 60,
            owner: 'me'
          };
          const bullet2 = {
            x: ship.x + Math.cos(ship.angle) * ship.size + Math.cos(rightAngle) * offset,
            y: ship.y + Math.sin(ship.angle) * ship.size + Math.sin(rightAngle) * offset,
            velocity: {
              x: Math.cos(ship.angle) * 6,
              y: Math.sin(ship.angle) * 6
            },
            life: 60,
            owner: 'me'
          };
          bullets.push(bullet1);
          bullets.push(bullet2);
          
          // Broadcast bullets to other player
          if (window.broadcastBullet) {
            window.broadcastBullet(bullet1);
            window.broadcastBullet(bullet2);
          }
        } else {
          // Single bullet from center
          const bullet = {
            x: ship.x + Math.cos(ship.angle) * ship.size,
            y: ship.y + Math.sin(ship.angle) * ship.size,
            velocity: {
              x: Math.cos(ship.angle) * 6,
              y: Math.sin(ship.angle) * 6
            },
            life: 60,
            owner: 'me'
          };
          bullets.push(bullet);
          
          // Broadcast bullet to other player
          if (window.broadcastBullet) {
            window.broadcastBullet(bullet);
          }
        }
        playSound('shoot');
      }
      if (!laserCanon) {
        ship.lastFireState = firePressed;
      }
      
      // Handle heat seekers (S key) and hyperspace (H key)
      const heatSeekerPressed = keyboard.s || keyboard.S;
      if (heatSeekerPressed && !ship.lastHeatSeekerState) {
        if (heatSeekerCharges > 0) {
          const launched = launchHeatSeeker();
          if (launched) {
            heatSeekerCharges = Math.max(0, heatSeekerCharges - 1);
            ship.lastHeatSeekerState = true;
          }
        }
      }
      if (!heatSeekerPressed) {
        ship.lastHeatSeekerState = false;
      }

      const hyperspacePressed = keyboard.h || keyboard.H;
      if (hyperspacePressed && !ship.lastHyperspaceState && now - lastHyperspaceTime > HYPERSPACE_COOLDOWN) {
        // Activate hyperspace!
        createParticles(ship.x, ship.y, 15);
        ship.x = Math.random() * canvas.width;
        ship.y = Math.random() * canvas.height;
        ship.velocity.x = 0;
        ship.velocity.y = 0;
        createParticles(ship.x, ship.y, 15);
        lastHyperspaceTime = now;
        playSound('hyperspace');
        playAssetAudio('hyper');
        console.log('Manual hyperspace jump!');
        ship.lastHyperspaceState = true;
      }
      if (!hyperspacePressed) {
        ship.lastHyperspaceState = false;
      }
      
      // Handle bomb drop (B key) - only in anyplayer mode
      if (window.getGameMode && window.isMultiplayerActive) {
        const currentGameMode = window.getGameMode();
        const isMultiplayerActive = window.isMultiplayerActive();
        
        if ((currentGameMode === 'anyplayer' || currentGameMode === 'vs') && isMultiplayerActive) {
          const bombPressed = keyboard.b || keyboard.B;
          if (bombPressed && !ship.lastBombState && bombCount < MAX_BOMBS) {
            // Drop a bomb at current position
            const currentPlayerId = window.getMyPlayerId ? window.getMyPlayerId() : null;
            const bomb = {
              x: ship.x,
              y: ship.y,
              owner: currentPlayerId,
              life: Infinity, // Stays until hit
              pulsePhase: 0,
              createdAt: Date.now(), // Track when bomb was dropped
              countdownWarningPlayed: false
            };
            bombs.push(bomb);
            bombCount++;
            
            // Broadcast bomb to other players
            if (window.broadcastBombDropped) {
              window.broadcastBombDropped(bomb);
              console.log(`üí£ Bomb dropped! (${bombCount}/${MAX_BOMBS}) - Broadcast sent`);
            } else {
              console.log(`üí£ Bomb dropped! (${bombCount}/${MAX_BOMBS}) - ‚ö†Ô∏è No broadcast function available!`);
            }
            
            playSound('shoot'); // Use shoot sound for now
          }
          ship.lastBombState = bombPressed;
        }
      }
    } else {
      // Original autonomous AI
      ship.lastFireState = false;
      
      // Find nearest asteroid
      let nearest = null;
      let nearestDist = Infinity;
      
      asteroids.forEach(asteroid => {
        const dx = asteroid.x - ship.x;
        const dy = asteroid.y - ship.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < nearestDist) {
          nearestDist = dist;
          nearest = asteroid;
        }
      });
      
      if (nearest) {
        // Aim at nearest asteroid
        const dx = nearest.x - ship.x;
        const dy = nearest.y - ship.y;
        const targetAngle = Math.atan2(dy, dx);
        
        // Smooth rotation toward target
        let angleDiff = targetAngle - ship.angle;
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
        
        ship.angle += angleDiff * 0.05;
        
        // Shoot periodically
        if (Math.random() < 0.02 && Math.abs(angleDiff) < 0.3) {
          if (dualCannon) {
            // Fire two bullets from wing positions
            const leftAngle = ship.angle - Math.PI / 2;
            const rightAngle = ship.angle + Math.PI / 2;
            const offset = ship.size * 0.5;
            
            const bullet1 = {
              x: ship.x + Math.cos(ship.angle) * ship.size + Math.cos(leftAngle) * offset,
              y: ship.y + Math.sin(ship.angle) * ship.size + Math.sin(leftAngle) * offset,
              velocity: {
                x: Math.cos(ship.angle) * 6,
                y: Math.sin(ship.angle) * 6
              },
              life: 60,
              owner: 'me'
            };
            const bullet2 = {
              x: ship.x + Math.cos(ship.angle) * ship.size + Math.cos(rightAngle) * offset,
              y: ship.y + Math.sin(ship.angle) * ship.size + Math.sin(rightAngle) * offset,
              velocity: {
                x: Math.cos(ship.angle) * 6,
                y: Math.sin(ship.angle) * 6
              },
              life: 60,
              owner: 'me'
            };
            bullets.push(bullet1);
            bullets.push(bullet2);
            
            // Broadcast bullets to other player
            if (window.broadcastBullet) {
              window.broadcastBullet(bullet1);
              window.broadcastBullet(bullet2);
            }
          } else {
            const bullet = {
              x: ship.x + Math.cos(ship.angle) * ship.size,
              y: ship.y + Math.sin(ship.angle) * ship.size,
              velocity: {
                x: Math.cos(ship.angle) * 6,
                y: Math.sin(ship.angle) * 6
              },
              life: 60,
              owner: 'me'
            };
            bullets.push(bullet);
            
            // Broadcast bullet to other player
            if (window.broadcastBullet) {
              window.broadcastBullet(bullet);
            }
          }
          playSound('shoot');
        }
        
        // Thrust occasionally
        ship.thrust = Math.random() < 0.3;
        if (ship.thrust) {
          ship.velocity.x += Math.cos(ship.angle) * 0.1 * thrusterPower;
          ship.velocity.y += Math.sin(ship.angle) * 0.1 * thrusterPower;
          // playSound('thrust'); // Muted
        }
        
        // Use hyperspace in dangerous situations
        const now = Date.now();
        if (now - lastHyperspaceTime > HYPERSPACE_COOLDOWN) {
          // Check if in danger (nearby large asteroid or UFO bullets)
          let inDanger = false;
          
          asteroids.forEach(asteroid => {
            if (asteroid.size > 50) {
              const dx = asteroid.x - ship.x;
              const dy = asteroid.y - ship.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < 100) inDanger = true;
            }
          });
          
          ufoBullets.forEach(bullet => {
            const dx = bullet.x - ship.x;
            const dy = bullet.y - ship.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 80) inDanger = true;
          });
          
          if (inDanger && Math.random() < 0.1) {
            // Activate hyperspace!
            createParticles(ship.x, ship.y, 15);
            ship.x = Math.random() * canvas.width;
            ship.y = Math.random() * canvas.height;
            ship.velocity.x = 0;
            ship.velocity.y = 0;
            createParticles(ship.x, ship.y, 15);
            lastHyperspaceTime = now;
            playSound('hyperspace');
            playAssetAudio('hyper');
            console.log('Hyperspace jump!');
          }
        }
      }
    }
    
    // Apply velocity and friction
    ship.velocity.x *= 0.98;
    ship.velocity.y *= 0.98;
    ship.x += ship.velocity.x;
    ship.y += ship.velocity.y;
    
    // Wrap around screen
    if (ship.x < 0) ship.x = canvas.width;
    if (ship.x > canvas.width) ship.x = 0;
    if (ship.y < 0) ship.y = canvas.height;
    if (ship.y > canvas.height) ship.y = 0;
    
    // Check collision with bombs in anyplayer mode
    const currentGameMode = window.getGameMode && window.getGameMode();
    if (currentGameMode === 'anyplayer' && !ship.exploded && !gameOver) {
      const currentPlayerId = window.getMyPlayerId ? window.getMyPlayerId() : null;
      for (let i = bombs.length - 1; i >= 0; i--) {
        const bomb = bombs[i];
        // Don't hit your own bombs
        if (bomb.owner === currentPlayerId) continue;
        
        const dx = ship.x - bomb.x;
        const dy = ship.y - bomb.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 10 + ship.size) {
          // Ship hit a bomb!
          if (energyForcefield) {
            // Forcefield absorbs bomb hit
            energyForcefield = false;
            createBombExplosion(bomb.x, bomb.y);
            playSound('hit');
            console.log('üõ°Ô∏è FORCEFIELD ABSORBED BOMB!');
          } else {
            // Ship explodes!
            lives--;
            if (bomb.owner && bomb.owner !== currentPlayerId) {
              transmitPowerupsToPlayer(bomb.owner, { mode: currentGameMode, reason: 'bomb' });
            }
            resetOffensivePowerups();
            ship.exploded = true;
            ship.respawnTime = Date.now() + 3000;
            createBombExplosion(bomb.x, bomb.y);
            playSound('explosion');
            
            const currentGameMode = window.getGameMode ? window.getGameMode() : 'solo';
            if (currentGameMode === 'anyplayer') {
              playerDeaths++;
              console.log(`Ship destroyed by bomb! Deaths: ${playerDeaths}/50`);
              if (playerDeaths >= 50) {
                gameOver = true;
                console.log('GAME OVER!');
              }
            } else {
              console.log(`Ship destroyed by bomb! Lives remaining: ${lives}`);
              if (lives <= 0) {
                gameOver = true;
                console.log('GAME OVER!');
              }
            }
            
            // Notify the bomb owner they got a kill
            if (window.broadcastBombKill) {
              window.broadcastBombKill(currentPlayerId, bomb.owner);
              console.log(`üíÄ Killed by ${bomb.owner}'s bomb!`);
            }
          }
          
          // Remove bomb
          bombs.splice(i, 1);
          if (bomb.owner === currentPlayerId && bombCount > 0) {
            bombCount--;
          }
          
          // Broadcast bomb destruction
          if (window.broadcastBombDestroyed) {
            window.broadcastBombDestroyed(i);
          }
          break;
        }
      }
    }
  }
  
  // Update asteroids
  function updateAsteroids() {
    for (let index = 0; index < asteroids.length; index++) {
      const asteroid = asteroids[index];
      asteroid.x += asteroid.velocity.x;
      asteroid.y += asteroid.velocity.y;
      asteroid.angle += asteroid.rotation;
      
      // Wrap around screen
      if (asteroid.x < -50) asteroid.x = canvas.width + 50;
      if (asteroid.x > canvas.width + 50) asteroid.x = -50;
      if (asteroid.y < -50) asteroid.y = canvas.height + 50;
      if (asteroid.y > canvas.height + 50) asteroid.y = -50;
      
      // Check collision with ship (all asteroids destroy, unless forcefield is active)
      if (!ship.exploded && !gameOver) {
        const dx = ship.x - asteroid.x;
        const dy = ship.y - asteroid.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < asteroid.size + ship.size) {
          if (energyForcefield) {
            // Forcefield absorbs hit and is destroyed
            energyForcefield = false;
            createParticles(ship.x, ship.y, 20);
            playSound('hit');
            console.log('üõ°Ô∏è FORCEFIELD ABSORBED HIT!');
            // Push asteroid away
            const pushAngle = Math.atan2(asteroid.y - ship.y, asteroid.x - ship.x);
            asteroid.velocity.x += Math.cos(pushAngle) * 3;
            asteroid.velocity.y += Math.sin(pushAngle) * 3;
          } else {
            // Ship explodes!
            lives--;
            resetOffensivePowerups();
            ship.exploded = true;
            ship.respawnTime = Date.now() + 3000; // Respawn after 3 seconds
            createParticles(ship.x, ship.y, 30);
            playSound('explosion');
            
            const currentGameMode = window.getGameMode ? window.getGameMode() : 'solo';
            if (currentGameMode === 'anyplayer') {
              playerDeaths++;
              console.log(`Ship destroyed by large asteroid! Deaths: ${playerDeaths}/50`);
              if (playerDeaths >= 50) {
                gameOver = true;
                console.log('GAME OVER!');
              }
            } else {
              console.log(`Ship destroyed by large asteroid! Lives remaining: ${lives}`);
              if (lives <= 0) {
                gameOver = true;
                console.log('GAME OVER!');
              }
            }
          }
        }
      }
      
      // Check collision with bullets
      for (let bIndex = bullets.length - 1; bIndex >= 0; bIndex--) {
        const bullet = bullets[bIndex];
        const dx = bullet.x - asteroid.x;
        const dy = bullet.y - asteroid.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const hitAsteroid = bullet.type === 'laser'
          ? laserHitsCircle(bullet, asteroid.x, asteroid.y, asteroid.size)
          : dist < asteroid.size;
        
        if (hitAsteroid) {
          // Hit!
          createParticles(asteroid.x, asteroid.y, 10);
          bullets.splice(bIndex, 1);
          playSound('hit');
          
          // Award prize if asteroid has one
          if (asteroid.prizeWord) {
            if (asteroid.prizeWord === 'LASER') {
              if (!laserCanon) {
                laserCanon = true;
                lastLaserShot = 0;
                tripleCannon = false;
                dualCannon = false;
                console.log('üî´ LASER PRIZE! Laser Canon unlocked!');
                playSound('laser');
              } else if (!tripleCannon) {
                tripleCannon = true;
                cannonRange = 2;
                console.log('‚ö° LASER PRIZE! Triple Cannon with 2x Range!');
                playSound('powerup');
              } else if (!dualCannon) {
                dualCannon = true;
                console.log('‚ö° LASER PRIZE! Dual Cannon!');
                playSound('powerup');
              }
            } else if (asteroid.prizeWord === 'FORCE') {
              energyForcefield = true;
              largerForcefield = true;
              console.log('üõ°Ô∏è FORCE PRIZE! Larger Energy Forcefield!');
              playSound('powerup');
            } else if (asteroid.prizeWord === 'THRUST') {
              dualThruster = true;
              thrusterPower = Math.max(thrusterPower, 5);
              console.log('üöÄ THRUST PRIZE! Super Thrusters (5x Power)!');
              playSound('powerup');
            }
          }
          
          // Award points based on asteroid size
          if (asteroid.size >= 80) {
            score += 100; // Huge asteroid
          } else if (asteroid.size >= 40) {
            score += 50; // Large asteroid
          } else if (asteroid.size >= 20) {
            score += 25; // Medium asteroid
          } else {
            score += 10; // Small asteroid
          }
          
          const wasRed = asteroid.isRed;
          const fragmentId = asteroid.fragmentId;
          const wasBlue = asteroid.isBlue;
          const blueFragmentId = asteroid.blueFragmentId;
          
          // Split asteroid if large enough
          if (asteroid.size > 15) {
            asteroids.push(createAsteroid(asteroid.x, asteroid.y, asteroid.size / 2, null, wasRed, fragmentId, wasBlue, blueFragmentId));
            asteroids.push(createAsteroid(asteroid.x, asteroid.y, asteroid.size / 2, null, wasRed, fragmentId, wasBlue, blueFragmentId));
          } else if (wasRed && fragmentId) {
            // This was the last fragment of a red asteroid - check if all destroyed
            asteroids.splice(index, 1);
            
            // Check if any fragments of this red asteroid remain
            const remainingFragments = asteroids.filter(a => a.fragmentId === fragmentId);
            if (remainingFragments.length === 0) {
              // All fragments destroyed! Award dual thruster powerup
              dualThruster = true;
              thrusterPower = 5;
              redAsteroidFragments.delete(fragmentId);
              createParticles(asteroid.x, asteroid.y, 30); // Extra particles
              playSound('explosion');
              console.log('üî• RED ASTEROID DESTROYED! DUAL THRUSTER 5X ACTIVATED!');
              score += 500; // Bonus points!
            }
            continue; // Don't process further
          } else if (wasBlue && blueFragmentId) {
            // This was the last fragment of a blue asteroid - check if all destroyed
            asteroids.splice(index, 1);
            
            // Check if any fragments of this blue asteroid remain
            const remainingFragments = asteroids.filter(a => a.blueFragmentId === blueFragmentId);
            if (remainingFragments.length === 0) {
              // All fragments destroyed! Award energy forcefield powerup
              energyForcefield = true;
              blueAsteroidFragments.delete(blueFragmentId);
              createParticles(asteroid.x, asteroid.y, 30); // Extra particles
              playSound('explosion');
              console.log('üõ°Ô∏è BLUE ASTEROID DESTROYED! ENERGY FORCEFIELD ACTIVATED!');
              score += 500; // Bonus points!
            }
            continue; // Don't process further
          }
          asteroids.splice(index, 1);
          break; // Exit bullet check loop since asteroid is destroyed
        }
      }
      
      // Skip expensive physics for asteroids far from screen or from each other
      // Only check collisions for nearby asteroids
      const maxPhysicsDistance = 300;
      for (let otherIndex = index + 1; otherIndex < asteroids.length; otherIndex++) {
        const otherAsteroid = asteroids[otherIndex];
        
        const dx = asteroid.x - otherAsteroid.x;
        const dy = asteroid.y - otherAsteroid.y;
        const distSq = dx * dx + dy * dy; // Use squared distance to avoid sqrt
        const minDist = asteroid.size + otherAsteroid.size;
        const minDistSq = minDist * minDist;
        
        // Skip if too far apart or beyond max physics distance
        if (distSq > minDistSq + (maxPhysicsDistance * maxPhysicsDistance)) continue;
        
        const dist = Math.sqrt(distSq);
        
        if (dist < minDist && dist > 0) {
          // Collision detected - apply simplified physics
          const mass1 = asteroid.size;
          const mass2 = otherAsteroid.size;
          
          // Normalize collision vector
          const nx = dx / dist;
          const ny = dy / dist;
          
          // Relative velocity
          const dvx = asteroid.velocity.x - otherAsteroid.velocity.x;
          const dvy = asteroid.velocity.y - otherAsteroid.velocity.y;
          
          // Relative velocity in collision normal direction
          const dvn = dvx * nx + dvy * ny;
          
          // Do not resolve if velocities are separating
          if (dvn > 0) continue;
          
          // Collision impulse (simplified - linear instead of cubic mass)
          const impulse = (2 * dvn) / (mass1 + mass2);
          
          // Apply impulse to velocities
          asteroid.velocity.x -= impulse * mass2 * nx;
          asteroid.velocity.y -= impulse * mass2 * ny;
          otherAsteroid.velocity.x += impulse * mass1 * nx;
          otherAsteroid.velocity.y += impulse * mass1 * ny;
          
          // Separate asteroids to prevent overlap (simplified)
          const overlap = minDist - dist;
          const massRatio1 = mass2 / (mass1 + mass2);
          const massRatio2 = mass1 / (mass1 + mass2);
          
          asteroid.x += nx * overlap * massRatio1;
          asteroid.y += ny * overlap * massRatio1;
          otherAsteroid.x -= nx * overlap * massRatio2;
          otherAsteroid.y -= ny * overlap * massRatio2;
        }
      }
    }
    
    // Maintain asteroid count: max 3 large (>40px) and 4 small (<=40px)
    const largeAsteroids = asteroids.filter(a => a.size > 40);
    const smallAsteroids = asteroids.filter(a => a.size <= 40);
    
    // Add small asteroids if needed (max 4)
    while (smallAsteroids.length < 4) {
      const edge = Math.floor(Math.random() * 4);
      let x, y;
      if (edge === 0) { x = Math.random() * canvas.width; y = -50; }
      else if (edge === 1) { x = canvas.width + 50; y = Math.random() * canvas.height; }
      else if (edge === 2) { x = Math.random() * canvas.width; y = canvas.height + 50; }
      else { x = -50; y = Math.random() * canvas.height; }
      const size = Math.random() * 20 + 15; // Small: 15-35px
      asteroids.push(createAsteroid(x, y, size));
      smallAsteroids.push(asteroids[asteroids.length - 1]);
    }
    
    // Remove excess large asteroids (keep max 3)
    while (largeAsteroids.length > 3) {
      const index = asteroids.indexOf(largeAsteroids[largeAsteroids.length - 1]);
      if (index > -1) {
        asteroids.splice(index, 1);
        largeAsteroids.pop();
      }
    }
  }
  
  // Update shooting star rocks
  function updateShootingStars() {
    if (!SHOOTING_STARS_ENABLED) {
      if (shootingStars.length) {
        shootingStars.length = 0;
      }
      return;
    }
    for (let i = shootingStars.length - 1; i >= 0; i--) {
      const star = shootingStars[i];
      star.x += star.velocity.x;
      star.y += star.velocity.y;
      star.angle = (star.angle || 0) + (star.rotation || 0);
      star.trailPhase = (star.trailPhase || 0) + 0.25;
      
      if (!ship.exploded && !gameOver) {
        const dx = ship.x - star.x;
        const dy = ship.y - star.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < star.size + ship.size) {
          if (energyForcefield) {
            energyForcefield = false;
            createParticles(ship.x, ship.y, 20);
            playSound('hit');
            console.log('üõ°Ô∏è FORCEFIELD BLOCKED A SHOOTING STAR!');
            const pushAngle = Math.atan2(star.y - ship.y, star.x - ship.x);
            star.velocity.x += Math.cos(pushAngle) * 4;
            star.velocity.y += Math.sin(pushAngle) * 4;
          } else {
            lives--;
            dualCannon = false;
            dualThruster = false;
            thrusterPower = 1;
            tripleCannon = false;
            cannonRange = 1;
            largerForcefield = false;
            laserCanon = false;
            lastLaserShot = 0;
            ship.exploded = true;
            ship.respawnTime = Date.now() + 3000;
            createParticles(ship.x, ship.y, 30);
            playSound('explosion');
            const currentGameMode = window.getGameMode ? window.getGameMode() : 'solo';
            if (currentGameMode === 'anyplayer') {
              playerDeaths++;
              console.log(`Ship destroyed by shooting star! Deaths: ${playerDeaths}/50`);
              if (playerDeaths >= 50) {
                gameOver = true;
                console.log('GAME OVER!');
              }
            } else {
              console.log(`Ship destroyed by shooting star! Lives remaining: ${lives}`);
              if (lives <= 0) {
                gameOver = true;
                console.log('GAME OVER!');
              }
            }
            shootingStars.splice(i, 1);
            continue;
          }
        }
      }
      
      if (star.x < -SHOOTING_STAR_OUT_OF_BOUNDS || star.x > canvas.width + SHOOTING_STAR_OUT_OF_BOUNDS ||
          star.y < -SHOOTING_STAR_OUT_OF_BOUNDS || star.y > canvas.height + SHOOTING_STAR_OUT_OF_BOUNDS) {
        shootingStars.splice(i, 1);
      }
    }
  }

  // Update bullets
  function updateBullets() {
    for (let index = bullets.length - 1; index >= 0; index--) {
      const bullet = bullets[index];
      bullet.x += bullet.velocity.x;
      bullet.y += bullet.velocity.y;
      bullet.life--;
      
      // Remove dead bullets immediately
      if (bullet.life <= 0 || bullet.x < 0 || bullet.x > canvas.width || 
          bullet.y < 0 || bullet.y > canvas.height) {
        bullets.splice(index, 1);
        continue;
      }
      
      const currentGameMode = window.getGameMode && window.getGameMode();
      
      // Check collision with other players in VS or anyplayer mode
      if (currentGameMode === 'vs' || currentGameMode === 'anyplayer') {
        // Only check if this is our bullet
        if (bullet.owner === 'me') {
          if (currentGameMode === 'vs') {
            // VS mode - check collision with the other player
            const otherShip = window.getOtherPlayerShip ? window.getOtherPlayerShip() : null;
            if (otherShip && !otherShip.exploded) {
              const hitOtherShip = bullet.type === 'laser'
                ? laserHitsCircle(bullet, otherShip.x, otherShip.y, otherShip.size)
                : Math.hypot(bullet.x - otherShip.x, bullet.y - otherShip.y) < otherShip.size;
              
              if (hitOtherShip) {
                // Hit other player!
                bullets.splice(index, 1);
                createParticles(otherShip.x, otherShip.y, 15);
                playSound('explosion');
                
                // Broadcast hit
                if (window.broadcastPlayerHit) {
                  window.broadcastPlayerHit(window.getOtherPlayerId ? window.getOtherPlayerId() : null);
                }

                console.log('Hit other player!');
                continue;
              }
            }
          } else if (currentGameMode === 'anyplayer') {
            // Anyplayer mode - check collision with all other players
            const allPlayers = window.getAllPlayers ? window.getAllPlayers() : {};
            let hitPlayer = false;
            
            for (const [playerId, player] of Object.entries(allPlayers)) {
              if (player.exploded) continue;
              const hitPlayerTarget = bullet.type === 'laser'
                ? laserHitsCircle(bullet, player.x, player.y, player.size)
                : Math.hypot(bullet.x - player.x, bullet.y - player.y) < player.size;
              
              if (hitPlayerTarget) {
                // Hit another player!
                bullets.splice(index, 1);
                createParticles(player.x, player.y, 15);
                playSound('explosion');
                
                // Increment kills for hitting player
                playerKills++;
                score += 1000;
                console.log(`üíÄ Hit player ${playerId}! Kills: ${playerKills}`);
                
                // Broadcast hit to that player
                if (window.broadcastPlayerHit) {
                  window.broadcastPlayerHit(playerId);
                }

                hitPlayer = true;
                break;
              }
            }
            if (hitPlayer) continue;
          }
        }
      }
      
      // Check collision with bombs in anyplayer mode
      if (currentGameMode === 'anyplayer') {
        const currentPlayerId = window.getMyPlayerId ? window.getMyPlayerId() : null;
        let hitBomb = false;
        for (let i = bombs.length - 1; i >= 0; i--) {
          const bomb = bombs[i];
          // Don't hit your own bombs with your own bullets
          if (bomb.owner === currentPlayerId && bullet.owner === 'me') continue;
          
          const hitBombNow = bullet.type === 'laser'
            ? laserHitsCircle(bullet, bomb.x, bomb.y, 10)
            : Math.hypot(bullet.x - bomb.x, bullet.y - bomb.y) < 10;
          
          if (hitBombNow) {
            // Bullet hit bomb!
            bullets.splice(index, 1);
            
            // Explosion particles
            createBombExplosion(bomb.x, bomb.y);
            playSound('explosion');
            
            // Remove bomb
            if (bomb.owner === currentPlayerId) {
              bombCount--;
            }
            bombs.splice(i, 1);
            
            // Broadcast bomb destruction
            if (window.broadcastBombDestroyed && bullet.owner === 'me') {
              window.broadcastBombDestroyed(i);
            }
            
            score += 50; // Points for destroying bomb
            console.log('Destroyed bomb!');
            hitBomb = true;
            break;
          }
        }
        if (hitBomb) continue;
      }

      // Shooting star collisions (all modes)
      let hitStar = false;
      for (let s = shootingStars.length - 1; s >= 0; s--) {
        const star = shootingStars[s];
        const hitStarNow = bullet.type === 'laser'
          ? laserHitsCircle(bullet, star.x, star.y, star.size)
          : Math.hypot(bullet.x - star.x, bullet.y - star.y) < star.size;
        if (hitStarNow) {
          bullets.splice(index, 1);
          shootingStars.splice(s, 1);
          createParticles(star.x, star.y, 15);
          score += 75;
          playSound('hit');
          hitStar = true;
          break;
        }
      }
      if (hitStar) continue;
    }
  }
  
  // Update particles
  function updateParticles() {
    for (let index = particles.length - 1; index >= 0; index--) {
      const particle = particles[index];
      
      // Handle delayed particles (for shockwave rings)
      if (particle.delay !== undefined) {
        particle.delay -= 16; // Subtract frame time
        if (particle.delay > 0) continue; // Don't update yet
      }
      
      particle.x += particle.velocity.x;
      particle.y += particle.velocity.y;
      particle.life -= 0.02;
      
      if (particle.life <= 0) {
        particles.splice(index, 1);
      }
    }
  }
  
  function updateBombs() {
    const now = Date.now();
    const currentPlayerId = window.getMyPlayerId ? window.getMyPlayerId() : null;
    
    for (let i = bombs.length - 1; i >= 0; i--) {
      const bomb = bombs[i];
      let bombDestroyed = false;
      
      // Auto-detonate after 10 seconds
      if (bomb.createdAt && now - bomb.createdAt >= 10000) {
        // Create explosion
        createBombExplosion(bomb.x, bomb.y);
        playSound('explosion');
        bombDestroyed = true;
        console.log('üí£ Bomb auto-detonated!');
      }
      
      // Check collision with asteroids
      if (!bombDestroyed) {
        for (let j = asteroids.length - 1; j >= 0; j--) {
          const asteroid = asteroids[j];
          const dx = bomb.x - asteroid.x;
          const dy = bomb.y - asteroid.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < asteroid.size + 10) {
            // Bomb hit asteroid - both explode!
            createBombExplosion(bomb.x, bomb.y);
            createParticles(asteroid.x, asteroid.y, 15);
            playSound('explosion');
            
            // Destroy asteroid (no splitting)
            asteroids.splice(j, 1);
            bombDestroyed = true;
            
            // Award points
            if (bomb.owner === currentPlayerId) {
              score += 100;
            }
            break;
          }
        }
      }
      
      // Check collision with UFOs
      if (!bombDestroyed) {
        for (let j = ufos.length - 1; j >= 0; j--) {
          const ufo = ufos[j];
          const dx = bomb.x - ufo.x;
          const dy = bomb.y - ufo.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < ufo.size + 10) {
            // Bomb hit UFO!
            createBombExplosion(bomb.x, bomb.y);
            createParticles(ufo.x, ufo.y, 20);
            playSound('explosion');
            
            ufos.splice(j, 1);
            bombDestroyed = true;
            
            if (bomb.owner === currentPlayerId) {
              score += 500;
            }
            break;
          }
        }
      }
      
      // Check collision with aliens
      if (!bombDestroyed) {
        for (let j = aliens.length - 1; j >= 0; j--) {
          const alien = aliens[j];
          const dx = bomb.x - alien.x;
          const dy = bomb.y - alien.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < alien.size + 10) {
            // Bomb hit alien!
            createBombExplosion(bomb.x, bomb.y);
            createParticles(alien.x, alien.y, 30);
            playSound('explosion');
            
            aliens.splice(j, 1);
            bombDestroyed = true;
            
            if (bomb.owner === currentPlayerId) {
              score += 1500;
            }
            break;
          }
        }
      }

      // Check collision with shooting star rocks
      if (!bombDestroyed) {
        for (let j = shootingStars.length - 1; j >= 0; j--) {
          const star = shootingStars[j];
          const dx = bomb.x - star.x;
          const dy = bomb.y - star.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < star.size + 10) {
            createBombExplosion(bomb.x, bomb.y);
            createParticles(star.x, star.y, 20);
            playSound('explosion');
            shootingStars.splice(j, 1);
            bombDestroyed = true;
            if (bomb.owner === currentPlayerId) {
              score += 120;
            }
            break;
          }
        }
      }
      
      // Remove bomb if destroyed
      if (bombDestroyed) {
        // Decrement count if it's our bomb
        if (bomb.owner === currentPlayerId && bombCount > 0) {
          bombCount--;
        }
        
        bombs.splice(i, 1);
        
        // Broadcast destruction
        if (window.broadcastBombDestroyed) {
          window.broadcastBombDestroyed(i);
        }
      }
    }
  }
  
  // Draw functions
  function drawStars() {
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    for (let i = 0; i < stars.length; i++) {
      const star = stars[i];
      ctx.globalAlpha = star.opacity;
      ctx.fillRect(star.x, star.y, star.size, star.size);
    }
    ctx.globalAlpha = 1;
  }
  
  function drawShip() {
    if (ship.exploded) return; // Don't draw if exploded
    
    ctx.save();
    ctx.translate(ship.x, ship.y);
    ctx.rotate(ship.angle);
    
    // Check if this player is winning in anyplayer mode
    const gameMode = window.getGameMode ? window.getGameMode() : 'solo';
    const isWinning = gameMode === 'anyplayer' && isLeadingPlayer();
    
    // Draw victory flag if winning
    if (isWinning) {
      ctx.save();
      ctx.translate(-ship.size, -ship.size * 1.5);
      
      // Flag pole
      ctx.strokeStyle = 'rgba(255, 215, 0, 0.9)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, -20);
      ctx.stroke();
      
      // Animated flag
      const wave = Math.sin(Date.now() / 100) * 2;
      ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
      ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.moveTo(0, -20);
      ctx.lineTo(12 + wave, -17);
      ctx.lineTo(10 + wave, -13);
      ctx.lineTo(0, -10);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
      
      // Crown on flag
      ctx.fillStyle = 'rgba(255, 215, 0, 1)';
      ctx.font = 'bold 10px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('üëë', 6 + wave / 2, -13);
      
      ctx.restore();
    }
    
    // Draw energy forcefield if active
    if (energyForcefield) {
      const pulseIntensity = 0.5 + Math.sin(Date.now() / 200) * 0.3;
      const forcefieldSize = largerForcefield ? ship.size + 15 : ship.size + 8;
      const forcefieldColor = largerForcefield ? 'rgba(255, 100, 255, ' : 'rgba(100, 180, 255, ';
      
      ctx.strokeStyle = forcefieldColor + pulseIntensity + ')';
      ctx.lineWidth = largerForcefield ? 4 : 3;
      ctx.shadowColor = forcefieldColor + '0.8)';
      ctx.shadowBlur = largerForcefield ? 12 : 8;
      ctx.beginPath();
      ctx.arc(0, 0, forcefieldSize, 0, Math.PI * 2);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    
    // Ship body (triangle)
    ctx.strokeStyle = isWinning ? 'rgba(255, 215, 0, 0.8)' : 'rgba(126, 240, 163, 0.6)';
    ctx.fillStyle = isWinning ? 'rgba(255, 215, 0, 0.2)' : 'rgba(126, 240, 163, 0.1)';
    ctx.lineWidth = isWinning ? 3 : 2;
    if (isWinning) {
      ctx.shadowColor = 'rgba(255, 215, 0, 0.6)';
      ctx.shadowBlur = 8;
    }
    ctx.beginPath();
    ctx.moveTo(ship.size, 0);
    ctx.lineTo(-ship.size, -ship.size / 2);
    ctx.lineTo(-ship.size, ship.size / 2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    if (isWinning) {
      ctx.shadowBlur = 0;
    }
    
    // Thrust flames
    if (ship.thrust) {
      if (dualThruster) {
        // Dual thruster flames (larger and brighter)
        ctx.fillStyle = 'rgba(255, 200, 50, 0.8)';
        ctx.shadowColor = 'rgba(255, 200, 50, 0.6)';
        ctx.shadowBlur = 10;
        // Top flame
        ctx.beginPath();
        ctx.moveTo(-ship.size, -ship.size / 2.5);
        ctx.lineTo(-ship.size - 18, -ship.size / 4);
        ctx.lineTo(-ship.size, -ship.size / 6);
        ctx.closePath();
        ctx.fill();
        // Bottom flame
        ctx.beginPath();
        ctx.moveTo(-ship.size, ship.size / 2.5);
        ctx.lineTo(-ship.size - 18, ship.size / 4);
        ctx.lineTo(-ship.size, ship.size / 6);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
      } else {
        // Single thruster flame
        ctx.fillStyle = 'rgba(255, 107, 107, 0.6)';
        ctx.beginPath();
        ctx.moveTo(-ship.size, -ship.size / 3);
        ctx.lineTo(-ship.size - 10, 0);
        ctx.lineTo(-ship.size, ship.size / 3);
        ctx.closePath();
        ctx.fill();
      }
    }
    
    ctx.restore();
  }
  
  function drawAsteroids() {
    for (let i = 0; i < asteroids.length; i++) {
      const asteroid = asteroids[i];
      ctx.save();
      ctx.translate(asteroid.x, asteroid.y);
      ctx.rotate(asteroid.angle);
      
      // Special asteroids have different appearance
      if (asteroid.isRed) {
        ctx.strokeStyle = 'rgba(255, 107, 107, 0.8)';
        ctx.fillStyle = 'rgba(255, 107, 107, 0.2)';
        ctx.lineWidth = 3;
        ctx.shadowColor = 'rgba(255, 107, 107, 0.6)';
        ctx.shadowBlur = 8;
      } else if (asteroid.isBlue) {
        ctx.strokeStyle = 'rgba(100, 180, 255, 0.8)';
        ctx.fillStyle = 'rgba(100, 180, 255, 0.2)';
        ctx.lineWidth = 3;
        ctx.shadowColor = 'rgba(100, 180, 255, 0.6)';
        ctx.shadowBlur = 8;
      } else {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.lineWidth = 2;
        ctx.shadowBlur = 0;
      }
      
      ctx.beginPath();
      for (let j = 0; j < asteroid.points.length; j++) {
        const point = asteroid.points[j];
        const x = Math.cos(point.angle) * asteroid.size * point.radius;
        const y = Math.sin(point.angle) * asteroid.size * point.radius;
        if (j === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Draw prize word if present
      if (asteroid.prizeWord) {
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
        ctx.strokeStyle = 'rgba(50, 50, 50, 0.8)';
        ctx.lineWidth = 2;
        ctx.font = 'bold 12px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.strokeText(asteroid.prizeWord, 0, 0);
        ctx.fillText(asteroid.prizeWord, 0, 0);
      }
      
      ctx.restore();
    }
    
    ctx.shadowBlur = 0; // Reset shadow
  }

  function drawShootingStars() {
    if (!SHOOTING_STARS_ENABLED) {
      return;
    }
    shootingStars.forEach(star => {
      ctx.save();
      ctx.translate(star.x, star.y);
      const heading = Math.atan2(star.velocity.y, star.velocity.x);
      ctx.rotate(heading);
      const length = star.size * 3.5;
      const width = star.size * 0.5;
      const pulse = 0.7 + Math.sin(star.trailPhase || 0) * 0.3;
      ctx.shadowColor = 'rgba(255, 220, 150, 0.8)';
      ctx.shadowBlur = 18;
      ctx.fillStyle = `rgba(255, 220, 150, ${pulse})`;
      ctx.beginPath();
      ctx.moveTo(-length * 0.4, -width / 2);
      ctx.lineTo(length * 0.6, 0);
      ctx.lineTo(-length * 0.4, width / 2);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.beginPath();
      ctx.arc(0, 0, star.size * 0.35, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    });
  }
  
  function drawBullets() {
    for (let i = 0; i < bullets.length; i++) {
      const bullet = bullets[i];
      if (bullet.type === 'laser') {
        const length = bullet.length || LASER_LENGTH;
        const dirX = bullet.dirX || 0;
        const dirY = bullet.dirY || 0;
        const tailX = bullet.x - dirX * length;
        const tailY = bullet.y - dirY * length;
        ctx.strokeStyle = 'rgba(90, 190, 255, 0.92)';
        ctx.lineWidth = bullet.width || LASER_WIDTH;
        ctx.shadowColor = 'rgba(80, 160, 255, 0.7)';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.moveTo(tailX, tailY);
        ctx.lineTo(bullet.x, bullet.y);
        ctx.stroke();
        ctx.shadowBlur = 0;
      } else {
        ctx.fillStyle = 'rgba(126, 200, 255, 0.8)';
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }
  
  function drawBombs() {
    const allPlayers = window.getAllPlayers ? window.getAllPlayers() : {};
    const currentPlayerId = window.getMyPlayerId ? window.getMyPlayerId() : null;
    
    bombs.forEach(bomb => {
      // Pulsing animation
      bomb.pulsePhase = (bomb.pulsePhase || 0) + 0.1;
      const pulse = Math.sin(bomb.pulsePhase) * 0.3 + 0.7;
      const size = 8 * pulse;
      
      // Outer glow
      ctx.shadowColor = 'rgba(255, 50, 50, 0.8)';
      ctx.shadowBlur = 15 * pulse;
      
      // Get owner color if available
      let bombColor = 'rgba(255, 50, 50, 0.9)';
      const getPlayerColor = window.getPlayerColor;
      if (bomb.owner && getPlayerColor) {
        const ownerColor = getPlayerColor(bomb.owner);
        if (ownerColor && ownerColor.primary) {
          bombColor = ownerColor.primary.replace('0.7)', '0.9)');
        }
      } else if (bomb.owner && allPlayers[bomb.owner]) {
        const playerColor = allPlayers[bomb.owner].color || 0;
        const playerColorsArray = window.getPlayerColors ? window.getPlayerColors() : [];
        if (playerColorsArray.length > 0) {
          const colors = playerColorsArray[playerColor % playerColorsArray.length];
          bombColor = colors.primary;
        }
      }
      
      // Draw bomb circle
      ctx.fillStyle = bombColor;
      ctx.beginPath();
      ctx.arc(bomb.x, bomb.y, size, 0, Math.PI * 2);
      ctx.fill();
      
      // Inner core
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      ctx.beginPath();
      ctx.arc(bomb.x, bomb.y, size * 0.4, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.shadowBlur = 0;
      
      // Draw countdown timer
      if (bomb.createdAt) {
        const elapsed = Date.now() - bomb.createdAt;
        const remaining = Math.max(0, 10 - Math.floor(elapsed / 1000));

        if (typeof bomb.countdownWarningPlayed !== 'boolean') {
          bomb.countdownWarningPlayed = false;
        }

        if (remaining === 2 && !bomb.countdownWarningPlayed) {
          playAssetAudio('countdown');
          bomb.countdownWarningPlayed = true;
        }
        
        // Draw countdown with outline for visibility
        ctx.font = 'bold 20px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Black outline
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)';
        ctx.lineWidth = 4;
        ctx.strokeText(remaining.toString(), bomb.x, bomb.y);
        
        // White fill
        ctx.fillStyle = 'rgba(255, 255, 255, 1)';
        ctx.fillText(remaining.toString(), bomb.x, bomb.y);
      }
    });
  }
  
  function drawUfoBullets() {
    ctx.fillStyle = 'rgba(255, 107, 107, 0.8)';
    ctx.shadowColor = 'rgba(255, 107, 107, 0.5)';
    ctx.shadowBlur = 10;
    ufoBullets.forEach(bullet => {
      ctx.beginPath();
      ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.shadowBlur = 0;
  }
  
  function drawParticles() {
    for (let i = 0; i < particles.length; i++) {
      const particle = particles[i];
      ctx.fillStyle = `rgba(255, 255, 255, ${particle.life * 0.6})`;
      ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
    }
  }
  
  // Draw HUD (score and lives)
  function drawHUD() {
    ctx.save();
    ctx.shadowBlur = 0;
    
    // Score (top left) - or Kills in VS mode, or Kills/Deaths in anyplayer mode
    ctx.fillStyle = 'rgba(126, 240, 163, 0.9)';
    ctx.font = 'bold 24px system-ui';
    ctx.textAlign = 'left';
    const hudGameMode = window.getGameMode ? window.getGameMode() : 'solo';
    let hudDisplayText = '';
    if (hudGameMode === 'anyplayer') {
      const currentKills = window.getPlayerKills ? window.getPlayerKills() : 0;
      hudDisplayText = `Kills: ${currentKills}`;
    } else if (hudGameMode === 'vs') {
      hudDisplayText = `Kills: ${vsKills}`;
    } else {
      hudDisplayText = `Score: ${score}`;
    }
    ctx.fillText(hudDisplayText, 20, 40);
    
    // Game mode indicator
    if (window.isMultiplayerActive && window.isMultiplayerActive()) {
      const labelGameMode = window.getGameMode ? window.getGameMode() : 'coop';
      
      if (labelGameMode === 'coop') {
        ctx.fillStyle = 'rgba(100, 200, 255, 0.9)';
        ctx.font = 'bold 24px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('CO-OP', canvas.width / 2, 40);
      } else if (labelGameMode === 'vs') {
        ctx.fillStyle = 'rgba(255, 107, 107, 0.9)';
        ctx.font = 'bold 14px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('‚öîÔ∏è VS MODE', 20, 65);
      } else if (labelGameMode === 'anyplayer') {
        ctx.fillStyle = 'rgba(255, 165, 50, 0.9)';
        ctx.font = 'bold 14px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('‚öîÔ∏è BATTLE ROYALE', 20, 65);
        
        // Bomb count
        ctx.fillStyle = 'rgba(255, 100, 100, 0.9)';
        ctx.font = 'bold 16px system-ui';
        ctx.fillText(`üí£ Bombs: ${bombCount}/${MAX_BOMBS}`, 20, 87);
        
        // Heat seeker charges
        ctx.fillStyle = 'rgba(255, 220, 160, 0.95)';
        ctx.font = 'bold 16px system-ui';
        ctx.fillText(`üéØ Seekers: ${heatSeekerCharges}/${HEAT_SEEKER_MAX_CHARGES}`, 20, 107);

        // Q to Quit instruction
        ctx.fillStyle = 'rgba(200, 200, 200, 0.8)';
        ctx.font = 'bold 12px system-ui';
        ctx.fillText('Press Q to Quit', 20, 127);

        // Active powerups indicator
        const activePowerups = [];
        if (dualCannon) activePowerups.push('Dual Cannon');
        if (tripleCannon) activePowerups.push('Triple Cannon');
        if (dualThruster || thrusterPower > 1) activePowerups.push('Dual Thruster');
        if (energyForcefield) activePowerups.push(largerForcefield ? 'Mega Forcefield' : 'Forcefield');
        if (laserCanon) activePowerups.push('Laser');
        if (heatSeekerCharges > 0) activePowerups.push(`Seeker x${heatSeekerCharges}`);
        if (activePowerups.length === 0) {
          activePowerups.push('None');
        }
        ctx.fillText(`Powerups: ${activePowerups.join(', ')}`, 20, 145);
      }
    }
    
    // Lives/Deaths (top right) - show deaths in anyplayer mode, lives otherwise
    ctx.textAlign = 'right';
    const hudGameModeRight = window.getGameMode ? window.getGameMode() : 'solo';
    if (hudGameModeRight === 'anyplayer') {
      const currentDeaths = window.getPlayerDeaths ? window.getPlayerDeaths() : 0;
      ctx.fillStyle = 'rgba(255, 107, 107, 0.9)';
      ctx.font = 'bold 24px system-ui';
      ctx.fillText(`Deaths: ${currentDeaths}/50`, canvas.width - 20, 40);
    } else {
      ctx.fillText('Lives:', canvas.width - 100, 40);
      // Draw life indicators only in non-anyplayer modes
      for (let i = 0; i < lives; i++) {
        const x = canvas.width - 70 + (i * 25);
        const y = 30;
        
        ctx.save();
        ctx.translate(x, y);
        ctx.strokeStyle = 'rgba(126, 240, 163, 0.8)';
        ctx.fillStyle = 'rgba(126, 240, 163, 0.3)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.lineTo(-8, -6);
        ctx.lineTo(-8, 6);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      }
    }
    
    // Powerup indicators
    let powerupY = 70;
    if (hudGameMode === 'anyplayer') {
      // Start below the Battle Royale powerup summary line so entries don't overlap the HUD
      powerupY = 170;
    }
    if (tripleCannon) {
      ctx.fillStyle = 'rgba(255, 100, 255, 0.9)';
      ctx.font = 'bold 18px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText('‚ö° TRIPLE CANNON (2X RANGE)', 20, powerupY);
      powerupY += 30;
    } else if (dualCannon) {
      ctx.fillStyle = 'rgba(255, 200, 50, 0.9)';
      ctx.font = 'bold 18px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText('‚ö° DUAL CANNON', 20, powerupY);
      powerupY += 30;
    }
    if (dualThruster) {
      const powerText = `${thrusterPower.toFixed(0)}X POWER`;
      ctx.fillStyle = thrusterPower >= 5 ? 'rgba(255, 50, 150, 0.9)' : 'rgba(255, 140, 50, 0.9)';
      ctx.font = 'bold 18px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText(`üî• SUPER THRUSTER (${powerText})`, 20, powerupY);
      powerupY += 30;
    }
    if (laserCanon) {
      ctx.fillStyle = 'rgba(120, 205, 255, 0.95)';
      ctx.font = 'bold 18px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText('üî´ LASER CANON', 20, powerupY);
      powerupY += 30;
    }
    if (energyForcefield) {
      const forcefieldText = largerForcefield ? 'LARGER FORCEFIELD' : 'ENERGY FORCEFIELD';
      ctx.fillStyle = largerForcefield ? 'rgba(255, 100, 255, 0.9)' : 'rgba(100, 180, 255, 0.9)';
      ctx.font = 'bold 18px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText(`üõ°Ô∏è ${forcefieldText}`, 20, powerupY);
      powerupY += 30;
    }
    if (heatSeekerCharges > 0) {
      ctx.fillStyle = 'rgba(255, 220, 160, 0.95)';
      ctx.font = 'bold 18px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText(`üéØ HEAT SEEKERS (${heatSeekerCharges})`, 20, powerupY);
      powerupY += 30;
    }
    
    // Game Over message
    if (gameOver) {
      const currentGameMode = window.getGameMode ? window.getGameMode() : 'solo';
      
      ctx.fillStyle = 'rgba(255, 107, 107, 0.95)';
      ctx.font = 'bold 64px system-ui';
      ctx.textAlign = 'center';
      ctx.shadowColor = 'rgba(255, 107, 107, 0.8)';
      ctx.shadowBlur = 20;
      ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
      
      // Show appropriate message based on game mode
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.font = 'bold 24px system-ui';
      ctx.shadowBlur = 10;
      
      if (currentGameMode === 'anyplayer') {
        ctx.fillText(`Battle Royale - Kills: ${playerKills} | Deaths: ${playerDeaths}`, canvas.width / 2, canvas.height / 2 + 50);
      } else if (currentGameMode === 'vs') {
        ctx.fillText(`VS Mode - Final Kills: ${vsKills}`, canvas.width / 2, canvas.height / 2 + 50);
      } else if (currentGameMode === 'coop') {
        ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 50);
      } else {
        ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 50);
      }
      
      // Draw 'Play Again' button
      const btnX = canvas.width / 2;
      const btnY = canvas.height / 2 + 90;
      const btnWidth = 200;
      const btnHeight = 50;
      
      // Check if mouse is hovering
      const isHovering = window.playAgainHover || false;
      
      // Button background (red theme)
      ctx.fillStyle = isHovering ? 'rgba(255, 107, 107, 1)' : 'rgba(220, 80, 80, 0.9)';
      ctx.shadowBlur = isHovering ? 25 : 15;
      ctx.shadowColor = isHovering ? 'rgba(255, 107, 107, 0.9)' : 'rgba(220, 80, 80, 0.7)';
      ctx.fillRect(btnX - btnWidth / 2, btnY - btnHeight / 2, btnWidth, btnHeight);
      
      // Button border
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.lineWidth = 3;
      ctx.strokeRect(btnX - btnWidth / 2, btnY - btnHeight / 2, btnWidth, btnHeight);
      
      // Button text
      ctx.fillStyle = 'rgba(255, 255, 255, 1)';
      ctx.font = 'bold 22px system-ui';
      ctx.textAlign = 'center';
      ctx.shadowBlur = 0;
      ctx.fillText('PLAY AGAIN', btnX, btnY + 8);
    }
    
    ctx.restore();
  }
  
  // Main game loop
  let lastFrameTime = Date.now();
  let frameCount = 0;
  
  function gameLoop() {
    try {
      // Clear canvas - use clearRect for better performance
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Performance monitoring
      const currentTime = Date.now();
      frameCount++;
      
      if (!gamePaused) {
        // Check game mode - adjust spawning based on mode
        const gameMode = window.getGameMode ? window.getGameMode() : 'solo';
        const isVsMode = gameMode === 'vs';
        const isAnyPlayerMode = gameMode === 'anyplayer';
        const isMultiplayerGame = typeof window.isMultiplayerActive === 'function' ? window.isMultiplayerActive() : false;
        const isWorldAuthority = (() => {
          if (!isMultiplayerGame) return true;
          if (isAnyPlayerMode) {
            return typeof window.isAnyPlayerHostActive === 'function' ? window.isAnyPlayerHostActive() : false;
          }
          if (gameMode === 'coop' || gameMode === 'vs') {
            return typeof window.isMultiplayerHost === 'function' ? window.isMultiplayerHost() : false;
          }
          return true;
        })();
      
      if (!isVsMode) {
        const now = Date.now();
        
        // Refresh bomb count every 20 seconds in anyplayer and vs modes
        if ((isAnyPlayerMode || isVsMode) && now - lastBombRefreshTime >= BOMB_REFRESH_INTERVAL) {
          bombCount = 0; // Reset bomb count
          lastBombRefreshTime = now;
          console.log('üí£ Bomb count refreshed! You have 5 bombs available.');
        }
        
        if (isWorldAuthority) {
          // Reduced spawning in anyplayer mode (battle royale focuses on PvP)
          const asteroidMultiplier = isAnyPlayerMode ? 2.5 : 1; // 2.5x slower in anyplayer
          const ufoMultiplier = isAnyPlayerMode ? 3 : 1; // 3x slower in anyplayer
          const alienMultiplier = isAnyPlayerMode ? 4 : 1; // 4x slower in anyplayer
          
          // Spawn huge asteroid periodically
          if (now - lastHugeAsteroidTime >= HUGE_ASTEROID_INTERVAL * asteroidMultiplier) {
            spawnHugeAsteroid();
            lastHugeAsteroidTime = now;
          }
          
          // Spawn UFO randomly
          if (now - lastUfoTime >= nextUfoInterval * ufoMultiplier) {
            spawnUfo();
            lastUfoTime = now;
            nextUfoInterval = 20000 + Math.random() * 15000; // New random interval for next UFO
          }
          
          // Spawn Alien rarely
          if (now - lastAlienTime >= nextAlienInterval * alienMultiplier) {
            spawnAlien();
            lastAlienTime = now;
            nextAlienInterval = 45000 + Math.random() * 30000; // 45-75 seconds
          }

          // Spawn shooting star rocks frequently (disabled via flag)
          if (SHOOTING_STARS_ENABLED && now - lastShootingStarTime >= nextShootingStarInterval) {
            spawnShootingStar();
            lastShootingStarTime = now;
            nextShootingStarInterval = 12000 + Math.random() * 6000;
          }
          
          // Spawn Super Bonuses in Battle Royale mode
          if (isAnyPlayerMode && now - lastSuperBonusTime >= SUPER_BONUS_INTERVAL) {
            spawnSuperBonus();
            lastSuperBonusTime = now;
          }
        }
      }
      
      // Update - add try-catch to prevent crashes
      try {
        updateShipAI();
      } catch (e) {
        console.warn('Error in updateShipAI:', e.message);
      }
      
      try {
        updateAsteroids();
        updateShootingStars();
        updateAliens();
        updateUfos();
        updateUfoBullets();
        updateBullets();
        updateBombs();
        updateHeatSeekers();
        updateSuperBonuses();
      } catch (e) {
        console.warn('Error in entity updates:', e.message);
      }
      
      try {
        updateParticles();
      } catch (e) {
        console.warn('Error in updateParticles:', e.message);
      }
      
      // Check for extra life milestone
      if (score >= nextExtraLifeAt) {
        lives++;
        nextExtraLifeAt += 1000; // Next life at +1000 points
        playSound('powerup');
        console.log('üéâ EXTRA LIFE! Total lives: ' + lives);
      }
    }
    
    // Draw (always draw even when paused) - add error handling
    try {
      drawStars();
      drawAsteroids();
      drawShootingStars();
      drawAliens();
      drawUfos();
      drawUfoBullets();
      drawSuperBonuses();
      drawBombs();
      drawHeatSeekers();
      drawShip();
      drawBullets();
      drawParticles();
      drawHUD();
    } catch (e) {
      console.warn('Error in render functions:', e.message);
    }
    
    // Draw multiplayer elements (other players)
    try {
      const isMultiplayerActive = window.isMultiplayerActive && window.isMultiplayerActive();
      if (isMultiplayerActive) {
        const gameMode = window.getGameMode ? window.getGameMode() : 'solo';
        if (gameMode === 'anyplayer') {
          // Draw all players in battle royale
          if (window.drawAllPlayers) {
            window.drawAllPlayers();
          }
        } else {
          // Draw single other player in 2-player modes
          if (window.drawOtherPlayerShip) {
            window.drawOtherPlayerShip();
          }
        }
      }
    } catch (e) {
      console.warn('Error in multiplayer render:', e.message);
    }
    
    requestAnimationFrame(gameLoop);
    frameCounter++; // Increment FPS counter
    } catch (e) {
      console.error('Critical error in gameLoop:', e);
      requestAnimationFrame(gameLoop); // Keep the loop running even if there's an error
    }
  }
  
  // Start the game
  let frameCounter = 0;
  let lastFpsUpdate = Date.now();
  
  gameLoop();
  
  // FPS monitoring
  setInterval(() => {
    const now = Date.now();
    const elapsed = now - lastFpsUpdate;
    const fps = (frameCounter * 1000 / elapsed).toFixed(1);
    console.log(`[FPS: ${fps}] Game is running smoothly`);
    frameCounter = 0;
    lastFpsUpdate = now;
  }, 1000);
  
  // Expose pause state to global scope
  window.getGamePaused = () => gamePaused;
  window.setGamePaused = (paused) => { gamePaused = paused; };
  window.getSoundEnabled = () => soundEnabled;
  window.setSoundEnabled = (enabled) => { soundEnabled = enabled; };
  window.getGameOver = () => gameOver;
  window.getGameCanvas = () => canvas; // Expose canvas for Play Again button
  window.getLives = () => lives;
  window.getScore = () => score;
  window.getKills = () => vsKills;
  window.incrementKills = () => { vsKills++; };
  window.getPlayerKills = () => playerKills;
  window.setPlayerKills = (kills) => { playerKills = kills; };
  window.getPlayerDeaths = () => playerDeaths;
  window.setPlayerDeaths = (deaths) => { playerDeaths = deaths; };
  window.incrementPlayerKills = () => { playerKills++; };
  window.incrementPlayerDeaths = () => { playerDeaths++; };
  
  function deepClone(data) {
    if (data === undefined || data === null) {
      return data;
    }
    if (typeof structuredClone === 'function') {
      try {
        return structuredClone(data);
      } catch (err) {
        // Fallback to JSON clone below when structuredClone is unavailable.
      }
    }
    return JSON.parse(JSON.stringify(data));
  }

  function captureAnyPlayerState() {
    return {
      timestamp: Date.now(),
      asteroids: deepClone(asteroids),
      ufos: deepClone(ufos),
      ufoBullets: deepClone(ufoBullets),
      superBonuses: deepClone(superBonuses),
      bombs: deepClone(bombs),
      shootingStars: deepClone(shootingStars),
      heatSeekers: deepClone(heatSeekers)
    };
  }

  function syncAnyPlayerState(state = {}, options = {}) {
    if (!state || typeof state !== 'object') return;
    const copyArray = (target, source) => {
      target.length = 0;
      if (!Array.isArray(source)) return;
      source.forEach(item => {
        if (item !== null && item !== undefined) {
          target.push(item);
        }
      });
    };

    copyArray(asteroids, state.asteroids);
    copyArray(ufos, state.ufos);
    copyArray(ufoBullets, state.ufoBullets);
    copyArray(superBonuses, state.superBonuses);
    copyArray(bombs, state.bombs);
    copyArray(shootingStars, state.shootingStars);
    copyArray(heatSeekers, state.heatSeekers);

    const myId = options.myPlayerId || (window.getMyPlayerId ? window.getMyPlayerId() : null);
    if (Array.isArray(state.bombs)) {
      bombCount = state.bombs.filter(bomb => bomb && bomb.owner === myId).length;
    }
  }

  // Expose game objects for radar and multiplayer
  window.getShip = () => ship;
  window.getAsteroids = () => asteroids;
  window.getUfos = () => ufos;
  window.getAliens = () => aliens;
  window.getBullets = () => bullets;
  window.getUfoBullets = () => ufoBullets;
  window.getBombs = () => bombs;
  window.getHeatSeekers = () => heatSeekers;
  window.getShootingStars = () => shootingStars;
  window.getSuperBonuses = () => superBonuses;
  window.getLastSuperBonusTime = () => lastSuperBonusTime;
  window.getBombCount = () => bombCount;
  window.setBombCount = (count) => { bombCount = count; };
  window.addBomb = (bomb) => {
    if (bomb && typeof bomb.countdownWarningPlayed !== 'boolean') {
      bomb.countdownWarningPlayed = false;
    }
    bombs.push(bomb);
  };
  window.clearBombs = () => { bombs.length = 0; };
  window.removeBomb = (index) => { bombs.splice(index, 1); };
  window.syncSharedItems = (sharedState = {}) => {
    if (sharedState.superBonuses && Array.isArray(sharedState.superBonuses)) {
      superBonuses.length = 0;
      sharedState.superBonuses.forEach(bonus => {
        if (bonus) {
          superBonuses.push(bonus);
        }
      });
    }
    if (typeof sharedState.lastSuperBonusTime === 'number') {
      lastSuperBonusTime = sharedState.lastSuperBonusTime;
    }
  };
  window.captureAnyPlayerState = captureAnyPlayerState;
  window.applyAnyPlayerState = (state, options = {}) => {
    syncAnyPlayerState(state, options);
  };
})();

// ===== PAUSE AND SOUND CONTROLS =====
(function() {
  const pauseBtn = document.getElementById('pauseBtn');
  const soundBtn = document.getElementById('soundBtn');
  const pauseOverlay = document.getElementById('pauseOverlay');
  
  // Pause button click
  pauseBtn.addEventListener('click', function() {
    togglePause();
  });
  
  // Sound button click
  soundBtn.addEventListener('click', function() {
    toggleSound();
  });
  
  // Play Again button (on game over)
  window.playAgainHover = false;
  
  const gameCanvas = document.getElementById('asteroidCanvas');
  
  gameCanvas.addEventListener('mousemove', function(e) {
    const rect = gameCanvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    const gameOver = window.getGameOver ? window.getGameOver() : false;
    if (gameOver) {
      const btnX = gameCanvas.width / 2;
      const btnY = gameCanvas.height / 2 + 90;
      const btnWidth = 200;
      const btnHeight = 50;
      
      const isInBounds = mouseX >= btnX - btnWidth / 2 && mouseX <= btnX + btnWidth / 2 &&
                         mouseY >= btnY - btnHeight / 2 && mouseY <= btnY + btnHeight / 2;
      
      window.playAgainHover = isInBounds;
      gameCanvas.style.cursor = isInBounds ? 'pointer' : 'default';
    } else {
      gameCanvas.style.cursor = 'default';
    }
  });
  
  gameCanvas.addEventListener('click', function(e) {
    const rect = gameCanvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    const gameOver = window.getGameOver ? window.getGameOver() : false;
    console.log('Canvas clicked. GameOver:', gameOver, 'Mouse:', mouseX, mouseY);
    
    if (gameOver) {
      const btnX = gameCanvas.width / 2;
      const btnY = gameCanvas.height / 2 + 90;
      const btnWidth = 200;
      const btnHeight = 50;
      
      console.log('Button bounds:', {
        x: btnX - btnWidth / 2, 
        y: btnY - btnHeight / 2,
        width: btnWidth,
        height: btnHeight,
        mouseX: mouseX,
        mouseY: mouseY
      });
      
      const isInBounds = mouseX >= btnX - btnWidth / 2 && mouseX <= btnX + btnWidth / 2 &&
                         mouseY >= btnY - btnHeight / 2 && mouseY <= btnY + btnHeight / 2;
      
      console.log('Is in bounds:', isInBounds);
      
      if (isInBounds) {
        console.log('Play Again button clicked - reloading...');
        e.preventDefault();
        e.stopPropagation();
        window.location.reload(true);
      }
    }
  });
  
  // Alternative Play Again handler - listen for clicks anywhere when game over
  document.addEventListener('click', function(e) {
    const gameOver = window.getGameOver ? window.getGameOver() : false;
    if (!gameOver) return;
    
    // Get canvas position
    const canvas = document.getElementById('asteroidCanvas');
    const rect = canvas.getBoundingClientRect();
    
    // Check if click is within canvas bounds
    if (e.clientX < rect.left || e.clientX > rect.right || 
        e.clientY < rect.top || e.clientY > rect.bottom) {
      return; // Click outside canvas
    }
    
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    const btnX = canvas.width / 2;
    const btnY = canvas.height / 2 + 90;
    const btnWidth = 200;
    const btnHeight = 50;
    
    const isInBounds = mouseX >= btnX - btnWidth / 2 && mouseX <= btnX + btnWidth / 2 &&
                       mouseY >= btnY - btnHeight / 2 && mouseY <= btnY + btnHeight / 2;
    
    if (isInBounds) {
      console.log('Play Again clicked via document handler');
      e.preventDefault();
      e.stopPropagation();
      window.location.reload(true);
    }
  }, true); // Use capture phase to catch before other handlers
  
  // Keyboard pause toggle (P key when not in hyperspace mode)
  let lastPauseKeyTime = 0;
  const PAUSE_KEY_COOLDOWN = 300; // ms
  
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
      e.preventDefault();
      togglePause();
    }
    
    // Q key to quit Battle Royale back to lobby
    if ((e.key === 'q' || e.key === 'Q')) {
      const gameMode = window.getGameMode ? window.getGameMode() : 'solo';
      const gameOver = window.getGameOver ? window.getGameOver() : false;
      
      // Allow quitting only in Battle Royale mode
      if (gameMode === 'anyplayer') {
        e.preventDefault();
        
        // Reset game state and show lobby
        if (window.setGameOver) {
          window.setGameOver(true);
        }
        
        // Reload page to return to lobby
        window.location.reload(true);
      }
    }
  });
  
  function togglePause() {
    const currentPaused = window.getGamePaused();
    window.setGamePaused(!currentPaused);
    
    if (!currentPaused) {
      // Pausing
      pauseOverlay.classList.add('active');
      pauseBtn.classList.add('active');
      pauseBtn.textContent = '‚ñ∂';
      pauseBtn.title = 'Resume Game';
    } else {
      // Resuming
      pauseOverlay.classList.remove('active');
      pauseBtn.classList.remove('active');
      pauseBtn.textContent = '‚è∏';
      pauseBtn.title = 'Pause Game';
    }
  }
  
  function toggleSound() {
    const currentSound = window.getSoundEnabled();
    window.setSoundEnabled(!currentSound);
    
    if (!currentSound) {
      // Enabling sound
      soundBtn.classList.remove('muted');
      soundBtn.textContent = 'üîä';
      soundBtn.title = 'Mute Sound Effects';
    } else {
      // Muting sound
      soundBtn.classList.add('muted');
      soundBtn.textContent = 'üîá';
      soundBtn.title = 'Enable Sound Effects';
    }
  }
  
  // P key for pause only (H is hyperspace)
  document.addEventListener('keyup', function(e) {
    const now = Date.now();
    if ((e.key === 'p' || e.key === 'P') && now - lastPauseKeyTime > PAUSE_KEY_COOLDOWN) {
      lastPauseKeyTime = now;
      togglePause();
    }
  });
})();

// ===== RADAR SYSTEM =====
(function() {
  const radarCanvas = document.getElementById('radarCanvas');
  const radarCtx = radarCanvas.getContext('2d');
  const radarRadius = 100; // pixels
  const radarRange = 400; // game units
  let radarSweepAngle = 0;
  
  function drawRadar() {
    const centerX = radarCanvas.width / 2;
    const centerY = radarCanvas.height / 2;
    
    // Clear radar
    radarCtx.fillStyle = 'rgba(8, 16, 26, 0.3)';
    radarCtx.fillRect(0, 0, radarCanvas.width, radarCanvas.height);
    
    // Draw radar grid circles
    radarCtx.strokeStyle = 'rgba(126, 200, 255, 0.2)';
    radarCtx.lineWidth = 1;
    for (let i = 1; i <= 3; i++) {
      radarCtx.beginPath();
      radarCtx.arc(centerX, centerY, (radarRadius * i) / 3, 0, Math.PI * 2);
      radarCtx.stroke();
    }
    
    // Draw crosshairs
    radarCtx.beginPath();
    radarCtx.moveTo(centerX, 0);
    radarCtx.lineTo(centerX, radarCanvas.height);
    radarCtx.moveTo(0, centerY);
    radarCtx.lineTo(radarCanvas.width, centerY);
    radarCtx.stroke();
    
    // Draw radar sweep
    radarCtx.save();
    radarCtx.translate(centerX, centerY);
    radarCtx.rotate(radarSweepAngle);
    
    const gradient = radarCtx.createLinearGradient(0, 0, radarRadius, 0);
    gradient.addColorStop(0, 'rgba(126, 240, 163, 0.6)');
    gradient.addColorStop(1, 'rgba(126, 240, 163, 0)');
    
    radarCtx.fillStyle = gradient;
    radarCtx.beginPath();
    radarCtx.moveTo(0, 0);
    radarCtx.arc(0, 0, radarRadius, 0, Math.PI / 6);
    radarCtx.closePath();
    radarCtx.fill();
    
    radarCtx.restore();
    radarSweepAngle += 0.05;
    
    // Get game objects from exposed functions
    const ship = window.getShip ? window.getShip() : null;
    const asteroids = window.getAsteroids ? window.getAsteroids() : [];
    const ufos = window.getUfos ? window.getUfos() : [];
    const aliens = window.getAliens ? window.getAliens() : [];
    const shootingStars = window.getShootingStars ? window.getShootingStars() : [];
    
    if (!ship) {
      requestAnimationFrame(drawRadar);
      return;
    }
    
    // Draw ship at center (player) - only if not exploded
    if (!ship.exploded) {
      radarCtx.fillStyle = 'rgba(126, 240, 163, 0.9)';
      radarCtx.beginPath();
      radarCtx.arc(centerX, centerY, 3, 0, Math.PI * 2);
      radarCtx.fill();
    }
    
    // Draw red asteroids (prize asteroids)
    asteroids.forEach(asteroid => {
      if (!asteroid.isRed) return;
        
      const dx = asteroid.x - ship.x;
      const dy = asteroid.y - ship.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > radarRange) return;
      
      const radarX = centerX + (dx / radarRange) * radarRadius;
      const radarY = centerY + (dy / radarRange) * radarRadius;
      
      // Pulsing red dot for prize asteroids
      const pulse = 0.6 + Math.sin(Date.now() / 200) * 0.4;
      radarCtx.fillStyle = `rgba(255, 107, 107, ${pulse})`;
      radarCtx.shadowColor = 'rgba(255, 107, 107, 0.8)';
      radarCtx.shadowBlur = 8;
      radarCtx.beginPath();
      radarCtx.arc(radarX, radarY, 4, 0, Math.PI * 2);
      radarCtx.fill();
      radarCtx.shadowBlur = 0;
    });
    
    // Draw blue asteroids (forcefield powerup)
    asteroids.forEach(asteroid => {
      if (!asteroid.isBlue) return;
      
      const dx = asteroid.x - ship.x;
      const dy = asteroid.y - ship.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > radarRange) return;
      
      const radarX = centerX + (dx / radarRange) * radarRadius;
      const radarY = centerY + (dy / radarRange) * radarRadius;
      
      // Pulsing blue dot for forcefield asteroids
      const pulse = 0.6 + Math.sin(Date.now() / 200 + 1) * 0.4;
      radarCtx.fillStyle = `rgba(100, 180, 255, ${pulse})`;
      radarCtx.shadowColor = 'rgba(100, 180, 255, 0.8)';
      radarCtx.shadowBlur = 8;
      radarCtx.beginPath();
      radarCtx.arc(radarX, radarY, 4, 0, Math.PI * 2);
      radarCtx.fill();
      radarCtx.shadowBlur = 0;
    });
    
    // Draw UFOs (incoming craft)
    ufos.forEach(ufo => {
      const dx = ufo.x - ship.x;
      const dy = ufo.y - ship.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > radarRange) return;
      
      const radarX = centerX + (dx / radarRange) * radarRadius;
      const radarY = centerY + (dy / radarRange) * radarRadius;
      
      // Blinking yellow triangle for UFOs
      const blink = Math.sin(Date.now() / 300) > 0;
      if (blink) {
        radarCtx.fillStyle = 'rgba(255, 200, 50, 0.9)';
        radarCtx.shadowColor = 'rgba(255, 200, 50, 0.8)';
        radarCtx.shadowBlur = 10;
        radarCtx.beginPath();
        radarCtx.moveTo(radarX, radarY - 5);
        radarCtx.lineTo(radarX - 4, radarY + 3);
        radarCtx.lineTo(radarX + 4, radarY + 3);
        radarCtx.closePath();
        radarCtx.fill();
        radarCtx.shadowBlur = 0;
      }
    });
    
    // Draw Aliens (rare powerful targets)
    aliens.forEach(alien => {
      const dx = alien.x - ship.x;
      const dy = alien.y - ship.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > radarRange) return;
      
      const radarX = centerX + (dx / radarRange) * radarRadius;
      const radarY = centerY + (dy / radarRange) * radarRadius;
      
      // Pulsing purple/magenta star for aliens
      const alienPulse = 0.7 + Math.sin(Date.now() / 150) * 0.3;
      radarCtx.fillStyle = `rgba(255, 100, 255, ${alienPulse})`;
      radarCtx.shadowColor = 'rgba(255, 100, 255, 0.9)';
      radarCtx.shadowBlur = 12;
      
      // Draw star shape
      radarCtx.beginPath();
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const r = i % 2 === 0 ? 6 : 3;
        const x = radarX + Math.cos(angle) * r;
        const y = radarY + Math.sin(angle) * r;
        if (i === 0) radarCtx.moveTo(x, y);
        else radarCtx.lineTo(x, y);
      }
      radarCtx.closePath();
      radarCtx.fill();
      radarCtx.shadowBlur = 0;
    });
    
    // Draw large asteroids (threats)
    asteroids.forEach(asteroid => {
      if (asteroid.isRed || asteroid.isBlue || asteroid.size < 60) return; // Skip special and small asteroids
        
        const dx = asteroid.x - ship.x;
        const dy = asteroid.y - ship.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist > radarRange) return;
        
        const radarX = centerX + (dx / radarRange) * radarRadius;
        const radarY = centerY + (dy / radarRange) * radarRadius;
        
        // Orange dot for large threatening asteroids
        radarCtx.fillStyle = 'rgba(255, 160, 80, 0.7)';
        radarCtx.beginPath();
        radarCtx.arc(radarX, radarY, 3, 0, Math.PI * 2);
        radarCtx.fill();
    });

    // Draw shooting star rocks
    shootingStars.forEach(star => {
      const dx = star.x - ship.x;
      const dy = star.y - ship.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist > radarRange) return;
      const radarX = centerX + (dx / radarRange) * radarRadius;
      const radarY = centerY + (dy / radarRange) * radarRadius;
      radarCtx.fillStyle = 'rgba(255, 240, 180, 0.9)';
      radarCtx.shadowColor = 'rgba(255, 240, 180, 0.8)';
      radarCtx.shadowBlur = 6;
      radarCtx.beginPath();
      radarCtx.arc(radarX, radarY, 3, 0, Math.PI * 2);
      radarCtx.fill();
      radarCtx.shadowBlur = 0;
    });
    
    // Draw other players in multiplayer modes
    const gameMode = window.getGameMode ? window.getGameMode() : 'solo';
    const isMultiplayer = window.isMultiplayerActive ? window.isMultiplayerActive() : false;
    
    if (isMultiplayer) {
      if (gameMode === 'anyplayer') {
        // Draw all players in anyplayer mode with their unique colors
        const allPlayers = window.getAllPlayers ? window.getAllPlayers() : {};
        const getPlayerColor = window.getPlayerColor;
        
        Object.entries(allPlayers).forEach(([playerId, player]) => {
          if (player.exploded) return;
          
          const dx = player.x - ship.x;
          const dy = player.y - ship.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist > radarRange) return;
          
          const radarX = centerX + (dx / radarRange) * radarRadius;
          const radarY = centerY + (dy / radarRange) * radarRadius;
          
          // Get player's unique color
          const color = getPlayerColor ? getPlayerColor(playerId) : { primary: 'rgba(255, 107, 107, 0.7)' };
          const colorStr = color.primary.replace('0.7)', '0.9)');
          
          // Draw triangle for other players
          radarCtx.fillStyle = colorStr;
          radarCtx.strokeStyle = colorStr;
          radarCtx.lineWidth = 1.5;
          radarCtx.shadowColor = colorStr;
          radarCtx.shadowBlur = 6;
          radarCtx.beginPath();
          radarCtx.moveTo(radarX, radarY - 4);
          radarCtx.lineTo(radarX - 3.5, radarY + 3);
          radarCtx.lineTo(radarX + 3.5, radarY + 3);
          radarCtx.closePath();
          radarCtx.fill();
          radarCtx.stroke();
          radarCtx.shadowBlur = 0;
        });
      } else {
        // Draw single other player in 2-player modes
        const otherShip = window.getOtherPlayerShip ? window.getOtherPlayerShip() : null;
        
        if (otherShip && !otherShip.exploded) {
          const dx = otherShip.x - ship.x;
          const dy = otherShip.y - ship.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist <= radarRange) {
            const radarX = centerX + (dx / radarRange) * radarRadius;
            const radarY = centerY + (dy / radarRange) * radarRadius;
            
            // Color based on mode (red for VS, yellow for coop)
            const playerColor = gameMode === 'vs' ? 'rgba(255, 107, 107, 0.9)' : 'rgba(255, 200, 100, 0.9)';
            
            radarCtx.fillStyle = playerColor;
            radarCtx.strokeStyle = playerColor;
            radarCtx.lineWidth = 1.5;
            radarCtx.shadowColor = playerColor;
            radarCtx.shadowBlur = 6;
            radarCtx.beginPath();
            radarCtx.moveTo(radarX, radarY - 4);
            radarCtx.lineTo(radarX - 3.5, radarY + 3);
            radarCtx.lineTo(radarX + 3.5, radarY + 3);
            radarCtx.closePath();
            radarCtx.fill();
            radarCtx.stroke();
            radarCtx.shadowBlur = 0;
          }
        }
      }
    }
    
    requestAnimationFrame(drawRadar);
  }
  
  // Start radar
  drawRadar();
})();

// ===== SCREEN SAVER SYSTEM =====
(function() {
  const IDLE_TIME_MS = 300000; // 5 minutes
  const overlay = document.getElementById('screenSaverOverlay');
  const particlesContainer = document.getElementById('screensaverParticles');
  const statusEl = document.getElementById('screensaverStatus');
  
  let idleTimer = null;
  let isScreenSaverActive = false;
  let lastActivityTime = Date.now();
  
  // Create floating particles for screen saver
  function createParticles() {
    particlesContainer.innerHTML = '';
    for (let i = 0; i < 30; i++) {
      const particle = document.createElement('div');
      particle.className = 'screensaver-particle';
      
      const x = Math.random() * 100;
      const y = Math.random() * 100;
      const duration = 8 + Math.random() * 12;
      const delay = Math.random() * 5;
      const size = 1 + Math.random() * 3;
      
      particle.style.left = x + '%';
      particle.style.top = y + '%';
      particle.style.width = size + 'px';
      particle.style.height = size + 'px';
      particle.style.animation = `float ${duration}s linear ${delay}s infinite`;
      
      particlesContainer.appendChild(particle);
    }
  }
  
  // Update screen saver status with live data
  function updateScreenSaverStatus() {
    const magEl = document.getElementById('currentMag');
    const distEl = document.getElementById('distanceValue');
    
    if (magEl && distEl) {
      const mag = magEl.textContent;
      const dist = distEl.textContent;
      statusEl.textContent = `Magnitude: ${mag} | Distance: ${dist} km`;
    }
  }
  
  // Activate screen saver
  function activateScreenSaver() {
    if (isScreenSaverActive) return;
    
    isScreenSaverActive = true;
    overlay.classList.add('active');
    createParticles();
    updateScreenSaverStatus();
    
    // Update status every 10 seconds
    const statusInterval = setInterval(() => {
      if (isScreenSaverActive) {
        updateScreenSaverStatus();
      } else {
        clearInterval(statusInterval);
      }
    }, 10000);
    
    console.log('Screen saver activated');
  }
  
  // Deactivate screen saver
  function deactivateScreenSaver() {
    if (!isScreenSaverActive) return;
    
    isScreenSaverActive = false;
    overlay.classList.remove('active');
    particlesContainer.innerHTML = '';
    
    console.log('Screen saver deactivated');
  }
  
  // Reset idle timer
  function resetIdleTimer() {
    lastActivityTime = Date.now();
    
    if (isScreenSaverActive) {
      deactivateScreenSaver();
    }
    
    clearTimeout(idleTimer);
    idleTimer = setTimeout(() => {
      activateScreenSaver();
    }, IDLE_TIME_MS);
  }
  
  // Activity listeners
  const activityEvents = ['mousedown', 'mousemove', 'keydown', 'touchstart', 'click', 'scroll'];
  
  activityEvents.forEach(event => {
    document.addEventListener(event, resetIdleTimer, true);
  });
  
  // Initialize timer on page load
  resetIdleTimer();
  
  // Expose screen saver control to window for manual toggling
  window.screenSaver = {
    activate: activateScreenSaver,
    deactivate: deactivateScreenSaver,
    toggle: () => {
      if (isScreenSaverActive) {
        deactivateScreenSaver();
      } else {
        activateScreenSaver();
      }
    },
    isActive: () => isScreenSaverActive,
    setIdleTime: (ms) => {
      IDLE_TIME_MS = ms;
      resetIdleTimer();
    }
  };
  
  console.log('Screen saver system initialized. Idle timeout: ' + (IDLE_TIME_MS / 1000 / 60) + ' minutes');
})();

// ===== MULTIPLAYER SYSTEM (CO-OP, VS, ANY PLAYER) =====
(function() {
  let ws = null;
  let isWebSocketConnected = false;
  let myPlayerId = null;
  let otherPlayerId = null;
  let isMultiplayer = false;
  let isHost = false;
  let gameMode = 'solo'; // 'solo', 'coop', 'vs', 'anyplayer'
  let allPlayers = {}; // For anyplayer mode: { playerId: shipState }
  let otherPlayerShip = null;
  let otherPlayerTargetState = null; // Target state for interpolation
  let lastUpdateTime = Date.now();
  let anyPlayerHostId = null;
  let isAnyPlayerHost = false;
  let lastAnyPlayerSyncSent = 0;
  const ANYPLAYER_SYNC_INTERVAL = 250; // ms between shared-world snapshots
  const GAME_SYNC_INTERVAL = 150; // ms between co-op/VS world snapshots
  let lastGameSyncSent = 0;
  const firebaseHelpers = window.firebaseHelpers || null;
  const cloneForSync = (value) => {
    if (value === undefined || value === null) return value;
    try {
      return JSON.parse(JSON.stringify(value));
    } catch (err) {
      return null;
    }
  };

  function captureSharedGameState() {
    try {
      if (typeof window.captureAnyPlayerState === 'function') {
        const snapshot = window.captureAnyPlayerState();
        if (snapshot) {
          return snapshot;
        }
      }
    } catch (err) {
      console.warn('Failed to capture shared game state:', err.message || err);
    }
    const fallbackAsteroids = window.getAsteroids ? window.getAsteroids() : [];
    return {
      asteroids: cloneForSync(fallbackAsteroids) || []
    };
  }

  function applySharedGameStateFromHost(gameState) {
    if (!gameState) return;
    if (typeof window.applyAnyPlayerState === 'function') {
      window.applyAnyPlayerState(gameState, { myPlayerId });
      return;
    }
    const gameAsteroids = window.getAsteroids ? window.getAsteroids() : null;
    if (gameAsteroids && Array.isArray(gameState.asteroids)) {
      gameAsteroids.length = 0;
      gameState.asteroids.forEach(asteroid => {
        if (asteroid) {
          gameAsteroids.push(asteroid);
        }
      });
    }
  }

  window.applyFirebaseRemoteState = (payload) => {
    if (!payload || !payload.state) return;
    if (!isMultiplayer) return;
    const activeMode = window.getGameMode ? window.getGameMode() : gameMode;
    if (activeMode !== 'coop' && activeMode !== 'vs') return;
    if (payload.playerId && payload.playerId === myPlayerId) return;

    const state = payload.state;
    if (!otherPlayerShip) {
      otherPlayerShip = {
        x: state.x || 0,
        y: state.y || 0,
        angle: state.angle || 0,
        velocity: state.velocity || { x: 0, y: 0 },
        exploded: !!state.exploded,
        size: 15,
        thrust: !!state.thrust
      };
      otherPlayerTargetState = { ...state };
    } else {
      otherPlayerTargetState = { ...state };
    }
    lastUpdateTime = Date.now();

    if (activeMode === 'coop' && payload.powerups && window.syncPowerups) {
      window.syncPowerups(payload.powerups);
    }

    if (payload.shared && payload.meta && payload.meta.isHost && !isHost) {
      if (window.syncSharedItems) {
        window.syncSharedItems(payload.shared);
      }
      if (payload.shared.powerupsSnapshot && window.syncPowerups && activeMode === 'vs') {
        window.syncPowerups(payload.shared.powerupsSnapshot, { mode: 'vs' });
      }
    }
  };

  const firebaseSync = firebaseHelpers ? (() => {
    let db = null;
    let sessionId = null;
    let myDocRef = null;
    let partnerDocRef = null;
    let activeMode = null;
    let myId = null;
    let partnerId = null;
    let unsubscribes = [];
    let ready = false;
    let lastWriteAt = 0;
    const WRITE_INTERVAL = 120;

    const ensureDb = () => {
      if (db) return db;
      if (!window.getFirebaseApp) return null;
      db = window.getFirebaseDb ? window.getFirebaseDb() : null;
      if (!db && firebaseHelpers && firebaseHelpers.getFirestore) {
        db = firebaseHelpers.getFirestore(window.getFirebaseApp());
      }
      return db;
    };

    const buildSessionId = (mode, a, b) => {
      return `${mode || 'coop'}_${[a, b].sort().join('_')}`;
    };

    const unsubscribeAll = () => {
      unsubscribes.forEach(unsub => {
        if (typeof unsub === 'function') {
          unsub();
        }
      });
      unsubscribes = [];
    };

    async function stopSession(options = {}) {
      unsubscribeAll();
      const shouldDeletePresence = !options.silent;
      if (shouldDeletePresence && myDocRef && firebaseHelpers && firebaseHelpers.deleteDoc) {
        try {
          await firebaseHelpers.deleteDoc(myDocRef);
        } catch (err) {
          console.warn('[FirebaseSync] Failed to remove presence', err.message || err);
        }
      }
      sessionId = null;
      myDocRef = null;
      partnerDocRef = null;
      activeMode = null;
      myId = null;
      partnerId = null;
      ready = false;
    }

    async function startSession(options = {}) {
      const { mode, myPlayerId, partnerPlayerId } = options;
      if (!mode || !myPlayerId || !partnerPlayerId) return;
      if (mode === 'anyplayer' || mode === 'solo') return;
      const database = ensureDb();
      if (!database) {
        console.warn('[FirebaseSync] Firestore not available');
        return;
      }
      await stopSession({ silent: true });
      const { doc, collection, setDoc, onSnapshot, serverTimestamp } = firebaseHelpers;
      sessionId = buildSessionId(mode, myPlayerId, partnerPlayerId);
      const matchesCol = collection(database, 'matches');
      const sessionDocRef = doc(matchesCol, sessionId);
      myDocRef = doc(collection(sessionDocRef, 'players'), myPlayerId);
      partnerDocRef = doc(collection(sessionDocRef, 'players'), partnerPlayerId);
      myId = myPlayerId;
      partnerId = partnerPlayerId;
      activeMode = mode;

      try {
        await setDoc(sessionDocRef, {
          mode,
          participants: [myPlayerId, partnerPlayerId],
          updatedAt: Date.now(),
          lastServerTimestamp: serverTimestamp()
        }, { merge: true });
        await setDoc(myDocRef, {
          playerId: myPlayerId,
          status: 'online',
          updatedAt: Date.now(),
          lastServerTimestamp: serverTimestamp()
        }, { merge: true });
      } catch (err) {
        console.warn('[FirebaseSync] Failed to write session data', err.message || err);
      }

      unsubscribes.push(onSnapshot(partnerDocRef, (snapshot) => {
        if (!snapshot.exists()) return;
        if (typeof window.applyFirebaseRemoteState === 'function') {
          window.applyFirebaseRemoteState(snapshot.data());
        }
      }));

      ready = true;
      console.log(`[FirebaseSync] Session ready (${sessionId})`);
    }

    async function publishState(payload = {}) {
      if (!ready || !myDocRef || !payload.state) return;
      const now = Date.now();
      if (now - lastWriteAt < WRITE_INTERVAL) return;
      lastWriteAt = now;
      const { setDoc, serverTimestamp } = firebaseHelpers;
      try {
        await setDoc(myDocRef, {
          playerId: myId,
          mode: activeMode,
          state: payload.state,
          powerups: payload.powerups || null,
          shared: payload.shared || null,
          meta: payload.meta || null,
          updatedAt: now,
          lastServerTimestamp: serverTimestamp()
        }, { merge: true });
      } catch (err) {
        console.warn('[FirebaseSync] publishState error', err.message || err);
      }
    }

    return {
      startSession,
      publishState,
      stopSession,
      isActive: () => ready
    };
  })() : {
    startSession: () => Promise.resolve(),
    publishState: () => {},
    stopSession: () => Promise.resolve(),
    isActive: () => false
  };

  window.firebaseSyncManager = firebaseSync;

  function stopFirebaseSync(reason) {
    if (!firebaseSync || typeof firebaseSync.stopSession !== 'function') return;
    const result = firebaseSync.stopSession({ reason });
    if (result && typeof result.catch === 'function') {
      result.catch(err => console.warn('[FirebaseSync] stop error', err && err.message ? err.message : err));
    }
  }
  
  // Color palette for different players (bright, distinct colors)
  const playerColors = [
    { name: 'Red', primary: 'rgba(255, 107, 107, 0.7)', fill: 'rgba(255, 107, 107, 0.15)' },
    { name: 'Cyan', primary: 'rgba(100, 200, 255, 0.7)', fill: 'rgba(100, 200, 255, 0.15)' },
    { name: 'Green', primary: 'rgba(126, 240, 163, 0.7)', fill: 'rgba(126, 240, 163, 0.15)' },
    { name: 'Orange', primary: 'rgba(255, 165, 50, 0.7)', fill: 'rgba(255, 165, 50, 0.15)' },
    { name: 'Purple', primary: 'rgba(200, 100, 255, 0.7)', fill: 'rgba(200, 100, 255, 0.15)' },
    { name: 'Yellow', primary: 'rgba(255, 240, 100, 0.7)', fill: 'rgba(255, 240, 100, 0.15)' },
    { name: 'Pink', primary: 'rgba(255, 150, 200, 0.7)', fill: 'rgba(255, 150, 200, 0.15)' },
    { name: 'Teal', primary: 'rgba(80, 220, 200, 0.7)', fill: 'rgba(80, 220, 200, 0.15)' }
  ];
  
  // Cache for assigned colors to ensure consistency
  const playerColorMap = {};
  let nextColorIndex = 0; // Counter for assigning colors in order
  
  // Assign colors to players - consistently across all game modes
  function getPlayerColor(playerId) {
    // If already assigned, return it
    if (playerColorMap[playerId]) {
      return playerColorMap[playerId];
    }
    
    // For anyplayer mode, assign next available color
    if (gameMode === 'anyplayer') {
      const color = playerColors[nextColorIndex % playerColors.length];
      playerColorMap[playerId] = color;
      nextColorIndex++;
      return color;
    }
    
    // For 2-player modes (coop, vs), use a different approach
    // Local player gets green, other player gets their mode-appropriate color
    if (playerId === myPlayerId) {
      // Local player - always green
      const color = { name: 'Green', primary: 'rgba(126, 240, 163, 0.7)', fill: 'rgba(126, 240, 163, 0.15)' };
      playerColorMap[playerId] = color;
      return color;
    } else if (playerId === otherPlayerId || gameMode !== 'anyplayer') {
      // Other player in 2-player mode
      const color = gameMode === 'vs' 
        ? { name: 'Red', primary: 'rgba(255, 107, 107, 0.7)', fill: 'rgba(255, 107, 107, 0.15)' }
        : { name: 'Orange', primary: 'rgba(255, 165, 50, 0.7)', fill: 'rgba(255, 165, 50, 0.15)' };
      playerColorMap[playerId] = color;
      return color;
    }
    
    // Fallback
    const index = Object.keys(playerColorMap).length % playerColors.length;
    const color = playerColors[index];
    playerColorMap[playerId] = color;
    return color;
  }
  
  const lobbyOverlay = document.getElementById('lobbyOverlay');
  const lobbyStatus = document.getElementById('lobbyStatus');
  const soloPlayBtn = document.getElementById('soloPlayBtn');
  const coopPlayBtn = document.getElementById('coopPlayBtn');
  const anyPlayerBtn = document.getElementById('anyPlayerBtn');
  const anyPlayerCountBadge = document.getElementById('anyPlayerCount');
  const urlParams = new URLSearchParams(window.location.search);
  const autoModeParam = (urlParams.get('mode') || '').toLowerCase();
  const shouldAutoStartFromUrl = ['anyplayer', 'royale', 'battleroyal'].includes(autoModeParam);
  let queuedAutoStartBattleRoyale = shouldAutoStartFromUrl;
  
  // Function to update Battle Royale player count
  function updateAnyPlayerCount(count) {
    if (anyPlayerCountBadge) {
      anyPlayerCountBadge.textContent = count;
      anyPlayerCountBadge.style.display = count > 0 ? 'inline-block' : 'none';
    }
  }
  const joinRequestOverlay = document.getElementById('joinRequestOverlay');
  const acceptJoinBtn = document.getElementById('acceptJoinBtn');
  const declineJoinBtn = document.getElementById('declineJoinBtn');
  
  let pendingJoinRequest = null;
  
  // Connect to WebSocket server
  function connectWebSocket() {
    const config = window.ASTEROCKS_CONFIG || {};
    const isLocal = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    const isGitHubPages = window.location.hostname.includes('github.io');
    const isRenderApp = window.location.hostname.includes('onrender.com');
    
    // Determine the backend server host and protocol
    let host;
    let protocol;
    
    if (isLocal) {
      // Local development
      host = 'localhost:3000';
      protocol = 'ws:';
      if (config.DEBUG) {
        console.log('Using local development server:', host);
      }
    } else if (isGitHubPages && config.BACKEND_SERVER) {
      // GitHub Pages - use configured backend server
      host = config.BACKEND_SERVER;
      protocol = 'wss:';
      if (config.DEBUG) {
        console.log('GitHub Pages: Using configured backend server:', host);
      }
    } else if (isRenderApp || window.location.protocol === 'https:') {
      // Render deployment or HTTPS - use same host with WSS
      host = window.location.host;
      protocol = 'wss:';
      if (config.DEBUG) {
        console.log('Render/HTTPS: Using same-host server with WSS:', host);
      }
    } else {
      // Fallback to same host with appropriate protocol
      host = window.location.host;
      protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      if (config.DEBUG) {
        console.log('Fallback: Using same-host server:', host, 'with protocol:', protocol);
      }
    }
    
    const wsUrl = `${protocol}//${host}`;
    if (config.DEBUG) {
      console.log('Connecting to WebSocket:', wsUrl);
      console.log('Current location:', window.location.href);
      console.log('Connection mode:', isLocal ? 'local' : isGitHubPages ? 'github-pages' : isRenderApp ? 'render' : 'other');
    }
    
    // Try to connect with a timeout
    let connectionTimeout;
    ws = new WebSocket(wsUrl);
    
    connectionTimeout = setTimeout(() => {
      if (ws && ws.readyState !== WebSocket.OPEN) {
        console.warn('WebSocket connection timeout after 5 seconds - falling back to offline mode');
        console.warn('Attempting connection to:', wsUrl);
        ws.close();
        // Mark connection as failed so UI can adapt
        isWebSocketConnected = false;
        lobbyStatus.textContent = 'Playing offline - Solo and local-only modes available';
        if (config.DEBUG) {
          console.log('Check server logs at: https://dashboard.render.com/');
        }
      }
    }, 5000); // 5 second timeout
    
    ws.onopen = () => {
      clearTimeout(connectionTimeout);
      isWebSocketConnected = true;
      console.log('WebSocket connected to:', wsUrl);
      lobbyStatus.textContent = 'Connected to multiplayer server';
      if (queuedAutoStartBattleRoyale) {
        tryAutoStartBattleRoyale();
      }
    };
    
      function tryAutoStartBattleRoyale() {
        if (!queuedAutoStartBattleRoyale) return;
        if (anyPlayerBtn && !anyPlayerBtn.disabled && ws && ws.readyState === WebSocket.OPEN) {
          console.log('Auto-starting Battle Royale via queued request');
          queuedAutoStartBattleRoyale = false;
          anyPlayerBtn.click();
        }
      }
    
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      handleWebSocketMessage(data);
    };
    
    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
      console.error('WebSocket error details:', error.message || error);
      isWebSocketConnected = false;
      lobbyStatus.textContent = 'Connection error - Playing offline mode';
      anyPlayerBtn.disabled = false; // Allow offline battle royale
    };
    
    ws.onclose = () => {
      console.log('WebSocket disconnected');
      console.log(`WebSocket close code: ${ws.code}, reason: ${ws.reason}`);
      isWebSocketConnected = false;
      stopFirebaseSync('socket-closed');
      if (isMultiplayer) {
        // Show notification that other player left
        console.log('Multiplayer session ended');
        isMultiplayer = false;
        otherPlayerShip = null;
      }
    };
  }
  
  function handleWebSocketMessage(data) {
    switch(data.type) {
      case 'connected':
        myPlayerId = data.playerId;
        isHost = data.isFirstPlayer;
        console.log(`Connected as ${myPlayerId} (${isHost ? 'Host' : 'Guest'})`);
        console.log(`Other players available: ${data.otherPlayers ? data.otherPlayers.length : 0}`);
        
        if (data.otherPlayers && data.otherPlayers.length > 0) {
          lobbyStatus.textContent = 'Another player is online!';
          coopPlayBtn.disabled = false;
          vsPlayBtn.disabled = false;
          otherPlayerId = data.otherPlayers[0];
        } else {
          lobbyStatus.textContent = 'Waiting for other players...';
          coopPlayBtn.disabled = true;
          vsPlayBtn.disabled = true;
        }
        
        // Update Battle Royale player count
        if (data.anyPlayerCount !== undefined) {
          updateAnyPlayerCount(data.anyPlayerCount);
        }
        break;
        
      case 'lobby_count':
        // Update Battle Royale active player count
        if (data.count !== undefined) {
          updateAnyPlayerCount(data.count);
        }
        break;

      case 'anyplayer_host':
        anyPlayerHostId = data.hostId || null;
        isAnyPlayerHost = !!myPlayerId && anyPlayerHostId === myPlayerId;
        if (data.gameState && window.applyAnyPlayerState && !isAnyPlayerHost) {
          window.applyAnyPlayerState(data.gameState, { myPlayerId });
        }
        break;

      case 'anyplayer_state':
        if (gameMode === 'anyplayer' && data.gameState && window.applyAnyPlayerState) {
          anyPlayerHostId = data.hostId || anyPlayerHostId;
          const shouldApplyState = !isAnyPlayerHost || (data.forceApply && data.hostId === myPlayerId);
          if (shouldApplyState) {
            window.applyAnyPlayerState(data.gameState, { myPlayerId });
          }
        }
        break;
        
      case 'player_available':
        if (!isMultiplayer) {
          otherPlayerId = data.playerId;
          lobbyStatus.textContent = 'Another player is online!';
          coopPlayBtn.disabled = false;
          vsPlayBtn.disabled = false;
        }
        break;
        
      case 'join_request':
        // Another player wants to join our game
        if (!isMultiplayer) {
          pendingJoinRequest = data.playerId;
          const mode = data.mode || 'coop';
          console.log(`Received join_request from ${data.playerId} with mode: ${mode}`);
          const joinRequestMessage = document.getElementById('joinRequestMessage');
          const joinRequestMode = document.getElementById('joinRequestMode');
          
          if (mode === 'vs') {
            joinRequestMessage.textContent = 'Another player wants to battle you!';
            joinRequestMode.textContent = '‚öîÔ∏è VS MODE (PvP)';
            joinRequestMode.style.color = '#ff6b6b';
          } else {
            joinRequestMessage.textContent = 'Another player wants to join your game!';
            joinRequestMode.textContent = 'ü§ù CO-OP MODE';
            joinRequestMode.style.color = '#7ef0a3';
          }
          
          pendingJoinRequestMode = mode;
          console.log(`Set pendingJoinRequestMode to: ${pendingJoinRequestMode}`);
          joinRequestOverlay.classList.add('active');
        }
        break;
        
      case 'join_response':
        console.log(`Received join_response: accepted=${data.accepted}, mode=${data.mode}`);
        if (data.accepted) {
          console.log(`Calling startMultiplayerGame with mode: ${data.mode || 'coop'}`);
          startMultiplayerGame(data.playerId, data.mode || 'coop');
          // Store the other player's ID with their mode to ensure proper routing
          otherPlayerId = data.playerId;
        } else {
          alert('Join request declined');
          lobbyOverlay.classList.add('active');
          coopPlayBtn.disabled = false;
          vsPlayBtn.disabled = false;
          soloPlayBtn.disabled = false;
        }
        break;
        
      case 'player_state':
        // Update other player's ship with interpolation
        if (data.playerId !== myPlayerId && isMultiplayer) {
          console.log(`Received player_state from ${data.playerId}: x=${data.state.x.toFixed(0)}, y=${data.state.y.toFixed(0)}, gameMode=${gameMode}`);
          if (gameMode === 'anyplayer') {
            // In anyplayer mode, track all players
            if (!allPlayers[data.playerId]) {
              allPlayers[data.playerId] = {
                x: data.state.x,
                y: data.state.y,
                angle: data.state.angle,
                velocity: data.state.velocity,
                exploded: data.state.exploded,
                size: 15,
                thrust: data.state.thrust || false,
                lives: data.state.lives || 3,
                score: data.state.score || 0,
                kills: data.state.kills || 0,
                deaths: data.state.deaths || 0
              };
              console.log(`  Created new player entry in anyplayer mode: ${data.playerId}`);
            } else {
              // Update existing player
              Object.assign(allPlayers[data.playerId], data.state);
            }
          } else {
            // Regular 2-player mode
            console.log(`  Updating 2-player mode: otherPlayerId=${otherPlayerId}, incomingPlayerId=${data.playerId}`);
            if (!otherPlayerShip) {
              otherPlayerShip = {
                x: data.state.x,
                y: data.state.y,
                angle: data.state.angle,
                velocity: data.state.velocity,
                exploded: data.state.exploded,
                size: 15,
                thrust: data.state.thrust || false
              };
              otherPlayerTargetState = { ...data.state };
              console.log(`  Created otherPlayerShip at (${data.state.x.toFixed(0)}, ${data.state.y.toFixed(0)})`);
            } else {
              // Set target state for smooth interpolation
              otherPlayerTargetState = { ...data.state };
              lastUpdateTime = Date.now();
              console.log(`  Updated otherPlayerShip target to (${data.state.x.toFixed(0)}, ${data.state.y.toFixed(0)})`);
            }
          }
        } else {
          if (data.playerId === myPlayerId) {
            console.log(`  Ignoring player_state from self (${myPlayerId})`);
          } else if (!isMultiplayer) {
            console.log(`  Ignoring player_state because isMultiplayer=${isMultiplayer}`);
          }
        }
        break;
        
      case 'game_state':
        // Sync game state from host (if we're not host)
        if (!isHost && isMultiplayer && (gameMode === 'coop' || gameMode === 'vs')) {
          if (data.gameState) {
            applySharedGameStateFromHost(data.gameState);
          }
        }
        break;
        
      case 'bullet_fired':
        // Another player fired a bullet
        if (data.playerId !== myPlayerId && isMultiplayer) {
          const gameBullets = window.getBullets ? window.getBullets() : [];
          if (gameBullets && data.bullet) {
            // Mark bullet as from other player for VS mode collision detection
            data.bullet.owner = 'other';
            gameBullets.push(data.bullet);
            playSound(data.bullet.type === 'laser' ? 'laser' : 'shoot');
          }
        }
        break;

      case 'heat_seeker_launch':
        if (isMultiplayer && data.missile) {
          const incoming = { ...data.missile };
          if (!incoming.ownerId) {
            incoming.ownerId = data.playerId || 'remote';
          }
          if (incoming.ownerId === myPlayerId) {
            break; // Already have local copy
          }
          incoming.auraPhase = incoming.auraPhase || 0;
          const exists = heatSeekers.some(missile => missile.id && incoming.id && missile.id === incoming.id);
          if (!exists) {
            heatSeekers.push(incoming);
          }
        }
        break;
        
      case 'powerup_sync':
        if (!window.syncPowerups) break;
        const incomingMode = data.mode || 'coop';
        const differentPlayer = !data.playerId || data.playerId !== myPlayerId;
        if (incomingMode === 'coop' && gameMode === 'coop' && differentPlayer) {
          window.syncPowerups(data.powerups, { mode: 'coop' });
        } else if (incomingMode === 'vs' && gameMode === 'vs' && data.isHost) {
          window.syncPowerups(data.powerups, { mode: 'vs' });
        }
        break;

      case 'powerup_transfer':
        if (window.syncPowerups && data.targetId === myPlayerId && data.powerups) {
          window.syncPowerups(data.powerups, { mode: 'inherit' });
          const donor = data.fromPlayerId || 'a rival';
          console.log(`‚ö° Inherited powerups from ${donor}!`);
        }
        break;
        
      case 'player_hit':
        // In VS or anyplayer mode, other player hit us
        if ((gameMode === 'vs' || gameMode === 'anyplayer') && data.targetId === myPlayerId) {
          if (window.handlePlayerHit) {
            window.handlePlayerHit(data.playerId || null);
          }
        }
        break;

      case 'player_killed':
        // Other player was killed by us
        if (gameMode === 'vs') {
          vsKills++;
          console.log(`üíÄ Got a kill! Total kills: ${vsKills}`);
        }
        break;
        
      case 'bomb_dropped':
        // Another player dropped a bomb
        if ((gameMode === 'anyplayer' || gameMode === 'vs') && data.bomb && window.addBomb) {
          // Ensure bomb has all required properties
          const bomb = {
            x: data.bomb.x,
            y: data.bomb.y,
            owner: data.bomb.owner,
            life: data.bomb.life || Infinity,
            pulsePhase: data.bomb.pulsePhase || 0,
            createdAt: data.bomb.createdAt || Date.now()
          };
          window.addBomb(bomb);
          const bombsArray = window.getBombs ? window.getBombs() : [];
          console.log(`üí£ Received bomb from ${bomb.owner} at (${Math.round(bomb.x)}, ${Math.round(bomb.y)}). Total bombs: ${bombsArray.length}`);
        } else {
          console.log('‚ö†Ô∏è Bomb received but not added:', { gameMode, hasBomb: !!data.bomb, hasAddBomb: !!window.addBomb });
        }
        break;
        
      case 'bomb_destroyed':
        // A bomb was destroyed
        if ((gameMode === 'anyplayer' || gameMode === 'vs') && data.bombIndex !== undefined && window.getBombs && window.removeBomb) {
          const bombs = window.getBombs();
          const currentPlayerId = window.getMyPlayerId ? window.getMyPlayerId() : null;
          if (data.bombIndex < bombs.length) {
            const bomb = bombs[data.bombIndex];
            if (bomb && bomb.owner === currentPlayerId && window.getBombCount && window.setBombCount) {
              window.setBombCount(window.getBombCount() - 1);
            }
            window.removeBomb(data.bombIndex);
          }
        }
        break;
        
      case 'bomb_kill':
        // Someone hit a bomb and died
        if (gameMode === 'anyplayer' || gameMode === 'vs') {
          const currentPlayerId = window.getMyPlayerId ? window.getMyPlayerId() : null;
          if (data.bomber === currentPlayerId) {
            // Our bomb got a kill!
            score += 2000;
            if (gameMode === 'anyplayer') {
              playerKills++;
            }
            console.log(`üí£ Your bomb eliminated player ${data.victim}! +2000`);
          }
        }
        break;
        
      case 'player_disconnected':
        if (gameMode === 'anyplayer') {
          // Remove from all players list
          delete allPlayers[data.playerId];
          
          // Remove their color assignment
          delete playerColorMap[data.playerId];
          
          // Remove their bombs
          if (window.getBombs && window.removeBomb) {
            const bombs = window.getBombs();
            for (let i = bombs.length - 1; i >= 0; i--) {
              if (bombs[i].owner === data.playerId) {
                window.removeBomb(i);
              }
            }
          }
          
          console.log('Player disconnected from battle royale:', data.playerId);
        } else if (data.playerId === otherPlayerId) {
          console.log('Other player disconnected');
          stopFirebaseSync('peer-left');
          isMultiplayer = false;
          otherPlayerShip = null;
          otherPlayerId = null;
        }
        break;
        
      case 'anyplayer_players':
        // Receive list of all players in anyplayer mode
        if (gameMode === 'anyplayer') {
          console.log('Received player list:', data.players);
          // Initialize all other players
          data.players.forEach(playerId => {
            if (playerId !== myPlayerId && !allPlayers[playerId]) {
              const gameCanvas = document.getElementById('asteroidCanvas');
              allPlayers[playerId] = {
                x: Math.random() * (gameCanvas ? gameCanvas.width : 800),
                y: Math.random() * (gameCanvas ? gameCanvas.height : 600),
                angle: Math.random() * Math.PI * 2,
                velocity: { x: 0, y: 0 },
                exploded: false,
                size: 15,
                thrust: false,
                lives: 3,
                score: 0
              };
            }
          });
        }
        break;
    }
  }
  
  function startMultiplayerGame(partnerPlayerId, mode) {
    console.log(`startMultiplayerGame called: partnerPlayerId=${partnerPlayerId}, mode=${mode}`);
    isMultiplayer = true;
    gameMode = mode || 'coop';
    console.log(`Set gameMode to: ${gameMode}, isMultiplayer to: ${isMultiplayer}`);
    otherPlayerId = partnerPlayerId;
    lobbyOverlay.classList.remove('active');
    joinRequestOverlay.classList.remove('active');
    console.log(`Starting ${gameMode.toUpperCase()} game with ${partnerPlayerId}`);
    if (gameMode !== 'anyplayer') {
      anyPlayerHostId = null;
      isAnyPlayerHost = false;
    }
    
    // Initialize other player ship
    const gameCanvas = document.getElementById('asteroidCanvas');
    otherPlayerShip = {
      x: (gameCanvas ? gameCanvas.width : 800) / 2 + 100,
      y: (gameCanvas ? gameCanvas.height : 600) / 2,
      angle: Math.PI,
      velocity: { x: 0, y: 0 },
      exploded: false,
      size: 15,
      thrust: false,
      lives: 3,
      score: 0
    };

    if (firebaseSync && typeof firebaseSync.startSession === 'function' && (gameMode === 'coop' || gameMode === 'vs')) {
      const result = firebaseSync.startSession({
        mode: gameMode,
        myPlayerId,
        partnerPlayerId
      });
      if (result && typeof result.catch === 'function') {
        result.catch(err => console.warn('[FirebaseSync] start error', err && err.message ? err.message : err));
      }
    }
  }
  
  // Button handlers
  const vsPlayBtn = document.getElementById('vsPlayBtn');
  let pendingJoinRequestMode = 'coop';
  
  soloPlayBtn.addEventListener('click', () => {
    stopFirebaseSync('solo-mode');
    gameMode = 'solo';
    anyPlayerHostId = null;
    isAnyPlayerHost = false;
    lobbyOverlay.classList.remove('active');
    console.log('Starting solo game');
  });
  
  coopPlayBtn.addEventListener('click', () => {
    if (otherPlayerId && ws && ws.readyState === WebSocket.OPEN) {
      // Send join request for co-op
      ws.send(JSON.stringify({
        type: 'join_request',
        targetPlayerId: otherPlayerId,
        mode: 'coop'
      }));
      lobbyStatus.textContent = 'Sending co-op request...';
      coopPlayBtn.disabled = true;
      vsPlayBtn.disabled = true;
      soloPlayBtn.disabled = true;
    }
  });
  
  vsPlayBtn.addEventListener('click', () => {
    if (otherPlayerId && ws && ws.readyState === WebSocket.OPEN) {
      // Send join request for VS mode
      ws.send(JSON.stringify({
        type: 'join_request',
        targetPlayerId: otherPlayerId,
        mode: 'vs'
      }));
      lobbyStatus.textContent = 'Sending VS challenge...';
      coopPlayBtn.disabled = true;
      vsPlayBtn.disabled = true;
      soloPlayBtn.disabled = true;
    }
  });
  
  anyPlayerBtn.addEventListener('click', () => {
    stopFirebaseSync('anyplayer-mode');
    if (ws && ws.readyState === WebSocket.OPEN) {
      anyPlayerHostId = null;
      isAnyPlayerHost = false;
      lastAnyPlayerSyncSent = 0;
      // Join or create an open game
      ws.send(JSON.stringify({
        type: 'join_anyplayer',
        playerId: myPlayerId
      }));
      lobbyStatus.textContent = 'Joining battle royale...';
      gameMode = 'anyplayer';
      isMultiplayer = true;
      lobbyOverlay.classList.remove('active');
      console.log('Starting Any Player mode (Battle Royale)');
      
      // Initialize all players tracking
      allPlayers = {};
      
      // Reset color assignments for new game
      Object.keys(playerColorMap).forEach(key => delete playerColorMap[key]);
      nextColorIndex = 0;
      
      // Assign color to local player first
      getPlayerColor(myPlayerId);
      
      // Randomize spawn position for battle royale
      const ship = window.getShip ? window.getShip() : null;
      const gameCanvas = document.getElementById('asteroidCanvas');
      if (ship && gameCanvas) {
        ship.x = Math.random() * gameCanvas.width;
        ship.y = Math.random() * gameCanvas.height;
        ship.velocity = { x: 0, y: 0 };
        ship.angle = Math.random() * Math.PI * 2;
        console.log(`Spawned at random position: (${Math.round(ship.x)}, ${Math.round(ship.y)})`);
      }
      
      // Clear bombs from previous games
      if (window.clearBombs) {
        window.clearBombs();
        window.setBombCount(0);
      }
      
      // Clear super bonuses
      superBonuses = [];
      lastSuperBonusTime = Date.now();
      
      // Reset powerups
      dualCannon = false;
      energyForcefield = false;
      dualThruster = false;
      thrusterPower = 1;
    }
  });
  
  acceptJoinBtn.addEventListener('click', () => {
    console.log(`Accept button clicked. pendingJoinRequest=${pendingJoinRequest}, pendingJoinRequestMode=${pendingJoinRequestMode}`);
    if (pendingJoinRequest && ws && ws.readyState === WebSocket.OPEN) {
      console.log(`Sending join_response with accepted=true, mode=${pendingJoinRequestMode}`);
      ws.send(JSON.stringify({
        type: 'join_response',
        requestingPlayerId: pendingJoinRequest,
        accepted: true,
        mode: pendingJoinRequestMode
      }));
      console.log(`Calling startMultiplayerGame with mode: ${pendingJoinRequestMode}`);
      startMultiplayerGame(pendingJoinRequest, pendingJoinRequestMode);
      pendingJoinRequest = null;
    }
  });
  
  declineJoinBtn.addEventListener('click', () => {
    if (pendingJoinRequest && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'join_response',
        requestingPlayerId: pendingJoinRequest,
        accepted: false
      }));
      joinRequestOverlay.classList.remove('active');
      pendingJoinRequest = null;
    }
  });
  
  // Send state updates periodically
  setInterval(() => {
    const ship = window.getShip ? window.getShip() : null;
    const lives = window.getLives ? window.getLives() : 3;
    const score = window.getScore ? window.getScore() : 0;
    const kills = window.getPlayerKills ? window.getPlayerKills() : 0;
    const deaths = window.getPlayerDeaths ? window.getPlayerDeaths() : 0;
    const powerupSnapshot = window.getPowerups ? window.getPowerups() : null;

    if (isMultiplayer && ws && ws.readyState === WebSocket.OPEN) {
      if (ship) {
        try {
          ws.send(JSON.stringify({
            type: 'state_update',
            state: {
              x: ship.x,
              y: ship.y,
              angle: ship.angle,
              velocity: ship.velocity,
              exploded: ship.exploded,
              thrust: ship.thrust,
              lives: lives,
              score: score,
              kills: kills,
              deaths: deaths
            }
          }));
        } catch (e) {
          console.error('Error sending state_update:', e.message);
        }
      }
      
      const shouldBroadcastPowerups = (gameMode === 'coop' || (gameMode === 'vs' && isHost));
      if (shouldBroadcastPowerups && powerupSnapshot) {
        try {
          ws.send(JSON.stringify({
            type: 'powerup_sync',
            powerups: powerupSnapshot,
            mode: gameMode,
            isHost,
            playerId: myPlayerId
          }));
        } catch (e) {
          console.error('Error sending powerup_sync:', e.message);
        }
      }
      
      // If host, sync game state for 2-player modes
      if (isHost && (gameMode === 'coop' || gameMode === 'vs')) {
        const now = Date.now();
        if (now - lastGameSyncSent >= GAME_SYNC_INTERVAL) {
          const sharedState = captureSharedGameState();
          if (sharedState) {
            try {
              ws.send(JSON.stringify({
                type: 'game_sync',
                gameState: sharedState
              }));
              lastGameSyncSent = now;
            } catch (e) {
              console.error('Error sending game_sync:', e.message);
            }
          }
        }
      }

      if (gameMode === 'anyplayer' && isAnyPlayerHost && window.captureAnyPlayerState) {
        const now = Date.now();
        if (now - lastAnyPlayerSyncSent >= ANYPLAYER_SYNC_INTERVAL) {
          const snapshot = window.captureAnyPlayerState();
          if (snapshot) {
            try {
              ws.send(JSON.stringify({
                type: 'anyplayer_state_update',
                gameState: snapshot
              }));
              lastAnyPlayerSyncSent = now;
            } catch (e) {
              console.error('Error sending anyplayer_state_update:', e.message);
            }
          }
        }
      }
    }

    if (firebaseSync && typeof firebaseSync.publishState === 'function' && firebaseSync.isActive && firebaseSync.isActive() && ship) {
      let sharedState = null;
      if (isHost && (gameMode === 'coop' || gameMode === 'vs')) {
        const bonuses = window.getSuperBonuses ? window.getSuperBonuses() : [];
        const lastBonusSpawn = window.getLastSuperBonusTime ? window.getLastSuperBonusTime() : null;
        const powerupsForShare = window.getPowerups ? window.getPowerups() : null;
        sharedState = {
          superBonuses: cloneForSync(bonuses || []),
          lastSuperBonusTime: typeof lastBonusSpawn === 'number' ? lastBonusSpawn : null,
          powerupsSnapshot: powerupsForShare ? cloneForSync(powerupsForShare) : null
        };
      }
      firebaseSync.publishState({
        state: {
          x: ship.x,
          y: ship.y,
          angle: ship.angle,
          velocity: ship.velocity,
          exploded: ship.exploded,
          thrust: ship.thrust,
          lives,
          score,
          kills,
          deaths
        },
        powerups: gameMode === 'coop' ? powerupSnapshot : null,
        shared: sharedState,
        meta: {
          score,
          lives,
          kills,
          deaths,
          timestamp: Date.now(),
          isHost,
          mode: gameMode
        }
      });
    }
  }, 50); // 20 times per second for smoother sync
  
  // Interpolate other player's position for smooth movement
  setInterval(() => {
    if (isMultiplayer && gameMode !== 'anyplayer') {
      // For 2-player modes, use interpolation
      if (otherPlayerShip && otherPlayerTargetState) {
        const lerpFactor = 0.6; // Faster interpolation (was 0.3, now 0.6 for less drag)
        
        // Lerp position
        otherPlayerShip.x += (otherPlayerTargetState.x - otherPlayerShip.x) * lerpFactor;
        otherPlayerShip.y += (otherPlayerTargetState.y - otherPlayerShip.y) * lerpFactor;
        
        // Lerp angle (handle wrapping)
        let angleDiff = otherPlayerTargetState.angle - otherPlayerShip.angle;
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
        otherPlayerShip.angle += angleDiff * lerpFactor;
        
        // Update other properties
        otherPlayerShip.thrust = otherPlayerTargetState.thrust;
        otherPlayerShip.exploded = otherPlayerTargetState.exploded;
      }
    }
    
    // For anyplayer mode, positions are updated directly (no interpolation to reduce lag)
  }, 16); // ~60fps interpolation
  
  // Expose multiplayer functions
  window.getOtherPlayerShip = () => otherPlayerShip;
  window.getAllPlayers = () => allPlayers;
  window.isMultiplayerActive = () => isMultiplayer;
  window.getGameMode = () => {
    //console.log(`getGameMode called, returning: ${gameMode}`);
    return gameMode;
  };
  window.getMyPlayerId = () => myPlayerId;
  window.getOtherPlayerId = () => otherPlayerId;
  window.getPlayerColor = getPlayerColor;
  window.getPlayerColors = () => playerColors;
  
  // Broadcast bullet function
  window.broadcastBullet = (bullet) => {
    if (isMultiplayer && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'bullet_fired',
        bullet: bullet
      }));
    }
  };

  window.broadcastHeatSeeker = (missile) => {
    const currentMode = window.getGameMode ? window.getGameMode() : 'solo';
    if (!missile) return;
    if (!isMultiplayer || !(currentMode === 'anyplayer' || currentMode === 'vs')) return;
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'heat_seeker_launch',
        missile
      }));
    }
  };
  
  // Broadcast bomb operations
  window.broadcastBombDropped = (bomb) => {
    const currentGameMode = window.getGameMode ? window.getGameMode() : 'solo';
    const isMulti = window.isMultiplayerActive ? window.isMultiplayerActive() : false;
    console.log('üîç Broadcast check:', { isMulti, currentGameMode, hasWs: !!ws, wsState: ws ? ws.readyState : 'no ws' });
    if (isMulti && (currentGameMode === 'anyplayer' || currentGameMode === 'vs') && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'bomb_dropped',
        bomb: bomb
      }));
      console.log('‚úÖ Bomb broadcast sent to server');
    } else {
      console.log('‚ùå Bomb broadcast blocked:', { isMulti, currentGameMode, hasWs: !!ws, wsReady: ws && ws.readyState === WebSocket.OPEN });
    }
  };
  
  window.broadcastBombDestroyed = (bombIndex) => {
    const currentGameMode = window.getGameMode ? window.getGameMode() : 'solo';
    const isMulti = window.isMultiplayerActive ? window.isMultiplayerActive() : false;
    if (isMulti && (currentGameMode === 'anyplayer' || currentGameMode === 'vs') && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'bomb_destroyed',
        bombIndex: bombIndex
      }));
    }
  };
  
  window.broadcastBombKill = (victimId, bomberId) => {
    const currentGameMode = window.getGameMode ? window.getGameMode() : 'solo';
    const isMulti = window.isMultiplayerActive ? window.isMultiplayerActive() : false;
    if (isMulti && (currentGameMode === 'anyplayer' || currentGameMode === 'vs') && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'bomb_kill',
        victim: victimId,
        bomber: bomberId
      }));
    }
  };

  window.broadcastPowerupTransfer = (targetPlayerId, powerups, context = {}) => {
    const currentGameMode = window.getGameMode ? window.getGameMode() : 'solo';
    const isMulti = window.isMultiplayerActive ? window.isMultiplayerActive() : false;
    if (!isMulti || !(currentGameMode === 'vs' || currentGameMode === 'anyplayer')) return;
    if (!targetPlayerId || !powerups) return;
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'powerup_transfer',
        targetId: targetPlayerId,
        powerups,
        mode: currentGameMode,
        context
      }));
    }
  };
  
  // Broadcast player hit in VS or anyplayer mode
  window.broadcastPlayerHit = (targetPlayerId) => {
    if (isMultiplayer && (gameMode === 'vs' || gameMode === 'anyplayer') && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'player_hit',
        targetId: targetPlayerId
      }));
    }
  };

  window.isMultiplayerHost = () => isHost;
  window.isAnyPlayerHostActive = () => isAnyPlayerHost;


  window.addEventListener('beforeunload', () => {
    stopFirebaseSync('page-exit');
  });
  // Broadcast a kill in VS mode
  window.broadcastKill = () => {
    if (isMultiplayer && gameMode === 'vs' && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'player_killed'
      }));
    }
  };
  
  // Show lobby on page load
  lobbyOverlay.classList.add('active');
  
  // Connect to WebSocket
  connectWebSocket();
})();

// ===== MODIFY GAME TO SUPPORT 2 PLAYERS =====
(function() {
  // Override the ship drawing function to draw both players
  const originalGameLoop = window.gameLoop;
  
  // Draw other player's ship (for 2-player modes)
  function drawOtherPlayerShip() {
    const otherShip = window.getOtherPlayerShip ? window.getOtherPlayerShip() : null;
    const isMultiplayer = window.isMultiplayerActive ? window.isMultiplayerActive() : false;
    if (!otherShip) {
      return;
    }
    if (!isMultiplayer) {
      return;
    }
    if (otherShip.exploded) {
      return;
    }
    
    const canvas = document.getElementById('asteroidCanvas');
    const ctx = canvas.getContext('2d');
    
    ctx.save();
    ctx.translate(otherShip.x, otherShip.y);
    ctx.rotate(otherShip.angle);
    
    // Get color based on game mode and player ID
    const gameMode = window.getGameMode ? window.getGameMode() : 'coop';
    const getPlayerColor = window.getPlayerColor;
    const otherPlayerId = window.getOtherPlayerId ? window.getOtherPlayerId() : null;
    
    // Use the color assignment function for consistency
    let shipColor = { primary: 'rgba(255, 107, 107, 0.6)', fill: 'rgba(255, 107, 107, 0.1)' };
    if (getPlayerColor && otherPlayerId) {
      const assignedColor = getPlayerColor(otherPlayerId);
      shipColor = {
        primary: assignedColor.primary.replace('0.7)', '0.6)'),
        fill: assignedColor.fill.replace('0.15)', '0.1)')
      };
    } else {
      // Fallback to mode-based colors
      shipColor = gameMode === 'vs'
        ? { primary: 'rgba(255, 107, 107, 0.6)', fill: 'rgba(255, 107, 107, 0.1)' }
        : { primary: 'rgba(255, 165, 50, 0.6)', fill: 'rgba(255, 165, 50, 0.1)' };
    }
    
    ctx.strokeStyle = shipColor.primary;
    ctx.fillStyle = shipColor.fill;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(otherShip.size, 0);
    ctx.lineTo(-otherShip.size, -otherShip.size / 2);
    ctx.lineTo(-otherShip.size, otherShip.size / 2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Thrust flames
    if (otherShip.thrust) {
      ctx.fillStyle = shipColor.primary.replace('0.6)', '0.5)');
      ctx.beginPath();
      ctx.moveTo(-otherShip.size, -otherShip.size / 3);
      ctx.lineTo(-otherShip.size - 10, 0);
      ctx.lineTo(-otherShip.size, otherShip.size / 3);
      ctx.closePath();
      ctx.fill();
    }
    
    ctx.restore();
    
    // Draw player label
    const labelColor = shipColor.primary.replace('0.6)', '0.9)');
    ctx.fillStyle = labelColor;
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    const label = gameMode === 'vs' ? 'ENEMY' : 'P2';
    ctx.fillText(label, otherShip.x, otherShip.y - 25);
  }
  
  // Draw all players in anyplayer mode
  function drawAllPlayers() {
    const allPlayers = window.getAllPlayers ? window.getAllPlayers() : {};
    const getPlayerColor = window.getPlayerColor;
    const leadingPlayerId = getLeadingPlayerId();
    const canvas = document.getElementById('asteroidCanvas');
    const ctx = canvas.getContext('2d');
    
    Object.entries(allPlayers).forEach(([playerId, player]) => {
      if (player.exploded) return;
      
      // Get unique color for this player
      const color = getPlayerColor ? getPlayerColor(playerId) : { primary: 'rgba(255, 107, 107, 0.7)', fill: 'rgba(255, 107, 107, 0.15)' };
      const isWinning = playerId === leadingPlayerId;
      
      ctx.save();
      ctx.translate(player.x, player.y);
      ctx.rotate(player.angle);
      
      // Draw victory flag if this player is winning
      if (isWinning) {
        ctx.save();
        ctx.translate(-player.size, -player.size * 1.5);
        
        // Flag pole
        ctx.strokeStyle = 'rgba(255, 215, 0, 0.9)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, -20);
        ctx.stroke();
        
        // Animated flag with player's color
        const wave = Math.sin(Date.now() / 100) * 2;
        ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
        ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(0, -20);
        ctx.lineTo(12 + wave, -17);
        ctx.lineTo(10 + wave, -13);
        ctx.lineTo(0, -10);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Crown on flag
        ctx.fillStyle = 'rgba(255, 215, 0, 1)';
        ctx.font = 'bold 10px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('üëë', 6 + wave / 2, -13);
        
        ctx.restore();
      }
      
      // Ship body - unique color for each player, golden glow if winning
      ctx.strokeStyle = isWinning ? 'rgba(255, 215, 0, 0.8)' : color.primary;
      ctx.fillStyle = isWinning ? 'rgba(255, 215, 0, 0.2)' : color.fill;
      ctx.lineWidth = isWinning ? 3 : 2;
      if (isWinning) {
        ctx.shadowColor = 'rgba(255, 215, 0, 0.6)';
        ctx.shadowBlur = 15;
      }
      ctx.beginPath();
      ctx.moveTo(player.size, 0);
      ctx.lineTo(-player.size, -player.size / 2);
      ctx.lineTo(-player.size, player.size / 2);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.shadowBlur = 0;
      
      // Thrust flames
      if (player.thrust) {
        ctx.fillStyle = isWinning ? 'rgba(255, 215, 0, 0.6)' : color.primary.replace('0.7)', '0.6)');
        ctx.beginPath();
        ctx.moveTo(-player.size, -player.size / 3);
        ctx.lineTo(-player.size - 10, 0);
        ctx.lineTo(-player.size, player.size / 3);
        ctx.closePath();
        ctx.fill();
      }
      
      ctx.restore();
      
      // Draw player indicator with score (with crown if winning)
      ctx.fillStyle = isWinning ? 'rgba(255, 215, 0, 0.9)' : color.primary.replace('0.7)', '0.9)');
      ctx.font = 'bold 11px system-ui';
      ctx.textAlign = 'center';
      const displayText = isWinning ? `üëë ${player.kills || 0}` : `${player.kills || 0}`;
      ctx.fillText(displayText, player.x, player.y - 25);
    });
    tryAutoStartBattleRoyale();
  }
  
  // Update player list UI
  function updatePlayerList() {
    const playerListEl = document.getElementById('playerList');
    const playerListContent = document.getElementById('playerListContent');
    const gameMode = window.getGameMode ? window.getGameMode() : 'solo';
    const myPlayerId = window.getMyPlayerId ? window.getMyPlayerId() : null;
    const allPlayers = window.getAllPlayers ? window.getAllPlayers() : {};
    const getPlayerColor = window.getPlayerColor;
    const getScore = window.getScore ? window.getScore() : 0;
    const getLives = window.getLives ? window.getLives() : 3;
    const getPlayerKills = window.getPlayerKills ? window.getPlayerKills() : 0;
    const getPlayerDeaths = window.getPlayerDeaths ? window.getPlayerDeaths() : 0;
    
    if (gameMode === 'anyplayer' && playerListEl && playerListContent) {
      playerListEl.classList.add('active');
      
      // Build player list HTML
      let html = '';
      
      // Add local player first
      const myColor = { primary: 'rgba(126, 240, 163, 0.7)', fill: 'rgba(126, 240, 163, 0.15)' };
      html += `
        <div class="player-item me">
          <div class="player-icon" style="background: ${myColor.primary};"></div>
          <div class="player-info">
            <div class="player-name">You</div>
            <div class="player-score">Kills: ${getPlayerKills} | Deaths: ${getPlayerDeaths}</div>
          </div>
        </div>
      `;
      
      // Add other players
      const leadingPlayerId = window.getLeadingPlayerId ? window.getLeadingPlayerId() : null;
      Object.entries(allPlayers).forEach(([playerId, player]) => {
        const color = getPlayerColor ? getPlayerColor(playerId) : { primary: 'rgba(255, 107, 107, 0.7)' };
        // Sanitize playerId to prevent XSS
        const shortId = String(playerId).substring(0, 6).replace(/[<>"'&]/g, '');
        const isLeading = playerId === leadingPlayerId && leadingPlayerId !== myPlayerId;
        const crownIcon = isLeading ? ' üëë' : '';
        // Ensure numeric values are safe
        const kills = Math.max(0, parseInt(player.kills) || 0);
        const deaths = Math.max(0, parseInt(player.deaths) || 0);
        html += `
          <div class="player-item" style="border-left-color: ${color.primary};">
            <div class="player-icon" style="background: ${color.primary};"></div>
            <div class="player-info">
              <div class="player-name">${shortId}${crownIcon}</div>
              <div class="player-score">Kills: ${kills} | Deaths: ${deaths}</div>
            </div>
          </div>
        `;
      });
      
      // Show crown next to local player if they're leading
      if (leadingPlayerId === myPlayerId) {
        html = html.replace('<div class="player-name">You</div>', '<div class="player-name">You üëë</div>');
      }
      
      playerListContent.innerHTML = html;
    } else {
      if (playerListEl) {
        playerListEl.classList.remove('active');
      }
    }
  }
  
  // Inject into game loop
  const canvas = document.getElementById('asteroidCanvas');
  const originalRequestAnimationFrame = window.requestAnimationFrame;
  
  // Expose drawing functions to be called from the game loop
  window.drawOtherPlayerShip = drawOtherPlayerShip;
  window.drawAllPlayers = drawAllPlayers;
  
  // Update player list more frequently
  setInterval(() => {
    updatePlayerList();
  }, 100); // 10 times per second
})();

</script>

</body>
</html>
