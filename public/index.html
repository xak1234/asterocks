<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Asterocks ‚Äî Multiplayer Asteroid Game</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial; }
    body {
      margin: 0;
      padding: 24px;
      background: #08101a;
      color: #e6eef8;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      position: relative;
    }
    #asteroidCanvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
    }
    .container {
      max-width: 900px;
      width: 100%;
      position: relative;
      z-index: 1;
      display: none;
      flex-direction: column;
      gap: 20px;
      background: rgba(8, 16, 26, 0.5);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 30px;
      border: 2px solid rgba(126, 200, 255, 0.3);
    }
    .card {
      background: rgba(15, 27, 42, 0.8);
      backdrop-filter: blur(8px);
      border-radius: 12px;
      padding: 28px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(126, 200, 255, 0.2);
    }
    header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
      margin-bottom: 28px;
    }
    .header-left h1 {
      margin: 0;
      font-size: 20px;
      font-weight: 600;
    }
    .header-left .sub {
      color: #93aecd;
      font-size: 12px;
      margin-top: 4px;
    }
    .header-left .sub code {
      background: rgba(255, 255, 255, 0.05);
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 11px;
    }
    .header-right {
      text-align: right;
    }
    .header-right > div {
      color: #93aecd;
      font-size: 12px;
      line-height: 1.6;
    }
    .status {
      color: #7ec8ff;
    }

    .content {
      display: grid;
      grid-template-columns: 1fr 2fr;
      gap: 24px;
    }

    /* Comet tracking styles removed */
    .observations {
      display: none;
    }

    /* Joystick Control Panel */
    #controlPanel {
      position: fixed;
      bottom: 15px;
      right: 15px;
      display: none;
      z-index: 1000;
      background: rgba(15, 27, 42, 0.95);
      border-radius: 12px;
      padding: 15px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.8);
      border: 2px solid rgba(126, 200, 255, 0.5);
    }

    #controlPanel.active {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      animation: panelFadeIn 0.3s ease-out;
    }

    @keyframes panelFadeIn {
      from {
        opacity: 0;
        transform: scale(0.8);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .joystick-container {
      display: grid;
      grid-template-columns: repeat(3, 50px);
      grid-template-rows: repeat(3, 50px);
      gap: 5px;
    }

    .direction-btn {
      background: rgba(126, 200, 255, 0.3);
      border: 2px solid rgba(126, 200, 255, 0.6);
      border-radius: 8px;
      color: #7ec8ff;
      font-size: 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .direction-btn:active {
      background: rgba(126, 200, 255, 0.5);
      transform: scale(0.95);
    }

    .direction-btn.up { grid-column: 2; grid-row: 1; }
    .direction-btn.left { grid-column: 1; grid-row: 2; }
    .direction-btn.right { grid-column: 3; grid-row: 2; }
    .direction-btn.down { grid-column: 2; grid-row: 3; }

    .fire-btn {
      width: 70px;
      height: 70px;
      background: linear-gradient(145deg, #ff6b6b, #ff4444);
      border: 3px solid rgba(255, 107, 107, 0.8);
      border-radius: 50%;
      color: white;
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 3px 10px rgba(255, 107, 107, 0.5);
      transition: all 0.15s ease;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .fire-btn:active {
      background: linear-gradient(145deg, #ff4444, #ff2222);
      transform: scale(0.95);
      box-shadow: 0 1px 3px rgba(255, 107, 107, 0.7);
    }

    .hyperspace-btn {
      width: 70px;
      height: 40px;
      background: linear-gradient(145deg, #7ec8ff, #5ea8df);
      border: 3px solid rgba(126, 200, 255, 0.8);
      border-radius: 8px;
      color: white;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 3px 10px rgba(126, 200, 255, 0.5);
      transition: all 0.15s ease;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .hyperspace-btn:active {
      background: linear-gradient(145deg, #5ea8df, #4e98cf);
      transform: scale(0.95);
      box-shadow: 0 1px 3px rgba(126, 200, 255, 0.7);
    }

    .close-panel-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      width: 15px;
      height: 15px;
      background: rgba(255, 107, 107, 0.3);
      border: 1px solid rgba(255, 107, 107, 0.5);
      border-radius: 50%;
      color: #ff9b9b;
      font-size: 9px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s ease;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .close-panel-btn:active {
      background: rgba(255, 107, 107, 0.5);
      transform: scale(0.95);
    }

    .drag-handle {
      position: absolute;
      top: 5px;
      left: 5px;
      width: 20px;
      height: 20px;
      background: rgba(126, 200, 255, 0.3);
      border: 1px solid rgba(126, 200, 255, 0.5);
      border-radius: 4px;
      cursor: move;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 2px;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    .drag-handle::before,
    .drag-handle::after {
      content: '';
      width: 12px;
      height: 2px;
      background: rgba(126, 200, 255, 0.6);
      border-radius: 1px;
    }

    .drag-handle:active {
      background: rgba(126, 200, 255, 0.5);
      cursor: grabbing;
    }

    @media (max-width: 720px) {
      .content {
        grid-template-columns: 1fr;
      }
      body {
        padding: 16px;
      }
      
      /* Optimize joystick for mobile */
      #controlPanel {
        bottom: 20px;
        right: 20px;
        padding: 20px;
        border-radius: 16px;
      }
      
      .joystick-container {
        grid-template-columns: repeat(3, 60px);
        grid-template-rows: repeat(3, 60px);
        gap: 8px;
      }
      
      .direction-btn {
        font-size: 24px;
        border-radius: 8px;
        border: 3px solid rgba(126, 200, 255, 0.6);
      }
      
      .fire-btn {
        width: 90px;
        height: 90px;
        font-size: 16px;
        border: 4px solid rgba(255, 107, 107, 0.8);
        box-shadow: 0 4px 12px rgba(255, 107, 107, 0.5);
      }
      
      .hyperspace-btn {
        width: 90px;
        height: 50px;
        font-size: 13px;
        border: 3px solid rgba(126, 200, 255, 0.8);
      }
      
      .close-panel-btn {
        width: 24px;
        height: 24px;
        font-size: 14px;
        top: 8px;
        right: 8px;
        border: 2px solid rgba(255, 107, 107, 0.5);
      }
      
      .drag-handle {
        width: 28px;
        height: 28px;
        top: 8px;
        left: 8px;
        border: 2px solid rgba(126, 200, 255, 0.5);
        border-radius: 6px;
      }
      
      .drag-handle::before,
      .drag-handle::after {
        width: 16px;
        height: 3px;
      }
    }

    /* ===== SCREEN SAVER STYLES ===== */
    #screenSaverOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #08101a 0%, #0a1428 50%, #08101a 100%);
      display: none;
      z-index: 2000;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      opacity: 0;
      transition: opacity 0.5s ease-in-out;
      pointer-events: none;
    }

    #screenSaverOverlay.active {
      display: flex;
      opacity: 1;
      pointer-events: auto;
    }

    .screensaver-content {
      text-align: center;
      color: #e6eef8;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial;
      z-index: 2001;
      position: relative;
    }

    .screensaver-logo {
      font-size: 64px;
      font-weight: 800;
      margin-bottom: 20px;
      letter-spacing: 3px;
      animation: screenSaverPulse 3s ease-in-out infinite;
      text-shadow: 0 0 20px rgba(126, 240, 163, 0.5);
    }

    .screensaver-subtitle {
      font-size: 20px;
      color: #93aecd;
      margin-bottom: 40px;
      letter-spacing: 1px;
      font-weight: 300;
    }

    .screensaver-status {
      font-size: 16px;
      color: #7ec8ff;
      margin-bottom: 30px;
      min-height: 24px;
      font-weight: 500;
    }

    .screensaver-hint {
      font-size: 13px;
      color: #86a6c5;
      margin-top: 80px;
      animation: screenSaverFade 2s ease-in-out infinite;
    }

    /* ===== RADAR SYSTEM ===== */
    #radarContainer {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 200px;
      height: 200px;
      background: rgba(15, 27, 42, 0.9);
      border-radius: 50%;
      border: 3px solid rgba(126, 200, 255, 0.5);
      box-shadow: 0 0 20px rgba(126, 200, 255, 0.3);
      z-index: 1000;
    }

    #radarCanvas {
      width: 100%;
      height: 100%;
      border-radius: 50%;
    }

    .radar-label {
      position: absolute;
      bottom: -30px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(126, 200, 255, 0.8);
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* ===== PLAYER LIST (ANYPLAYER MODE) ===== */
    #playerList {
      position: fixed;
      top: 150px;
      right: 20px;
      background: rgba(15, 27, 42, 0.6);
      border: 2px solid rgba(126, 200, 255, 0.5);
      border-radius: 6px;
      padding: 9px 12px;
      min-width: 80px;
      max-height: 300px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6);
    }

    #playerList.active {
      display: block;
    }

    .player-list-title {
      font-size: 10.5px;
      font-weight: 700;
      color: rgba(255, 200, 100, 0.9);
      text-transform: uppercase;
      letter-spacing: 0.75px;
      margin-bottom: 7.5px;
      text-align: center;
      border-bottom: 1px solid rgba(126, 200, 255, 0.3);
      padding-bottom: 4.5px;
    }

    .player-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4.5px 6px;
      margin-bottom: 3px;
      background: rgba(8, 16, 26, 0.6);
      border-radius: 3px;
      border-left: 2.25px solid;
    }

    .player-item.me {
      background: rgba(126, 240, 163, 0.15);
      border-left-color: rgba(126, 240, 163, 0.8);
    }

    .player-icon {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .player-info {
      flex: 1;
      font-size: 9px;
    }

    .player-name {
      color: rgba(255, 255, 255, 0.9);
      font-weight: 600;
    }

    .player-score {
      color: rgba(255, 200, 100, 0.8);
      font-size: 8.25px;
    }

    /* ===== CONTROL BUTTONS ===== */
    .control-buttons {
      position: fixed;
      top: 70px;
      right: 20px;
      display: flex;
      gap: 10px;
      z-index: 1000;
    }

    .control-btn {
      width: 50px;
      height: 50px;
      background: rgba(15, 27, 42, 0.9);
      border: 2px solid rgba(126, 200, 255, 0.5);
      border-radius: 8px;
      color: rgba(126, 200, 255, 0.9);
      font-size: 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
      user-select: none;
    }

    .control-btn:hover {
      background: rgba(15, 27, 42, 1);
      border-color: rgba(126, 240, 163, 0.8);
      color: rgba(126, 240, 163, 1);
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(126, 200, 255, 0.3);
    }

    .control-btn:active {
      transform: scale(0.95);
    }

    .control-btn.active {
      background: rgba(126, 200, 255, 0.2);
      border-color: rgba(126, 240, 163, 0.8);
      color: rgba(126, 240, 163, 1);
    }

    .control-btn.muted {
      background: rgba(255, 107, 107, 0.2);
      border-color: rgba(255, 107, 107, 0.5);
      color: rgba(255, 107, 107, 0.8);
    }

    .pause-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(8, 16, 26, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1500;
      backdrop-filter: blur(5px);
    }

    .pause-overlay.active {
      display: flex;
    }

    .pause-content {
      text-align: center;
      color: #e6eef8;
    }

    .pause-title {
      font-size: 64px;
      font-weight: 800;
      color: rgba(126, 240, 163, 0.9);
      text-shadow: 0 0 20px rgba(126, 240, 163, 0.5);
      margin-bottom: 20px;
      animation: pausePulse 2s ease-in-out infinite;
    }

    .pause-subtitle {
      font-size: 20px;
      color: #93aecd;
      letter-spacing: 1px;
    }

    @keyframes pausePulse {
      0%, 100% {
        opacity: 0.7;
      }
      50% {
        opacity: 1;
      }
    }

    /* ===== LOBBY SYSTEM STYLES ===== */
    .lobby-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: url('assets/back.png') center center / cover no-repeat, rgba(8, 16, 26, 0.7);
      background-attachment: fixed;
      background-blend-mode: overlay;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2500;
      backdrop-filter: blur(10px);
    }

    .lobby-overlay.active {
      display: flex;
    }

    .lobby-content {
      text-align: center;
      color: #e6eef8;
      background: rgba(15, 27, 42, 0.9);
      border-radius: 8px;
      padding: 20px 30px;
      border: 2px solid rgba(126, 200, 255, 0.5);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
      min-width: 200px;
    }

    .lobby-title {
      font-size: 16px;
      font-weight: 800;
      color: rgba(126, 240, 163, 0.9);
      text-shadow: 0 0 20px rgba(126, 240, 163, 0.5);
      margin-bottom: 10px;
      letter-spacing: 2px;
    }

    .lobby-status {
      font-size: 8px;
      color: #93aecd;
      margin-bottom: 15px;
      min-height: 12px;
    }

    .lobby-options {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-bottom: 10px;
    }

    .lobby-btn {
      padding: 8px 15px;
      font-size: 8px;
      font-weight: 600;
      border: 2px solid rgba(126, 200, 255, 0.5);
      border-radius: 4px;
      background: rgba(15, 27, 42, 0.8);
      color: rgba(126, 200, 255, 0.9);
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .lobby-btn:hover:not(:disabled) {
      background: rgba(126, 200, 255, 0.2);
      border-color: rgba(126, 240, 163, 0.8);
      color: rgba(126, 240, 163, 1);
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(126, 200, 255, 0.3);
    }

    .lobby-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .lobby-btn-primary {
      background: rgba(126, 240, 163, 0.2);
      border-color: rgba(126, 240, 163, 0.6);
      color: rgba(126, 240, 163, 1);
    }

    .lobby-btn-primary:hover:not(:disabled) {
      background: rgba(126, 240, 163, 0.3);
      box-shadow: 0 4px 12px rgba(126, 240, 163, 0.4);
    }

    .lobby-btn-vs {
      background: rgba(255, 107, 107, 0.2);
      border-color: rgba(255, 107, 107, 0.6);
      color: rgba(255, 107, 107, 1);
    }

    .lobby-btn-vs:hover:not(:disabled) {
      background: rgba(255, 107, 107, 0.3);
      box-shadow: 0 4px 12px rgba(255, 107, 107, 0.4);
    }

    .lobby-btn-any {
      background: rgba(255, 165, 0, 0.2);
      border-color: rgba(255, 165, 0, 0.6);
      color: rgba(255, 200, 100, 1);
    }

    .lobby-btn-any:hover:not(:disabled) {
      background: rgba(255, 165, 0, 0.3);
      box-shadow: 0 4px 12px rgba(255, 165, 0, 0.4);
      border-color: rgba(255, 200, 100, 0.8);
    }

    .lobby-hint {
      font-size: 7px;
      color: #86a6c5;
      font-style: italic;
    }

    /* ===== JOIN REQUEST POPUP ===== */
    .join-request-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(8, 16, 26, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 3000;
      backdrop-filter: blur(8px);
    }

    .join-request-overlay.active {
      display: flex;
      animation: popupFadeIn 0.3s ease-out;
    }

    @keyframes popupFadeIn {
      from {
        opacity: 0;
        transform: scale(0.9);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    .join-request-content {
      text-align: center;
      color: #e6eef8;
      background: linear-gradient(145deg, rgba(255, 200, 100, 0.15), rgba(255, 160, 80, 0.1));
      border-radius: 16px;
      padding: 40px 60px;
      border: 3px solid rgba(255, 200, 100, 0.6);
      box-shadow: 0 8px 32px rgba(255, 200, 100, 0.3);
      min-width: 400px;
      animation: pulseBorder 2s ease-in-out infinite;
    }

    @keyframes pulseBorder {
      0%, 100% {
        border-color: rgba(255, 200, 100, 0.6);
        box-shadow: 0 8px 32px rgba(255, 200, 100, 0.3);
      }
      50% {
        border-color: rgba(255, 200, 100, 0.9);
        box-shadow: 0 8px 32px rgba(255, 200, 100, 0.5);
      }
    }

    .join-request-title {
      font-size: 28px;
      font-weight: 800;
      color: rgba(255, 200, 100, 1);
      text-shadow: 0 0 20px rgba(255, 200, 100, 0.6);
      margin-bottom: 20px;
      letter-spacing: 2px;
      animation: textPulse 1.5s ease-in-out infinite;
    }

    @keyframes textPulse {
      0%, 100% {
        opacity: 0.9;
      }
      50% {
        opacity: 1;
      }
    }

    .join-request-message {
      font-size: 18px;
      color: #e6eef8;
      margin-bottom: 15px;
      font-weight: 500;
    }

    .join-request-mode {
      font-size: 16px;
      color: #ffd166;
      margin-bottom: 25px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .join-request-buttons {
      display: flex;
      gap: 20px;
      justify-content: center;
    }

    .join-request-btn {
      padding: 15px 40px;
      font-size: 16px;
      font-weight: 700;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      border: none;
    }

    .join-request-accept {
      background: linear-gradient(145deg, #7ef0a3, #5ed18a);
      color: #0a1428;
      box-shadow: 0 4px 12px rgba(126, 240, 163, 0.4);
    }

    .join-request-accept:hover {
      background: linear-gradient(145deg, #8ff5b0, #6ed998);
      transform: scale(1.05);
      box-shadow: 0 6px 16px rgba(126, 240, 163, 0.6);
    }

    .join-request-decline {
      background: linear-gradient(145deg, #ff9b9b, #ff6b6b);
      color: #0a1428;
      box-shadow: 0 4px 12px rgba(255, 107, 107, 0.4);
    }

    .join-request-decline:hover {
      background: linear-gradient(145deg, #ffb0b0, #ff8080);
      transform: scale(1.05);
      box-shadow: 0 6px 16px rgba(255, 107, 107, 0.6);
    }

    @keyframes screenSaverPulse {
      0%, 100% {
        opacity: 0.6;
        transform: scale(1);
      }
      50% {
        opacity: 1;
        transform: scale(1.08);
      }
    }

    @keyframes screenSaverFade {
      0%, 100% {
        opacity: 0.3;
      }
      50% {
        opacity: 0.9;
      }
    }

    .screensaver-particles {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 2000;
    }

    .screensaver-particle {
      position: absolute;
      width: 2px;
      height: 2px;
      background: rgba(126, 240, 163, 0.7);
      border-radius: 50%;
      box-shadow: 0 0 4px rgba(126, 240, 163, 0.8);
    }
  </style>
</head>
<body>
  <canvas id="asteroidCanvas"></canvas>
  
  <!-- Joystick Control Panel (DISABLED) -->
  <div id="controlPanel" style="display: none !important;">
    <div class="drag-handle" id="dragHandle"></div>
    <div class="close-panel-btn" id="closePanelBtn">√ó</div>
    <div class="joystick-container">
      <button class="direction-btn up" id="upBtn">‚ñ≤</button>
      <button class="direction-btn left" id="leftBtn">‚óÑ</button>
      <button class="direction-btn right" id="rightBtn">‚ñ∫</button>
      <button class="direction-btn down" id="downBtn">‚ñº</button>
    </div>
    <button class="fire-btn" id="fireBtn">FIRE</button>
    <button class="hyperspace-btn" id="hyperspaceBtn">HYPER</button>
  </div>
  
  <!-- Radar System -->
  <div id="radarContainer">
    <canvas id="radarCanvas" width="200" height="200"></canvas>
    <div class="radar-label">RADAR</div>
  </div>
  
  <!-- Control Buttons -->
  <div class="control-buttons">
    <button class="control-btn" id="soundBtn" title="Toggle Sound Effects">üîä</button>
    <button class="control-btn" id="pauseBtn" title="Pause Game">‚è∏</button>
  </div>
  
  <!-- Pause Overlay -->
  <div class="pause-overlay" id="pauseOverlay">
    <div class="pause-content">
      <div class="pause-title">PAUSED</div>
      <div class="pause-subtitle">Press P or click Pause button to resume</div>
    </div>
  </div>
  
  <!-- 2-Player Co-op Lobby -->
  <div class="lobby-overlay" id="lobbyOverlay">
    <div class="lobby-content">
      <div class="lobby-title">ASTEROCKS</div>
      <div class="lobby-status" id="lobbyStatus">Connecting...</div>
      <div class="lobby-options" id="lobbyOptions">
        <button class="lobby-btn" id="soloPlayBtn">Play Solo</button>
        <button class="lobby-btn lobby-btn-primary" id="coopPlayBtn" disabled>Co-op Mode</button>
        <button class="lobby-btn lobby-btn-vs" id="vsPlayBtn" disabled>VS Mode (PvP)</button>
        <button class="lobby-btn lobby-btn-any" id="anyPlayerBtn">Any Player (Battle Royale)</button>
      </div>
      <div class="lobby-hint">Co-op: Team up | VS: 1v1 Battle | Any Player: Join anyone's fight!</div>
    </div>
  </div>
  
  <!-- Join Request Popup -->
  <div class="join-request-overlay" id="joinRequestOverlay">
    <div class="join-request-content">
      <div class="join-request-title">INCOMING TRANSMISSION</div>
      <div class="join-request-message" id="joinRequestMessage">Another player wants to join your game!</div>
      <div class="join-request-mode" id="joinRequestMode"></div>
      <div class="join-request-buttons">
        <button class="join-request-btn join-request-accept" id="acceptJoinBtn">Accept</button>
        <button class="join-request-btn join-request-decline" id="declineJoinBtn">Decline</button>
      </div>
    </div>
  </div>
  
  <!-- Player List (Battle Royale) -->
  <div id="playerList">
    <div class="player-list-title">Battle Royale</div>
    <div id="playerListContent"></div>
  </div>
  
  <!-- Screen Saver Overlay -->
  <div id="screenSaverOverlay">
    <div class="screensaver-particles" id="screensaverParticles"></div>
    <div class="screensaver-content">
      <div class="screensaver-logo">ASTEROCKS</div>
      <div class="screensaver-subtitle">Multiplayer Asteroid Game</div>
      <div class="screensaver-status" id="screensaverStatus">Monitoring...</div>
      <div class="screensaver-hint">Move mouse or press any key to resume</div>
    </div>
  </div>
  
  <div class="container">
  </div>

<script>
// Asterocks - Multiplayer Asteroid Battle Game

// ===== DOUBLE-TAP/DOUBLE-CLICK JOYSTICK CONTROL SYSTEM (DISABLED - KEYBOARD ONLY) =====
(function() {
  let lastTapTime = 0;
  const DOUBLE_TAP_DELAY = 300; // milliseconds
  const controlPanel = document.getElementById('controlPanel');
  const closePanelBtn = document.getElementById('closePanelBtn');
  const dragHandle = document.getElementById('dragHandle');
  let isManualControl = true; // Always true for keyboard control
  
  // Drag state
  let isDragging = false;
  let dragOffsetX = 0;
  let dragOffsetY = 0;
  
  // Helper function to toggle control panel
  function toggleControlPanel() {
    if (controlPanel.classList.contains('active')) {
      controlPanel.classList.remove('active');
      isManualControl = false;
    } else {
      controlPanel.classList.add('active');
      isManualControl = true;
    }
  }
  
  // Auto-enable on mobile devices
  if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
    controlPanel.classList.add('active');
    isManualControl = true;
    console.log('Mobile controls enabled');
  }
  
  // Double-click detection (DISABLED)
  // document.addEventListener('dblclick', function(e) { });
  
  // Double-tap detection (DISABLED)
  // document.addEventListener('touchstart', function(e) { });
  
  // Close button
  closePanelBtn.addEventListener('click', function() {
    controlPanel.classList.remove('active');
    isManualControl = false;
  });
  
  // Drag functionality
  function startDrag(e) {
    e.preventDefault();
    isDragging = true;
    
    const rect = controlPanel.getBoundingClientRect();
    const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
    const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
    
    dragOffsetX = clientX - rect.left;
    dragOffsetY = clientY - rect.top;
    
    dragHandle.style.cursor = 'grabbing';
  }
  
  function drag(e) {
    if (!isDragging) return;
    e.preventDefault();
    
    const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
    const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
    
    let newLeft = clientX - dragOffsetX;
    let newTop = clientY - dragOffsetY;
    
    // Keep panel within viewport bounds
    const maxLeft = window.innerWidth - controlPanel.offsetWidth;
    const maxTop = window.innerHeight - controlPanel.offsetHeight;
    
    newLeft = Math.max(0, Math.min(newLeft, maxLeft));
    newTop = Math.max(0, Math.min(newTop, maxTop));
    
    controlPanel.style.left = newLeft + 'px';
    controlPanel.style.top = newTop + 'px';
    controlPanel.style.right = 'auto';
    controlPanel.style.bottom = 'auto';
  }
  
  function stopDrag(e) {
    if (isDragging) {
      e.preventDefault();
      isDragging = false;
      dragHandle.style.cursor = 'move';
    }
  }
  
  // Touch events
  dragHandle.addEventListener('touchstart', startDrag);
  document.addEventListener('touchmove', drag);
  document.addEventListener('touchend', stopDrag);
  
  // Mouse events
  dragHandle.addEventListener('mousedown', startDrag);
  document.addEventListener('mousemove', drag);
  document.addEventListener('mouseup', stopDrag);
  
  // Joystick controls
  const upBtn = document.getElementById('upBtn');
  const downBtn = document.getElementById('downBtn');
  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const fireBtn = document.getElementById('fireBtn');
  
  // Keyboard state tracking
  const keyboardState = {
    ArrowUp: false,
    ArrowDown: false,
    ArrowLeft: false,
    ArrowRight: false,
    ' ': false, // Spacebar
    'b': false, // Bomb drop
    'B': false, // Bomb drop (uppercase)
    'h': false, // Hyperspace
    'H': false  // Hyperspace (uppercase)
  };

  // Listen for keyboard events
  document.addEventListener('keydown', function(e) {
    if (e.key in keyboardState) {
      keyboardState[e.key] = true;
      e.preventDefault();
    }
  });

  document.addEventListener('keyup', function(e) {
    if (e.key in keyboardState) {
      keyboardState[e.key] = false;
      e.preventDefault();
    }
  });

  // Export manual control state and button states for game to use
  window.joystickControl = {
    isManualControl: () => isManualControl,
    getThrust: () => false,
    getRotation: () => 0,
    getFire: () => false,
    pressedButtons: {
      up: false,
      down: false,
      left: false,
      right: false,
      fire: false,
      hyperspace: false
    },
    keyboardState: keyboardState
  };
  
  // Button event handlers
  function setupButton(btn, key) {
    btn.addEventListener('touchstart', function(e) {
      e.preventDefault();
      window.joystickControl.pressedButtons[key] = true;
    });
    
    btn.addEventListener('touchend', function(e) {
      e.preventDefault();
      window.joystickControl.pressedButtons[key] = false;
    });
    
    btn.addEventListener('mousedown', function(e) {
      e.preventDefault();
      window.joystickControl.pressedButtons[key] = true;
    });
    
    btn.addEventListener('mouseup', function(e) {
      e.preventDefault();
      window.joystickControl.pressedButtons[key] = false;
    });
  }
  
  setupButton(upBtn, 'up');
  setupButton(downBtn, 'down');
  setupButton(leftBtn, 'left');
  setupButton(rightBtn, 'right');
  setupButton(fireBtn, 'fire');
  
  // Hyperspace button handler
  const hyperspaceBtn = document.getElementById('hyperspaceBtn');
  if (hyperspaceBtn) {
    hyperspaceBtn.addEventListener('touchstart', function(e) {
      e.preventDefault();
      window.joystickControl.pressedButtons.hyperspace = true;
    });
    
    hyperspaceBtn.addEventListener('touchend', function(e) {
      e.preventDefault();
      window.joystickControl.pressedButtons.hyperspace = false;
    });
    
    hyperspaceBtn.addEventListener('mousedown', function(e) {
      e.preventDefault();
      window.joystickControl.pressedButtons.hyperspace = true;
    });
    
    hyperspaceBtn.addEventListener('mouseup', function(e) {
      e.preventDefault();
      window.joystickControl.pressedButtons.hyperspace = false;
    });
  }
})();

// ===== ARCADE SOUND EFFECTS SYSTEM =====
class ArcadeSound {
  constructor(audioContext) {
    this.ctx = audioContext;
  }
  
  playShoot() {
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    
    osc.frequency.setValueAtTime(400, this.ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 0.1);
    
    gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
    
    osc.start(this.ctx.currentTime);
    osc.stop(this.ctx.currentTime + 0.1);
  }
  
  playAsteroidHit(baseFreq = 150) {
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    
    osc.type = 'square';
    osc.frequency.setValueAtTime(baseFreq, this.ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(baseFreq / 2, this.ctx.currentTime + 0.15);
    
    gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);
    
    osc.start(this.ctx.currentTime);
    osc.stop(this.ctx.currentTime + 0.15);
  }
  
  playExplosion() {
    // Create a noise burst for explosion
    const bufferSize = this.ctx.sampleRate * 0.5; // 0.5 seconds
    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < bufferSize; i++) {
      data[i] = Math.random() * 2 - 1;
    }
    
    const source = this.ctx.createBufferSource();
    source.buffer = buffer;
    
    const gain = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();
    
    source.connect(filter);
    filter.connect(gain);
    gain.connect(this.ctx.destination);
    
    filter.type = 'highpass';
    filter.frequency.setValueAtTime(200, this.ctx.currentTime);
    filter.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.5);
    
    gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
    
    source.start(this.ctx.currentTime);
    source.stop(this.ctx.currentTime + 0.5);
  }
  
  playHyperspace() {
    // Classic oscillating "whoosh" sound
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    
    osc.type = 'triangle';
    
    // Pitch sweep: low to high to low
    const duration = 0.4;
    osc.frequency.setValueAtTime(100, this.ctx.currentTime);
    osc.frequency.linearRampToValueAtTime(800, this.ctx.currentTime + duration / 2);
    osc.frequency.linearRampToValueAtTime(100, this.ctx.currentTime + duration);
    
    gain.gain.setValueAtTime(0.25, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
    
    osc.start(this.ctx.currentTime);
    osc.stop(this.ctx.currentTime + duration);
  }
  
  playUfoTheme() {
    // Classic UFO "beep-boop" sound
    const osc1 = this.ctx.createOscillator();
    const osc2 = this.ctx.createOscillator();
    const gain1 = this.ctx.createGain();
    const gain2 = this.ctx.createGain();
    const mainGain = this.ctx.createGain();
    
    osc1.connect(gain1);
    osc2.connect(gain2);
    gain1.connect(mainGain);
    gain2.connect(mainGain);
    mainGain.connect(this.ctx.destination);
    
    osc1.frequency.setValueAtTime(400, this.ctx.currentTime);
    osc2.frequency.setValueAtTime(300, this.ctx.currentTime);
    
    gain1.gain.setValueAtTime(0.15, this.ctx.currentTime);
    gain2.gain.setValueAtTime(0.15, this.ctx.currentTime);
    
    mainGain.gain.setValueAtTime(0.2, this.ctx.currentTime);
    mainGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
    
    osc1.start(this.ctx.currentTime);
    osc2.start(this.ctx.currentTime);
    osc1.stop(this.ctx.currentTime + 0.3);
    osc2.stop(this.ctx.currentTime + 0.3);
  }
  
  playUfoBullet() {
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    
    osc.frequency.setValueAtTime(600, this.ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(300, this.ctx.currentTime + 0.08);
    
    gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.08);
    
    osc.start(this.ctx.currentTime);
    osc.stop(this.ctx.currentTime + 0.08);
  }
  
  playThrust() {
    // Subtle rumble for engine thrust
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    
    osc.type = 'square';
    osc.frequency.setValueAtTime(80, this.ctx.currentTime);
    osc.frequency.linearRampToValueAtTime(120, this.ctx.currentTime + 0.1);
    osc.frequency.linearRampToValueAtTime(80, this.ctx.currentTime + 0.2);
    
    gain.gain.setValueAtTime(0.03, this.ctx.currentTime);
    gain.gain.linearRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
    
    osc.start(this.ctx.currentTime);
    osc.stop(this.ctx.currentTime + 0.2);
  }
}

// Initialize audio context
let audioContext = null;
let arcadeSound = null;
let soundEnabled = true; // Global sound state

function initAudio() {
  if (!audioContext) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    arcadeSound = new ArcadeSound(audioContext);
  }
}

// Sound playback helpers
function playSound(soundName) {
  if (!soundEnabled) return; // Don't play if sound is disabled
  if (!arcadeSound) initAudio();
  
  // Resume audio context if suspended (required on some browsers)
  if (audioContext.state === 'suspended') {
    audioContext.resume();
  }
  
  switch(soundName) {
    case 'shoot': arcadeSound.playShoot(); break;
    case 'hit': arcadeSound.playAsteroidHit(); break;
    case 'explosion': arcadeSound.playExplosion(); break;
    case 'hyperspace': arcadeSound.playHyperspace(); break;
    case 'ufo': arcadeSound.playUfoTheme(); break;
    case 'ufobullet': arcadeSound.playUfoBullet(); break;
    case 'thrust': arcadeSound.playThrust(); break;
  }
}

// ===== ASTEROID GAME BACKGROUND ANIMATION =====
(function() {
  const canvas = document.getElementById('asteroidCanvas');
  const ctx = canvas.getContext('2d');
  
  // Set canvas size to match window
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  
  // Game state
  const ship = {
    x: canvas.width / 2,
    y: canvas.height / 2,
    angle: 0,
    velocity: { x: 0, y: 0 },
    size: 15,
    thrust: false,
    rotation: 0,
    exploded: false,
    respawnTime: 0
  };
  
  const asteroids = [];
  const bullets = [];
  const particles = [];
  const stars = [];
  const ufos = [];
  const ufoBullets = [];
  const aliens = []; // Rare powerful aliens
  const bombs = []; // Bombs for anyplayer mode
  const MAX_BOMBS = 5; // Maximum bombs per player
  let bombCount = 0; // Current number of active bombs
  let lastBombRefreshTime = Date.now(); // Track bomb refresh timer
  const BOMB_REFRESH_INTERVAL = 20000; // 20 seconds
  let lastHugeAsteroidTime = Date.now();
  const HUGE_ASTEROID_INTERVAL = 20000; // 20 seconds
  let lastUfoTime = Date.now();
  let nextUfoInterval = 20000 + Math.random() * 15000; // 20-35 seconds
  let lastAlienTime = Date.now();
  let nextAlienInterval = 45000 + Math.random() * 30000; // 45-75 seconds (rare)
  let lastHyperspaceTime = 0;
  const HYPERSPACE_COOLDOWN = 8000; // 8 seconds
  
  // Game state
  let score = 0;
  let lives = 3;
  let nextExtraLifeAt = 1000; // Score threshold for next extra life
  let gameOver = false;
  let gamePaused = false;
  // soundEnabled is global (defined outside this scope)
  let dualCannon = false; // Powerup from destroying UFO
  let vsKills = 0; // Kill counter for VS mode
  let playerKills = 0; // Battle Royale kills counter
  let playerDeaths = 0; // Battle Royale deaths counter
  
  // Create background stars - fills entire window
  function generateStarfield() {
    stars.length = 0; // Clear existing stars
    const starCount = Math.ceil((window.innerWidth * window.innerHeight) / 8000); // ~1 star per 8000px
    for (let i = 0; i < starCount; i++) {
      stars.push({
        x: Math.random() * window.innerWidth,
        y: Math.random() * window.innerHeight,
        size: Math.random() * 1.5 + 0.5,
        opacity: Math.random() * 0.5 + 0.3
      });
    }
  }
  generateStarfield();
  
  // Regenerate stars on window resize
  window.addEventListener('resize', generateStarfield);
  
  // Track red asteroid fragments
  let redAsteroidFragments = new Set(); // IDs of fragments from red asteroid
  let redAsteroidId = 0; // Counter for unique IDs
  let dualThruster = false; // Dual thruster powerup state
  let thrusterPower = 1; // Thruster power multiplier
  let tripleCannon = false; // Triple cannon powerup (from alien)
  let cannonRange = 1; // Bullet range multiplier
  let largerForcefield = false; // Larger forcefield from alien
  
  // Track blue asteroid fragments
  let blueAsteroidFragments = new Set(); // IDs of fragments from blue asteroid
  let blueAsteroidId = 0; // Counter for unique IDs
  let energyForcefield = false; // Energy forcefield powerup state

  // Helper function to check if player is leading in anyplayer mode
  function isLeadingPlayer() {
    const allPlayers = window.getAllPlayers ? window.getAllPlayers() : {};
    const myScore = score;
    
    // Check if we have the highest score
    for (const player of Object.values(allPlayers)) {
      if (player.score > myScore) {
        return false;
      }
    }
    
    return Object.keys(allPlayers).length > 0; // Only show if there are other players
  }

  // Powerup sync functions for co-op
  window.getPowerups = () => {
    return {
      dualCannon,
      dualThruster,
      thrusterPower,
      energyForcefield,
      tripleCannon,
      cannonRange,
      largerForcefield
    };
  };
  
  window.syncPowerups = (powerups) => {
    // In co-op mode, sync powerups from other player
    if (window.getGameMode && window.getGameMode() === 'coop') {
      dualCannon = dualCannon || powerups.dualCannon;
      dualThruster = dualThruster || powerups.dualThruster;
      tripleCannon = tripleCannon || powerups.tripleCannon;
      thrusterPower = Math.max(thrusterPower, powerups.thrusterPower);
      cannonRange = Math.max(cannonRange, powerups.cannonRange);
      energyForcefield = energyForcefield || powerups.energyForcefield;
      largerForcefield = largerForcefield || powerups.largerForcefield;
    }
  };
  
  // Handle being hit by other player in VS or anyplayer mode
  window.handlePlayerHit = () => {
    const gameMode = window.getGameMode ? window.getGameMode() : 'solo';
    if ((gameMode === 'vs' || gameMode === 'anyplayer') && !ship.exploded) {
      lives--;
      
      // In royal mode, track deaths instead of lives
      if (gameMode === 'anyplayer') {
        playerDeaths++;
        console.log(`Hit by other player! Deaths: ${playerDeaths}/50`);
      } else {
        console.log(`Hit by other player! Lives remaining: ${lives}`);
      }
      
      dualCannon = false;
      dualThruster = false;
      thrusterPower = 1;
      tripleCannon = false;
      cannonRange = 1;
      energyForcefield = false;
      largerForcefield = false;
      ship.exploded = true;
      ship.respawnTime = Date.now() + 3000;
      createParticles(ship.x, ship.y, 30);
      playSound('explosion');
      
      // Check game over conditions
      const shouldGameOver = gameMode === 'anyplayer' ? playerDeaths >= 50 : lives <= 0;
      
      if (shouldGameOver) {
        // Opponent killed us - they get a kill
        if (window.broadcastKill) {
          window.broadcastKill();
        }
        gameOver = true;
        const modeText = gameMode === 'anyplayer' ? 'Battle Royale' : 'VS Mode';
        console.log(`GAME OVER - Defeated in ${modeText}!`);
      }
    }
  };

  // Create initial asteroids
  function createAsteroid(x, y, size, velocity, isRed = false, fragmentId = null, isBlue = false, blueFragmentId = null) {
    // Determine if this asteroid has a prize word (only large asteroids)
    let prizeWord = null;
    const asteroidSize = size || Math.random() * 30 + 20;
    if (asteroidSize >= 60 && !isRed && !isBlue && Math.random() < 0.3) { // 30% chance for large asteroids
      const prizes = ['LASER', 'FORCE', 'THRUST'];
      prizeWord = prizes[Math.floor(Math.random() * prizes.length)];
    }
    
    return {
      x: x || Math.random() * canvas.width,
      y: y || Math.random() * canvas.height,
      velocity: velocity || {
        x: (Math.random() - 0.5) * 2,
        y: (Math.random() - 0.5) * 2
      },
      size: asteroidSize,
      angle: Math.random() * Math.PI * 2,
      rotation: (Math.random() - 0.5) * 0.05,
      points: generateAsteroidShape(),
      isRed: isRed,
      fragmentId: fragmentId, // Tracks which red asteroid this belongs to
      isBlue: isBlue,
      blueFragmentId: blueFragmentId, // Tracks which blue asteroid this belongs to
      prizeWord: prizeWord // Prize word for large asteroids
    };
  }
  
  // Create huge asteroid entering from edge
  function spawnHugeAsteroid() {
    const edge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
    let x, y, velocity;
    const speed = 3 + Math.random() * 2; // Faster than normal
    const size = 80 + Math.random() * 40; // Much larger (80-120)
    
    if (edge === 0) { // top
      x = Math.random() * canvas.width;
      y = -size;
      velocity = { x: (Math.random() - 0.5) * 2, y: speed };
    } else if (edge === 1) { // right
      x = canvas.width + size;
      y = Math.random() * canvas.height;
      velocity = { x: -speed, y: (Math.random() - 0.5) * 2 };
    } else if (edge === 2) { // bottom
      x = Math.random() * canvas.width;
      y = canvas.height + size;
      velocity = { x: (Math.random() - 0.5) * 2, y: -speed };
    } else { // left
      x = -size;
      y = Math.random() * canvas.height;
      velocity = { x: speed, y: (Math.random() - 0.5) * 2 };
    }
    
    // 20% chance to spawn as red asteroid, 15% chance for blue
    const rand = Math.random();
    const isRed = rand < 0.2;
    const isBlue = !isRed && rand < 0.35; // 15% chance (0.2 to 0.35)
    const fragmentId = isRed ? ++redAsteroidId : null;
    const blueFragmentId = isBlue ? ++blueAsteroidId : null;
    
    if (isRed) {
      redAsteroidFragments.add(fragmentId);
    }
    if (isBlue) {
      blueAsteroidFragments.add(blueFragmentId);
    }
    
    asteroids.push(createAsteroid(x, y, size, velocity, isRed, fragmentId, isBlue, blueFragmentId));
    console.log(`Huge asteroid spawned! Size: ${size.toFixed(0)}${isRed ? ' (RED - Dual Thruster!)' : isBlue ? ' (BLUE - Energy Forcefield!)' : ''}`);
  }
  
  // Spawn UFO
  function spawnUfo() {
    const edge = Math.floor(Math.random() * 2); // 0=left, 1=right
    const y = Math.random() * (canvas.height * 0.8) + canvas.height * 0.1; // Middle 80% of screen
    let x, velocityX;
    
    if (edge === 0) { // left side, moving right
      x = -60;
      velocityX = 2.5 + Math.random() * 1.5; // Slower (was 5-8, now 2.5-4)
    } else { // right side, moving left
      x = canvas.width + 60;
      velocityX = -(2.5 + Math.random() * 1.5); // Slower (was 5-8, now 2.5-4)
    }
    
    ufos.push({
      x,
      y,
      velocityX,
      velocityY: 0,
      targetY: y,
      size: 30,
      bobOffset: Math.random() * Math.PI * 2,
      glowPhase: 0,
      lastShotTime: Date.now(),
      aggressionLevel: Math.random() // 0-1, higher = more aggressive
    });
    playSound('ufo');
    console.log('UFO spawned!');
  }
  
  // Spawn rare Alien spacecraft
  function spawnAlien() {
    const edge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
    let x, y, velocityX, velocityY;
    const speed = 6 + Math.random() * 4; // Fast moving
    
    if (edge === 0) { // top
      x = Math.random() * canvas.width;
      y = -80;
      velocityX = (Math.random() - 0.5) * 4;
      velocityY = speed;
    } else if (edge === 1) { // right
      x = canvas.width + 80;
      y = Math.random() * canvas.height;
      velocityX = -speed;
      velocityY = (Math.random() - 0.5) * 4;
    } else if (edge === 2) { // bottom
      x = Math.random() * canvas.width;
      y = canvas.height + 80;
      velocityX = (Math.random() - 0.5) * 4;
      velocityY = -speed;
    } else { // left
      x = -80;
      y = Math.random() * canvas.height;
      velocityX = speed;
      velocityY = (Math.random() - 0.5) * 4;
    }
    
    aliens.push({
      x,
      y,
      velocityX,
      velocityY,
      size: 40,
      rotationAngle: 0,
      glowPhase: 0,
      pulsePhase: 0,
      health: 5 // Takes 5 hits to destroy
    });
    playSound('ufo');
    console.log('üõ∏ RARE ALIEN SPACECRAFT DETECTED!');
  }
  
  // Update Aliens
  function updateAliens() {
    aliens.forEach((alien, index) => {
      alien.x += alien.velocityX;
      alien.y += alien.velocityY;
      alien.rotationAngle += 0.03;
      alien.glowPhase += 0.08;
      alien.pulsePhase += 0.05;
      
      // Check collision with player bullets
      bullets.forEach((bullet, bIndex) => {
        const dx = bullet.x - alien.x;
        const dy = bullet.y - alien.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < alien.size) {
          // Alien hit!
          alien.health--;
          createParticles(alien.x, alien.y, 10);
          bullets.splice(bIndex, 1);
          playSound('hit');
          
          if (alien.health <= 0) {
            // Alien destroyed! Award powerful powerups
            createParticles(alien.x, alien.y, 40);
            aliens.splice(index, 1);
            playSound('explosion');
            score += 1000; // Huge points for alien!
            
            // Award triple cannon with 2x range
            tripleCannon = true;
            cannonRange = 2;
            
            // Award super thrusters (4x power)
            dualThruster = true;
            thrusterPower = 4;
            
            // Award larger forcefield
            energyForcefield = true;
            largerForcefield = true;
            
            console.log('üéâ ALIEN DESTROYED! ULTIMATE POWERUPS UNLOCKED!');
            console.log('‚ö° Triple Cannon (2x Range) | üöÄ Super Thrusters (4x) | üõ°Ô∏è Larger Forcefield');
          }
        }
      });
      
      // Remove if off screen
      if (alien.x < -150 || alien.x > canvas.width + 150 || 
          alien.y < -150 || alien.y > canvas.height + 150) {
        aliens.splice(index, 1);
        console.log('Alien escaped!');
      }
    });
  }
  
  // Draw Aliens
  function drawAliens() {
    aliens.forEach(alien => {
      ctx.save();
      ctx.translate(alien.x, alien.y);
      ctx.rotate(alien.rotationAngle);
      
      // Powerful glow effect
      const glowIntensity = 0.5 + Math.sin(alien.glowPhase) * 0.3;
      const pulseSize = 1 + Math.sin(alien.pulsePhase) * 0.1;
      
      ctx.shadowColor = `rgba(255, 100, 255, ${glowIntensity})`;
      ctx.shadowBlur = 30;
      
      // Outer ring (rotating)
      ctx.strokeStyle = 'rgba(255, 100, 255, 0.8)';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(0, 0, alien.size * pulseSize, 0, Math.PI * 2);
      ctx.stroke();
      
      // Inner crystal core
      ctx.fillStyle = 'rgba(200, 50, 255, 0.7)';
      ctx.strokeStyle = 'rgba(255, 150, 255, 0.9)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        const r = alien.size * 0.5 * pulseSize;
        const x = Math.cos(angle) * r;
        const y = Math.sin(angle) * r;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Energy beams
      for (let i = 0; i < 3; i++) {
        const beamAngle = (i / 3) * Math.PI * 2 + alien.rotationAngle * 2;
        ctx.strokeStyle = `rgba(255, 100, 255, ${0.4 + glowIntensity * 0.3})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(beamAngle) * alien.size * 0.8, Math.sin(beamAngle) * alien.size * 0.8);
        ctx.stroke();
      }
      
      // Health indicator
      ctx.shadowBlur = 0;
      ctx.fillStyle = 'rgba(255, 100, 255, 0.9)';
      ctx.font = 'bold 10px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText(`HP: ${alien.health}`, 0, alien.size + 15);
      
      ctx.restore();
      
      // Label
      ctx.fillStyle = 'rgba(255, 100, 255, 0.9)';
      ctx.font = 'bold 11px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('üõ∏ ALIEN', alien.x, alien.y - alien.size - 10);
    });
  }
  
  // Update UFOs
  function updateUfos() {
    ufos.forEach((ufo, index) => {
      ufo.x += ufo.velocityX;
      ufo.bobOffset += 0.05;
      ufo.glowPhase += 0.1;
      
      // Erratic vertical movement - track player
      if (!ship.exploded && ufo.x > 50 && ufo.x < canvas.width - 50) {
        // Change target Y occasionally for unpredictable movement
        if (Math.random() < 0.02) {
          // Sometimes chase player, sometimes random
          if (Math.random() < 0.7 + ufo.aggressionLevel * 0.3) {
            // Chase player Y position
            ufo.targetY = ship.y + (Math.random() - 0.5) * 100;
          } else {
            // Random Y position
            ufo.targetY = Math.random() * canvas.height;
          }
          // Keep within bounds
          ufo.targetY = Math.max(50, Math.min(canvas.height - 50, ufo.targetY));
        }
        
        // Move toward target Y
        const yDiff = ufo.targetY - ufo.y;
        ufo.velocityY = yDiff * 0.05; // Smooth movement
        ufo.y += ufo.velocityY;
      }
      
      // Check collision with ship - UFOs destroy on contact
      if (!ship.exploded && !gameOver) {
        const bobY = ufo.y + Math.sin(ufo.bobOffset) * 3;
        const dx = ship.x - ufo.x;
        const dy = ship.y - bobY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < ufo.size + ship.size) {
          if (energyForcefield) {
            // Forcefield absorbs hit and is destroyed
            energyForcefield = false;
            createParticles(ship.x, ship.y, 20);
            playSound('hit');
            console.log('üõ°Ô∏è FORCEFIELD ABSORBED UFO COLLISION!');
            // Push UFO away
            const pushAngle = Math.atan2(ufo.y - ship.y, ufo.x - ship.x);
            ufo.x += Math.cos(pushAngle) * 50;
            ufo.y += Math.sin(pushAngle) * 50;
          } else {
            // Ship destroyed by UFO collision
            lives--;
            dualCannon = false;
            dualThruster = false;
            thrusterPower = 1;
            tripleCannon = false;
            cannonRange = 1;
            energyForcefield = false;
            largerForcefield = false;
            ship.exploded = true;
            ship.respawnTime = Date.now() + 3000;
            createParticles(ship.x, ship.y, 30);
            playSound('explosion');
            
            const currentGameMode = window.getGameMode ? window.getGameMode() : 'solo';
            if (currentGameMode === 'anyplayer') {
              playerDeaths++;
              console.log(`Ship destroyed by UFO collision! Deaths: ${playerDeaths}/50`);
              if (playerDeaths >= 50) {
                gameOver = true;
                console.log('GAME OVER!');
              }
            } else {
              console.log(`Ship destroyed by UFO collision! Lives remaining: ${lives}`);
              if (lives <= 0) {
                gameOver = true;
                console.log('GAME OVER!');
              }
            }
          }
        }
      }
      
      // Shoot at ship if not exploded and on screen - more aggressive
      if (!ship.exploded && ufo.x > 0 && ufo.x < canvas.width) {
        const now = Date.now();
        const shootInterval = 1500 - (ufo.aggressionLevel * 500); // 1.5s to 1s based on aggression
        if (now - ufo.lastShotTime > shootInterval) {
          const bobY = ufo.y + Math.sin(ufo.bobOffset) * 5;
          const dx = ship.x - ufo.x;
          const dy = ship.y - bobY;
          const angle = Math.atan2(dy, dx);
          
          ufoBullets.push({
            x: ufo.x,
            y: bobY,
            velocity: {
              x: Math.cos(angle) * 4,
              y: Math.sin(angle) * 4
            },
            life: 120
          });
          playSound('ufobullet');
          ufo.lastShotTime = now;
        }
      }
      
      // Check collision with player bullets
      bullets.forEach((bullet, bIndex) => {
        const bobY = ufo.y + Math.sin(ufo.bobOffset) * 5;
        const dx = bullet.x - ufo.x;
        const dy = bullet.y - bobY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < ufo.size) {
          // UFO destroyed!
          createParticles(ufo.x, bobY, 20);
          bullets.splice(bIndex, 1);
          ufos.splice(index, 1);
          playSound('explosion');
          score += 200; // Big points for UFO!
          dualCannon = true; // Award dual cannon powerup
          console.log('UFO destroyed! Dual cannon activated!');
        }
      });
      
      // Remove if off screen
      if (ufo.x < -100 || ufo.x > canvas.width + 100) {
        ufos.splice(index, 1);
      }
    });
  }
  
  // Update UFO bullets
  function updateUfoBullets() {
    ufoBullets.forEach((bullet, index) => {
      bullet.x += bullet.velocity.x;
      bullet.y += bullet.velocity.y;
      bullet.life--;
      
      // Check collision with ship - UFO bullets always destroy
      if (!ship.exploded) {
        const dx = bullet.x - ship.x;
        const dy = bullet.y - ship.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < ship.size) {
          // Ship hit by UFO bullet - always destroyed!
          lives--;
          dualCannon = false; // Lose powerup on death
          dualThruster = false; // Lose dual thruster on death
          thrusterPower = 1; // Reset thruster power
          tripleCannon = false;
          cannonRange = 1;
          energyForcefield = false; // Lose forcefield
          largerForcefield = false;
          ship.exploded = true;
          ship.respawnTime = Date.now() + 3000;
          createParticles(ship.x, ship.y, 30);
          ufoBullets.splice(index, 1);
          playSound('explosion');
          
          const currentGameMode = window.getGameMode ? window.getGameMode() : 'solo';
          if (currentGameMode === 'anyplayer') {
            playerDeaths++;
            console.log(`Ship destroyed by UFO bullet! Deaths: ${playerDeaths}/50`);
            if (playerDeaths >= 50) {
              gameOver = true;
              console.log('GAME OVER!');
            }
          } else {
            console.log(`Ship destroyed by UFO bullet! Lives remaining: ${lives}`);
            if (lives <= 0) {
              gameOver = true;
              console.log('GAME OVER!');
            }
          }
          return;
        }
      }
      
      if (bullet.life <= 0 || bullet.x < 0 || bullet.x > canvas.width || 
          bullet.y < 0 || bullet.y > canvas.height) {
        ufoBullets.splice(index, 1);
      }
    });
  }
  
  // Draw UFOs
  function drawUfos() {
    ufos.forEach(ufo => {
      const bobY = ufo.y + Math.sin(ufo.bobOffset) * 3; // Reduced bob for more aggressive look
      
      ctx.save();
      ctx.translate(ufo.x, bobY);
      
      // Glow effect
      const glowIntensity = 0.3 + Math.sin(ufo.glowPhase) * 0.2;
      ctx.shadowColor = `rgba(126, 240, 163, ${glowIntensity})`;
      ctx.shadowBlur = 20;
      
      // UFO dome (top)
      ctx.fillStyle = 'rgba(126, 240, 163, 0.7)';
      ctx.beginPath();
      ctx.ellipse(0, -5, ufo.size * 0.4, ufo.size * 0.3, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // UFO body (disc)
      ctx.fillStyle = 'rgba(126, 200, 255, 0.6)';
      ctx.strokeStyle = 'rgba(126, 240, 163, 0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(0, 0, ufo.size, ufo.size * 0.3, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();
      
      // Windows
      ctx.fillStyle = 'rgba(255, 255, 100, 0.9)';
      for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2;
        const wx = Math.cos(angle) * ufo.size * 0.5;
        const wy = Math.sin(angle) * ufo.size * 0.15;
        ctx.beginPath();
        ctx.arc(wx, wy, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Light beam (occasionally)
      if (Math.sin(ufo.glowPhase) > 0.5) {
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(126, 240, 163, 0.15)';
        ctx.beginPath();
        ctx.moveTo(-10, ufo.size * 0.3);
        ctx.lineTo(-15, 80);
        ctx.lineTo(15, 80);
        ctx.lineTo(10, ufo.size * 0.3);
        ctx.closePath();
        ctx.fill();
      }
      
      ctx.restore();
    });
  }
  
  function generateAsteroidShape() {
    const points = [];
    const numPoints = Math.floor(Math.random() * 4) + 6;
    for (let i = 0; i < numPoints; i++) {
      const angle = (i / numPoints) * Math.PI * 2;
      const radius = 0.7 + Math.random() * 0.3;
      points.push({ angle, radius });
    }
    return points;
  }
  
  // Initialize asteroids (4 small ones)
  for (let i = 0; i < 4; i++) {
    asteroids.push(createAsteroid(null, null, Math.random() * 20 + 15)); // Small: 15-35px
  }
  
  // Create particle effect
  function createParticles(x, y, count) {
    // Cap total particles to 500 for performance
    if (particles.length > 500) {
      particles.splice(0, count + 50); // Remove oldest particles
    }
    for (let i = 0; i < count; i++) {
      particles.push({
        x,
        y,
        velocity: {
          x: (Math.random() - 0.5) * 4,
          y: (Math.random() - 0.5) * 4
        },
        life: 1,
        size: Math.random() * 2 + 1
      });
    }
  }
  
  function createBombExplosion(x, y) {
    // Create expanding shockwave rings
    const shockwaveCount = 3;
    for (let ring = 0; ring < shockwaveCount; ring++) {
      const angleCount = 16 + (ring * 8); // More particles in outer rings
      const delay = ring * 50; // Stagger the rings
      
      for (let i = 0; i < angleCount; i++) {
        const angle = (Math.PI * 2 * i) / angleCount;
        const speed = 3 + ring * 1.5; // Outer rings move faster
        
        particles.push({
          x,
          y,
          velocity: {
            x: Math.cos(angle) * speed,
            y: Math.sin(angle) * speed
          },
          life: 1 - (ring * 0.15), // Outer rings fade faster
          size: 3 - ring * 0.5,
          delay: delay
        });
      }
    }
    
    // Add some random debris in center
    for (let i = 0; i < 30; i++) {
      particles.push({
        x,
        y,
        velocity: {
          x: (Math.random() - 0.5) * 6,
          y: (Math.random() - 0.5) * 6
        },
        life: 1,
        size: Math.random() * 3 + 1
      });
    }
  }
  
  // Autonomous ship AI or Manual Control
  function updateShipAI() {
    // Check if ship should respawn
    if (ship.exploded) {
      if (!gameOver && Date.now() >= ship.respawnTime) {
        ship.exploded = false;
        ship.x = canvas.width / 2;
        ship.y = canvas.height / 2;
        ship.velocity = { x: 0, y: 0 };
        ship.angle = 0;
        console.log('Ship respawned!');
      }
      return; // Don't update AI while exploded
    }
    
    // Keyboard control is always active
    const buttons = window.joystickControl.pressedButtons;
    const keyboard = window.joystickControl.keyboardState;
    const isManual = true; // Always use keyboard control
    
    if (isManual) {
      // Handle rotation (joystick or keyboard)
      if (buttons.left || keyboard.ArrowLeft) {
        ship.angle -= 0.1;
      }
      if (buttons.right || keyboard.ArrowRight) {
        ship.angle += 0.1;
      }
      
      // Handle thrust (joystick or keyboard)
      ship.thrust = buttons.up || keyboard.ArrowUp;
      if (ship.thrust) {
        ship.velocity.x += Math.cos(ship.angle) * 0.25 * thrusterPower;
        ship.velocity.y += Math.sin(ship.angle) * 0.25 * thrusterPower;
      }
      
      // Handle reverse thrust (joystick or keyboard)
      if (buttons.down || keyboard.ArrowDown) {
        ship.velocity.x -= Math.cos(ship.angle) * 0.12 * thrusterPower;
        ship.velocity.y -= Math.sin(ship.angle) * 0.12 * thrusterPower;
      }
      
      // Clamp maximum velocity for balanced gameplay
      const maxSpeed = 8;
      const speed = Math.sqrt(ship.velocity.x * ship.velocity.x + ship.velocity.y * ship.velocity.y);
      if (speed > maxSpeed) {
        const scale = maxSpeed / speed;
        ship.velocity.x *= scale;
        ship.velocity.y *= scale;
      }
      
      // Handle fire (joystick or keyboard spacebar)
      const firePressed = buttons.fire || keyboard[' '];
      if (firePressed && !ship.lastFireState) {
        if (tripleCannon) {
          // Fire three bullets (center + wings) with extended range
          const leftAngle = ship.angle - Math.PI / 2;
          const rightAngle = ship.angle + Math.PI / 2;
          const offset = ship.size * 0.5;
          
          const bulletLife = 60 * cannonRange; // Extended range
          
          // Center bullet
          const centerBullet = {
            x: ship.x + Math.cos(ship.angle) * ship.size,
            y: ship.y + Math.sin(ship.angle) * ship.size,
            velocity: {
              x: Math.cos(ship.angle) * 6,
              y: Math.sin(ship.angle) * 6
            },
            life: bulletLife,
            owner: 'me'
          };
          bullets.push(centerBullet);
          
          // Left bullet
          const leftBullet = {
            x: ship.x + Math.cos(ship.angle) * ship.size + Math.cos(leftAngle) * offset,
            y: ship.y + Math.sin(ship.angle) * ship.size + Math.sin(leftAngle) * offset,
            velocity: {
              x: Math.cos(ship.angle) * 6,
              y: Math.sin(ship.angle) * 6
            },
            life: bulletLife,
            owner: 'me'
          };
          bullets.push(leftBullet);
          
          // Right bullet
          const rightBullet = {
            x: ship.x + Math.cos(ship.angle) * ship.size + Math.cos(rightAngle) * offset,
            y: ship.y + Math.sin(ship.angle) * ship.size + Math.sin(rightAngle) * offset,
            velocity: {
              x: Math.cos(ship.angle) * 6,
              y: Math.sin(ship.angle) * 6
            },
            life: bulletLife,
            owner: 'me'
          };
          bullets.push(rightBullet);
          
          // Broadcast bullets to other player
          if (window.broadcastBullet) {
            window.broadcastBullet(centerBullet);
            window.broadcastBullet(leftBullet);
            window.broadcastBullet(rightBullet);
          }
        } else if (dualCannon) {
          // Fire two bullets from wing positions
          const leftAngle = ship.angle - Math.PI / 2;
          const rightAngle = ship.angle + Math.PI / 2;
          const offset = ship.size * 0.5;
          
          const bullet1 = {
            x: ship.x + Math.cos(ship.angle) * ship.size + Math.cos(leftAngle) * offset,
            y: ship.y + Math.sin(ship.angle) * ship.size + Math.sin(leftAngle) * offset,
            velocity: {
              x: Math.cos(ship.angle) * 6,
              y: Math.sin(ship.angle) * 6
            },
            life: 60,
            owner: 'me'
          };
          const bullet2 = {
            x: ship.x + Math.cos(ship.angle) * ship.size + Math.cos(rightAngle) * offset,
            y: ship.y + Math.sin(ship.angle) * ship.size + Math.sin(rightAngle) * offset,
            velocity: {
              x: Math.cos(ship.angle) * 6,
              y: Math.sin(ship.angle) * 6
            },
            life: 60,
            owner: 'me'
          };
          bullets.push(bullet1);
          bullets.push(bullet2);
          
          // Broadcast bullets to other player
          if (window.broadcastBullet) {
            window.broadcastBullet(bullet1);
            window.broadcastBullet(bullet2);
          }
        } else {
          // Single bullet from center
          const bullet = {
            x: ship.x + Math.cos(ship.angle) * ship.size,
            y: ship.y + Math.sin(ship.angle) * ship.size,
            velocity: {
              x: Math.cos(ship.angle) * 6,
              y: Math.sin(ship.angle) * 6
            },
            life: 60,
            owner: 'me'
          };
          bullets.push(bullet);
          
          // Broadcast bullet to other player
          if (window.broadcastBullet) {
            window.broadcastBullet(bullet);
          }
        }
        playSound('shoot');
      }
      ship.lastFireState = firePressed;
      
      // Handle hyperspace (H key)
      const hyperspacePressed = keyboard.h || keyboard.H;
      const now = Date.now();
      if (hyperspacePressed && !ship.lastHyperspaceState && now - lastHyperspaceTime > HYPERSPACE_COOLDOWN) {
        // Activate hyperspace!
        createParticles(ship.x, ship.y, 15);
        ship.x = Math.random() * canvas.width;
        ship.y = Math.random() * canvas.height;
        ship.velocity.x = 0;
        ship.velocity.y = 0;
        createParticles(ship.x, ship.y, 15);
        lastHyperspaceTime = now;
        playSound('hyperspace');
        console.log('Manual hyperspace jump!');
      }
      ship.lastHyperspaceState = hyperspacePressed;
      
      // Handle bomb drop (B key) - only in anyplayer mode
      if (window.getGameMode && window.isMultiplayerActive) {
        const currentGameMode = window.getGameMode();
        const isMultiplayerActive = window.isMultiplayerActive();
        
        if ((currentGameMode === 'anyplayer' || currentGameMode === 'vs') && isMultiplayerActive) {
          const bombPressed = keyboard.b || keyboard.B;
          if (bombPressed && !ship.lastBombState && bombCount < MAX_BOMBS) {
            // Drop a bomb at current position
            const currentPlayerId = window.getMyPlayerId ? window.getMyPlayerId() : null;
            const bomb = {
              x: ship.x,
              y: ship.y,
              owner: currentPlayerId,
              life: Infinity, // Stays until hit
              pulsePhase: 0,
              createdAt: Date.now() // Track when bomb was dropped
            };
            bombs.push(bomb);
            bombCount++;
            
            // Broadcast bomb to other players
            if (window.broadcastBombDropped) {
              window.broadcastBombDropped(bomb);
              console.log(`üí£ Bomb dropped! (${bombCount}/${MAX_BOMBS}) - Broadcast sent`);
            } else {
              console.log(`üí£ Bomb dropped! (${bombCount}/${MAX_BOMBS}) - ‚ö†Ô∏è No broadcast function available!`);
            }
            
            playSound('shoot'); // Use shoot sound for now
          }
          ship.lastBombState = bombPressed;
        }
      }
    } else {
      // Original autonomous AI
      ship.lastFireState = false;
      
      // Find nearest asteroid
      let nearest = null;
      let nearestDist = Infinity;
      
      asteroids.forEach(asteroid => {
        const dx = asteroid.x - ship.x;
        const dy = asteroid.y - ship.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < nearestDist) {
          nearestDist = dist;
          nearest = asteroid;
        }
      });
      
      if (nearest) {
        // Aim at nearest asteroid
        const dx = nearest.x - ship.x;
        const dy = nearest.y - ship.y;
        const targetAngle = Math.atan2(dy, dx);
        
        // Smooth rotation toward target
        let angleDiff = targetAngle - ship.angle;
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
        
        ship.angle += angleDiff * 0.05;
        
        // Shoot periodically
        if (Math.random() < 0.02 && Math.abs(angleDiff) < 0.3) {
          if (dualCannon) {
            // Fire two bullets from wing positions
            const leftAngle = ship.angle - Math.PI / 2;
            const rightAngle = ship.angle + Math.PI / 2;
            const offset = ship.size * 0.5;
            
            const bullet1 = {
              x: ship.x + Math.cos(ship.angle) * ship.size + Math.cos(leftAngle) * offset,
              y: ship.y + Math.sin(ship.angle) * ship.size + Math.sin(leftAngle) * offset,
              velocity: {
                x: Math.cos(ship.angle) * 6,
                y: Math.sin(ship.angle) * 6
              },
              life: 60,
              owner: 'me'
            };
            const bullet2 = {
              x: ship.x + Math.cos(ship.angle) * ship.size + Math.cos(rightAngle) * offset,
              y: ship.y + Math.sin(ship.angle) * ship.size + Math.sin(rightAngle) * offset,
              velocity: {
                x: Math.cos(ship.angle) * 6,
                y: Math.sin(ship.angle) * 6
              },
              life: 60,
              owner: 'me'
            };
            bullets.push(bullet1);
            bullets.push(bullet2);
            
            // Broadcast bullets to other player
            if (window.broadcastBullet) {
              window.broadcastBullet(bullet1);
              window.broadcastBullet(bullet2);
            }
          } else {
            const bullet = {
              x: ship.x + Math.cos(ship.angle) * ship.size,
              y: ship.y + Math.sin(ship.angle) * ship.size,
              velocity: {
                x: Math.cos(ship.angle) * 6,
                y: Math.sin(ship.angle) * 6
              },
              life: 60,
              owner: 'me'
            };
            bullets.push(bullet);
            
            // Broadcast bullet to other player
            if (window.broadcastBullet) {
              window.broadcastBullet(bullet);
            }
          }
          playSound('shoot');
        }
        
        // Thrust occasionally
        ship.thrust = Math.random() < 0.3;
        if (ship.thrust) {
          ship.velocity.x += Math.cos(ship.angle) * 0.1 * thrusterPower;
          ship.velocity.y += Math.sin(ship.angle) * 0.1 * thrusterPower;
          // playSound('thrust'); // Muted
        }
        
        // Use hyperspace in dangerous situations
        const now = Date.now();
        if (now - lastHyperspaceTime > HYPERSPACE_COOLDOWN) {
          // Check if in danger (nearby large asteroid or UFO bullets)
          let inDanger = false;
          
          asteroids.forEach(asteroid => {
            if (asteroid.size > 50) {
              const dx = asteroid.x - ship.x;
              const dy = asteroid.y - ship.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < 100) inDanger = true;
            }
          });
          
          ufoBullets.forEach(bullet => {
            const dx = bullet.x - ship.x;
            const dy = bullet.y - ship.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 80) inDanger = true;
          });
          
          if (inDanger && Math.random() < 0.1) {
            // Activate hyperspace!
            createParticles(ship.x, ship.y, 15);
            ship.x = Math.random() * canvas.width;
            ship.y = Math.random() * canvas.height;
            ship.velocity.x = 0;
            ship.velocity.y = 0;
            createParticles(ship.x, ship.y, 15);
            lastHyperspaceTime = now;
            playSound('hyperspace');
            console.log('Hyperspace jump!');
          }
        }
      }
    }
    
    // Apply velocity and friction
    ship.velocity.x *= 0.98;
    ship.velocity.y *= 0.98;
    ship.x += ship.velocity.x;
    ship.y += ship.velocity.y;
    
    // Wrap around screen
    if (ship.x < 0) ship.x = canvas.width;
    if (ship.x > canvas.width) ship.x = 0;
    if (ship.y < 0) ship.y = canvas.height;
    if (ship.y > canvas.height) ship.y = 0;
    
    // Check collision with bombs in anyplayer mode
    const currentGameMode = window.getGameMode && window.getGameMode();
    if (currentGameMode === 'anyplayer' && !ship.exploded && !gameOver) {
      const currentPlayerId = window.getMyPlayerId ? window.getMyPlayerId() : null;
      for (let i = bombs.length - 1; i >= 0; i--) {
        const bomb = bombs[i];
        // Don't hit your own bombs
        if (bomb.owner === currentPlayerId) continue;
        
        const dx = ship.x - bomb.x;
        const dy = ship.y - bomb.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < 10 + ship.size) {
          // Ship hit a bomb!
          if (energyForcefield) {
            // Forcefield absorbs bomb hit
            energyForcefield = false;
            createBombExplosion(bomb.x, bomb.y);
            playSound('hit');
            console.log('üõ°Ô∏è FORCEFIELD ABSORBED BOMB!');
          } else {
            // Ship explodes!
            lives--;
            dualCannon = false;
            dualThruster = false;
            thrusterPower = 1;
            tripleCannon = false;
            cannonRange = 1;
            largerForcefield = false;
            ship.exploded = true;
            ship.respawnTime = Date.now() + 3000;
            createBombExplosion(bomb.x, bomb.y);
            playSound('explosion');
            
            const currentGameMode = window.getGameMode ? window.getGameMode() : 'solo';
            if (currentGameMode === 'anyplayer') {
              playerDeaths++;
              console.log(`Ship destroyed by bomb! Deaths: ${playerDeaths}/50`);
              if (playerDeaths >= 50) {
                gameOver = true;
                console.log('GAME OVER!');
              }
            } else {
              console.log(`Ship destroyed by bomb! Lives remaining: ${lives}`);
              if (lives <= 0) {
                gameOver = true;
                console.log('GAME OVER!');
              }
            }
            
            // Notify the bomb owner they got a kill
            if (window.broadcastBombKill) {
              window.broadcastBombKill(currentPlayerId, bomb.owner);
              console.log(`üíÄ Killed by ${bomb.owner}'s bomb!`);
            }
          }
          
          // Remove bomb
          bombs.splice(i, 1);
          if (bomb.owner === currentPlayerId && bombCount > 0) {
            bombCount--;
          }
          
          // Broadcast bomb destruction
          if (window.broadcastBombDestroyed) {
            window.broadcastBombDestroyed(i);
          }
          break;
        }
      }
    }
  }
  
  // Update asteroids
  function updateAsteroids() {
    for (let index = 0; index < asteroids.length; index++) {
      const asteroid = asteroids[index];
      asteroid.x += asteroid.velocity.x;
      asteroid.y += asteroid.velocity.y;
      asteroid.angle += asteroid.rotation;
      
      // Wrap around screen
      if (asteroid.x < -50) asteroid.x = canvas.width + 50;
      if (asteroid.x > canvas.width + 50) asteroid.x = -50;
      if (asteroid.y < -50) asteroid.y = canvas.height + 50;
      if (asteroid.y > canvas.height + 50) asteroid.y = -50;
      
      // Check collision with ship (all asteroids destroy, unless forcefield is active)
      if (!ship.exploded && !gameOver) {
        const dx = ship.x - asteroid.x;
        const dy = ship.y - asteroid.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < asteroid.size + ship.size) {
          if (energyForcefield) {
            // Forcefield absorbs hit and is destroyed
            energyForcefield = false;
            createParticles(ship.x, ship.y, 20);
            playSound('hit');
            console.log('üõ°Ô∏è FORCEFIELD ABSORBED HIT!');
            // Push asteroid away
            const pushAngle = Math.atan2(asteroid.y - ship.y, asteroid.x - ship.x);
            asteroid.velocity.x += Math.cos(pushAngle) * 3;
            asteroid.velocity.y += Math.sin(pushAngle) * 3;
          } else {
            // Ship explodes!
            lives--;
            dualCannon = false; // Lose powerup on death
            dualThruster = false; // Lose dual thruster on death
            thrusterPower = 1; // Reset thruster power
            tripleCannon = false;
            cannonRange = 1;
            largerForcefield = false;
            ship.exploded = true;
            ship.respawnTime = Date.now() + 3000; // Respawn after 3 seconds
            createParticles(ship.x, ship.y, 30);
            playSound('explosion');
            
            const currentGameMode = window.getGameMode ? window.getGameMode() : 'solo';
            if (currentGameMode === 'anyplayer') {
              playerDeaths++;
              console.log(`Ship destroyed by large asteroid! Deaths: ${playerDeaths}/50`);
              if (playerDeaths >= 50) {
                gameOver = true;
                console.log('GAME OVER!');
              }
            } else {
              console.log(`Ship destroyed by large asteroid! Lives remaining: ${lives}`);
              if (lives <= 0) {
                gameOver = true;
                console.log('GAME OVER!');
              }
            }
          }
        }
      }
      
      // Check collision with bullets
      for (let bIndex = bullets.length - 1; bIndex >= 0; bIndex--) {
        const bullet = bullets[bIndex];
        const dx = bullet.x - asteroid.x;
        const dy = bullet.y - asteroid.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < asteroid.size) {
          // Hit!
          createParticles(asteroid.x, asteroid.y, 10);
          bullets.splice(bIndex, 1);
          playSound('hit');
          
          // Award prize if asteroid has one
          if (asteroid.prizeWord) {
            if (asteroid.prizeWord === 'LASER') {
              if (!tripleCannon) {
                tripleCannon = true;
                cannonRange = 2;
                console.log('‚ö° LASER PRIZE! Triple Cannon with 2x Range!');
              } else if (!dualCannon) {
                dualCannon = true;
                console.log('‚ö° LASER PRIZE! Dual Cannon!');
              }
              playSound('powerup');
            } else if (asteroid.prizeWord === 'FORCE') {
              energyForcefield = true;
              largerForcefield = true;
              console.log('üõ°Ô∏è FORCE PRIZE! Larger Energy Forcefield!');
              playSound('powerup');
            } else if (asteroid.prizeWord === 'THRUST') {
              dualThruster = true;
              thrusterPower = Math.max(thrusterPower, 4);
              console.log('üöÄ THRUST PRIZE! Super Thrusters (4x Power)!');
              playSound('powerup');
            }
          }
          
          // Award points based on asteroid size
          if (asteroid.size >= 80) {
            score += 100; // Huge asteroid
          } else if (asteroid.size >= 40) {
            score += 50; // Large asteroid
          } else if (asteroid.size >= 20) {
            score += 25; // Medium asteroid
          } else {
            score += 10; // Small asteroid
          }
          
          const wasRed = asteroid.isRed;
          const fragmentId = asteroid.fragmentId;
          const wasBlue = asteroid.isBlue;
          const blueFragmentId = asteroid.blueFragmentId;
          
          // Split asteroid if large enough
          if (asteroid.size > 15) {
            asteroids.push(createAsteroid(asteroid.x, asteroid.y, asteroid.size / 2, null, wasRed, fragmentId, wasBlue, blueFragmentId));
            asteroids.push(createAsteroid(asteroid.x, asteroid.y, asteroid.size / 2, null, wasRed, fragmentId, wasBlue, blueFragmentId));
          } else if (wasRed && fragmentId) {
            // This was the last fragment of a red asteroid - check if all destroyed
            asteroids.splice(index, 1);
            
            // Check if any fragments of this red asteroid remain
            const remainingFragments = asteroids.filter(a => a.fragmentId === fragmentId);
            if (remainingFragments.length === 0) {
              // All fragments destroyed! Award dual thruster powerup
              dualThruster = true;
              thrusterPower = 2;
              redAsteroidFragments.delete(fragmentId);
              createParticles(asteroid.x, asteroid.y, 30); // Extra particles
              playSound('explosion');
              console.log('üî• RED ASTEROID DESTROYED! DUAL THRUSTER ACTIVATED!');
              score += 500; // Bonus points!
            }
            continue; // Don't process further
          } else if (wasBlue && blueFragmentId) {
            // This was the last fragment of a blue asteroid - check if all destroyed
            asteroids.splice(index, 1);
            
            // Check if any fragments of this blue asteroid remain
            const remainingFragments = asteroids.filter(a => a.blueFragmentId === blueFragmentId);
            if (remainingFragments.length === 0) {
              // All fragments destroyed! Award energy forcefield powerup
              energyForcefield = true;
              blueAsteroidFragments.delete(blueFragmentId);
              createParticles(asteroid.x, asteroid.y, 30); // Extra particles
              playSound('explosion');
              console.log('üõ°Ô∏è BLUE ASTEROID DESTROYED! ENERGY FORCEFIELD ACTIVATED!');
              score += 500; // Bonus points!
            }
            continue; // Don't process further
          }
          asteroids.splice(index, 1);
          break; // Exit bullet check loop since asteroid is destroyed
        }
      }
      
      // Skip expensive physics for asteroids far from screen or from each other
      // Only check collisions for nearby asteroids
      const maxPhysicsDistance = 300;
      for (let otherIndex = index + 1; otherIndex < asteroids.length; otherIndex++) {
        const otherAsteroid = asteroids[otherIndex];
        
        const dx = asteroid.x - otherAsteroid.x;
        const dy = asteroid.y - otherAsteroid.y;
        const distSq = dx * dx + dy * dy; // Use squared distance to avoid sqrt
        const minDist = asteroid.size + otherAsteroid.size;
        const minDistSq = minDist * minDist;
        
        // Skip if too far apart or beyond max physics distance
        if (distSq > minDistSq + (maxPhysicsDistance * maxPhysicsDistance)) continue;
        
        const dist = Math.sqrt(distSq);
        
        if (dist < minDist && dist > 0) {
          // Collision detected - apply simplified physics
          const mass1 = asteroid.size;
          const mass2 = otherAsteroid.size;
          
          // Normalize collision vector
          const nx = dx / dist;
          const ny = dy / dist;
          
          // Relative velocity
          const dvx = asteroid.velocity.x - otherAsteroid.velocity.x;
          const dvy = asteroid.velocity.y - otherAsteroid.velocity.y;
          
          // Relative velocity in collision normal direction
          const dvn = dvx * nx + dvy * ny;
          
          // Do not resolve if velocities are separating
          if (dvn > 0) continue;
          
          // Collision impulse (simplified - linear instead of cubic mass)
          const impulse = (2 * dvn) / (mass1 + mass2);
          
          // Apply impulse to velocities
          asteroid.velocity.x -= impulse * mass2 * nx;
          asteroid.velocity.y -= impulse * mass2 * ny;
          otherAsteroid.velocity.x += impulse * mass1 * nx;
          otherAsteroid.velocity.y += impulse * mass1 * ny;
          
          // Separate asteroids to prevent overlap (simplified)
          const overlap = minDist - dist;
          const massRatio1 = mass2 / (mass1 + mass2);
          const massRatio2 = mass1 / (mass1 + mass2);
          
          asteroid.x += nx * overlap * massRatio1;
          asteroid.y += ny * overlap * massRatio1;
          otherAsteroid.x -= nx * overlap * massRatio2;
          otherAsteroid.y -= ny * overlap * massRatio2;
        }
      }
    }
    
    // Maintain asteroid count: max 3 large (>40px) and 4 small (<=40px)
    const largeAsteroids = asteroids.filter(a => a.size > 40);
    const smallAsteroids = asteroids.filter(a => a.size <= 40);
    
    // Add small asteroids if needed (max 4)
    while (smallAsteroids.length < 4) {
      const edge = Math.floor(Math.random() * 4);
      let x, y;
      if (edge === 0) { x = Math.random() * canvas.width; y = -50; }
      else if (edge === 1) { x = canvas.width + 50; y = Math.random() * canvas.height; }
      else if (edge === 2) { x = Math.random() * canvas.width; y = canvas.height + 50; }
      else { x = -50; y = Math.random() * canvas.height; }
      const size = Math.random() * 20 + 15; // Small: 15-35px
      asteroids.push(createAsteroid(x, y, size));
      smallAsteroids.push(asteroids[asteroids.length - 1]);
    }
    
    // Remove excess large asteroids (keep max 3)
    while (largeAsteroids.length > 3) {
      const index = asteroids.indexOf(largeAsteroids[largeAsteroids.length - 1]);
      if (index > -1) {
        asteroids.splice(index, 1);
        largeAsteroids.pop();
      }
    }
  }
  
  // Update bullets
  function updateBullets() {
    for (let index = bullets.length - 1; index >= 0; index--) {
      const bullet = bullets[index];
      bullet.x += bullet.velocity.x;
      bullet.y += bullet.velocity.y;
      bullet.life--;
      
      // Remove dead bullets immediately
      if (bullet.life <= 0 || bullet.x < 0 || bullet.x > canvas.width || 
          bullet.y < 0 || bullet.y > canvas.height) {
        bullets.splice(index, 1);
        continue;
      }
      
      const currentGameMode = window.getGameMode && window.getGameMode();
      
      // Check collision with other players in VS or anyplayer mode
      if (currentGameMode === 'vs' || currentGameMode === 'anyplayer') {
        // Only check if this is our bullet
        if (bullet.owner === 'me') {
          if (currentGameMode === 'vs') {
            // VS mode - check collision with the other player
            const otherShip = window.getOtherPlayerShip ? window.getOtherPlayerShip() : null;
            if (otherShip && !otherShip.exploded) {
              const dx = bullet.x - otherShip.x;
              const dy = bullet.y - otherShip.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              
              if (dist < otherShip.size) {
                // Hit other player!
                bullets.splice(index, 1);
                createParticles(otherShip.x, otherShip.y, 15);
                playSound('explosion');
                
                // Broadcast hit
                if (window.broadcastPlayerHit) {
                  window.broadcastPlayerHit(window.getOtherPlayerId ? window.getOtherPlayerId() : null);
                }

                console.log('Hit other player!');
                continue;
              }
            }
          } else if (currentGameMode === 'anyplayer') {
            // Anyplayer mode - check collision with all other players
            const allPlayers = window.getAllPlayers ? window.getAllPlayers() : {};
            let hitPlayer = false;
            
            for (const [playerId, player] of Object.entries(allPlayers)) {
              if (player.exploded) continue;
              
              const dx = bullet.x - player.x;
              const dy = bullet.y - player.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              
              if (dist < player.size) {
                // Hit another player!
                bullets.splice(index, 1);
                createParticles(player.x, player.y, 15);
                playSound('explosion');
                
                // Increment kills for hitting player
                playerKills++;
                score += 1000;
                console.log(`üíÄ Hit player ${playerId}! Kills: ${playerKills}`);
                
                // Broadcast hit to that player
                if (window.broadcastPlayerHit) {
                  window.broadcastPlayerHit(playerId);
                }

                hitPlayer = true;
                break;
              }
            }
            if (hitPlayer) continue;
          }
        }
      }
      
      // Check collision with bombs in anyplayer mode
      if (currentGameMode === 'anyplayer') {
        const currentPlayerId = window.getMyPlayerId ? window.getMyPlayerId() : null;
        let hitBomb = false;
        for (let i = bombs.length - 1; i >= 0; i--) {
          const bomb = bombs[i];
          // Don't hit your own bombs with your own bullets
          if (bomb.owner === currentPlayerId && bullet.owner === 'me') continue;
          
          const dx = bullet.x - bomb.x;
          const dy = bullet.y - bomb.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < 10) {
            // Bullet hit bomb!
            bullets.splice(index, 1);
            
            // Explosion particles
            createBombExplosion(bomb.x, bomb.y);
            playSound('explosion');
            
            // Remove bomb
            if (bomb.owner === currentPlayerId) {
              bombCount--;
            }
            bombs.splice(i, 1);
            
            // Broadcast bomb destruction
            if (window.broadcastBombDestroyed && bullet.owner === 'me') {
              window.broadcastBombDestroyed(i);
            }
            
            score += 50; // Points for destroying bomb
            console.log('Destroyed bomb!');
            hitBomb = true;
            break;
          }
        }
        if (hitBomb) continue;
      }
    }
  }
  
  // Update particles
  function updateParticles() {
    for (let index = particles.length - 1; index >= 0; index--) {
      const particle = particles[index];
      
      // Handle delayed particles (for shockwave rings)
      if (particle.delay !== undefined) {
        particle.delay -= 16; // Subtract frame time
        if (particle.delay > 0) continue; // Don't update yet
      }
      
      particle.x += particle.velocity.x;
      particle.y += particle.velocity.y;
      particle.life -= 0.02;
      
      if (particle.life <= 0) {
        particles.splice(index, 1);
      }
    }
  }
  
  function updateBombs() {
    const now = Date.now();
    const currentPlayerId = window.getMyPlayerId ? window.getMyPlayerId() : null;
    
    for (let i = bombs.length - 1; i >= 0; i--) {
      const bomb = bombs[i];
      let bombDestroyed = false;
      
      // Auto-detonate after 10 seconds
      if (bomb.createdAt && now - bomb.createdAt >= 10000) {
        // Create explosion
        createBombExplosion(bomb.x, bomb.y);
        playSound('explosion');
        bombDestroyed = true;
        console.log('üí£ Bomb auto-detonated!');
      }
      
      // Check collision with asteroids
      if (!bombDestroyed) {
        for (let j = asteroids.length - 1; j >= 0; j--) {
          const asteroid = asteroids[j];
          const dx = bomb.x - asteroid.x;
          const dy = bomb.y - asteroid.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < asteroid.size + 10) {
            // Bomb hit asteroid - both explode!
            createBombExplosion(bomb.x, bomb.y);
            createParticles(asteroid.x, asteroid.y, 15);
            playSound('explosion');
            
            // Destroy asteroid (no splitting)
            asteroids.splice(j, 1);
            bombDestroyed = true;
            
            // Award points
            if (bomb.owner === currentPlayerId) {
              score += 100;
            }
            break;
          }
        }
      }
      
      // Check collision with UFOs
      if (!bombDestroyed) {
        for (let j = ufos.length - 1; j >= 0; j--) {
          const ufo = ufos[j];
          const dx = bomb.x - ufo.x;
          const dy = bomb.y - ufo.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < ufo.size + 10) {
            // Bomb hit UFO!
            createBombExplosion(bomb.x, bomb.y);
            createParticles(ufo.x, ufo.y, 20);
            playSound('explosion');
            
            ufos.splice(j, 1);
            bombDestroyed = true;
            
            if (bomb.owner === currentPlayerId) {
              score += 500;
            }
            break;
          }
        }
      }
      
      // Check collision with aliens
      if (!bombDestroyed) {
        for (let j = aliens.length - 1; j >= 0; j--) {
          const alien = aliens[j];
          const dx = bomb.x - alien.x;
          const dy = bomb.y - alien.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < alien.size + 10) {
            // Bomb hit alien!
            createBombExplosion(bomb.x, bomb.y);
            createParticles(alien.x, alien.y, 30);
            playSound('explosion');
            
            aliens.splice(j, 1);
            bombDestroyed = true;
            
            if (bomb.owner === currentPlayerId) {
              score += 1500;
            }
            break;
          }
        }
      }
      
      // Remove bomb if destroyed
      if (bombDestroyed) {
        // Decrement count if it's our bomb
        if (bomb.owner === currentPlayerId && bombCount > 0) {
          bombCount--;
        }
        
        bombs.splice(i, 1);
        
        // Broadcast destruction
        if (window.broadcastBombDestroyed) {
          window.broadcastBombDestroyed(i);
        }
      }
    }
  }
  
  // Draw functions
  function drawStars() {
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    for (let i = 0; i < stars.length; i++) {
      const star = stars[i];
      ctx.globalAlpha = star.opacity;
      ctx.fillRect(star.x, star.y, star.size, star.size);
    }
    ctx.globalAlpha = 1;
  }
  
  function drawShip() {
    if (ship.exploded) return; // Don't draw if exploded
    
    ctx.save();
    ctx.translate(ship.x, ship.y);
    ctx.rotate(ship.angle);
    
    // Check if this player is winning in anyplayer mode
    const gameMode = window.getGameMode ? window.getGameMode() : 'solo';
    const isWinning = gameMode === 'anyplayer' && isLeadingPlayer();
    
    // Draw victory flag if winning
    if (isWinning) {
      ctx.save();
      ctx.translate(-ship.size, -ship.size * 1.5);
      
      // Flag pole
      ctx.strokeStyle = 'rgba(255, 215, 0, 0.9)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(0, -20);
      ctx.stroke();
      
      // Animated flag
      const wave = Math.sin(Date.now() / 100) * 2;
      ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
      ctx.shadowColor = 'rgba(255, 215, 0, 0.8)';
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.moveTo(0, -20);
      ctx.lineTo(12 + wave, -17);
      ctx.lineTo(10 + wave, -13);
      ctx.lineTo(0, -10);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
      
      // Crown on flag
      ctx.fillStyle = 'rgba(255, 215, 0, 1)';
      ctx.font = 'bold 10px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('üëë', 6 + wave / 2, -13);
      
      ctx.restore();
    }
    
    // Draw energy forcefield if active
    if (energyForcefield) {
      const pulseIntensity = 0.5 + Math.sin(Date.now() / 200) * 0.3;
      const forcefieldSize = largerForcefield ? ship.size + 15 : ship.size + 8;
      const forcefieldColor = largerForcefield ? 'rgba(255, 100, 255, ' : 'rgba(100, 180, 255, ';
      
      ctx.strokeStyle = forcefieldColor + pulseIntensity + ')';
      ctx.lineWidth = largerForcefield ? 4 : 3;
      ctx.shadowColor = forcefieldColor + '0.8)';
      ctx.shadowBlur = largerForcefield ? 12 : 8;
      ctx.beginPath();
      ctx.arc(0, 0, forcefieldSize, 0, Math.PI * 2);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    
    // Ship body (triangle)
    ctx.strokeStyle = isWinning ? 'rgba(255, 215, 0, 0.8)' : 'rgba(126, 240, 163, 0.6)';
    ctx.fillStyle = isWinning ? 'rgba(255, 215, 0, 0.2)' : 'rgba(126, 240, 163, 0.1)';
    ctx.lineWidth = isWinning ? 3 : 2;
    if (isWinning) {
      ctx.shadowColor = 'rgba(255, 215, 0, 0.6)';
      ctx.shadowBlur = 8;
    }
    ctx.beginPath();
    ctx.moveTo(ship.size, 0);
    ctx.lineTo(-ship.size, -ship.size / 2);
    ctx.lineTo(-ship.size, ship.size / 2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    if (isWinning) {
      ctx.shadowBlur = 0;
    }
    
    // Thrust flames
    if (ship.thrust) {
      if (dualThruster) {
        // Dual thruster flames (larger and brighter)
        ctx.fillStyle = 'rgba(255, 200, 50, 0.8)';
        ctx.shadowColor = 'rgba(255, 200, 50, 0.6)';
        ctx.shadowBlur = 10;
        // Top flame
        ctx.beginPath();
        ctx.moveTo(-ship.size, -ship.size / 2.5);
        ctx.lineTo(-ship.size - 18, -ship.size / 4);
        ctx.lineTo(-ship.size, -ship.size / 6);
        ctx.closePath();
        ctx.fill();
        // Bottom flame
        ctx.beginPath();
        ctx.moveTo(-ship.size, ship.size / 2.5);
        ctx.lineTo(-ship.size - 18, ship.size / 4);
        ctx.lineTo(-ship.size, ship.size / 6);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
      } else {
        // Single thruster flame
        ctx.fillStyle = 'rgba(255, 107, 107, 0.6)';
        ctx.beginPath();
        ctx.moveTo(-ship.size, -ship.size / 3);
        ctx.lineTo(-ship.size - 10, 0);
        ctx.lineTo(-ship.size, ship.size / 3);
        ctx.closePath();
        ctx.fill();
      }
    }
    
    ctx.restore();
  }
  
  function drawAsteroids() {
    for (let i = 0; i < asteroids.length; i++) {
      const asteroid = asteroids[i];
      ctx.save();
      ctx.translate(asteroid.x, asteroid.y);
      ctx.rotate(asteroid.angle);
      
      // Special asteroids have different appearance
      if (asteroid.isRed) {
        ctx.strokeStyle = 'rgba(255, 107, 107, 0.8)';
        ctx.fillStyle = 'rgba(255, 107, 107, 0.2)';
        ctx.lineWidth = 3;
        ctx.shadowColor = 'rgba(255, 107, 107, 0.6)';
        ctx.shadowBlur = 8;
      } else if (asteroid.isBlue) {
        ctx.strokeStyle = 'rgba(100, 180, 255, 0.8)';
        ctx.fillStyle = 'rgba(100, 180, 255, 0.2)';
        ctx.lineWidth = 3;
        ctx.shadowColor = 'rgba(100, 180, 255, 0.6)';
        ctx.shadowBlur = 8;
      } else {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.lineWidth = 2;
        ctx.shadowBlur = 0;
      }
      
      ctx.beginPath();
      for (let j = 0; j < asteroid.points.length; j++) {
        const point = asteroid.points[j];
        const x = Math.cos(point.angle) * asteroid.size * point.radius;
        const y = Math.sin(point.angle) * asteroid.size * point.radius;
        if (j === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Draw prize word if present
      if (asteroid.prizeWord) {
        ctx.shadowBlur = 0;
        ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
        ctx.strokeStyle = 'rgba(50, 50, 50, 0.8)';
        ctx.lineWidth = 2;
        ctx.font = 'bold 12px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.strokeText(asteroid.prizeWord, 0, 0);
        ctx.fillText(asteroid.prizeWord, 0, 0);
      }
      
      ctx.restore();
    }
    
    ctx.shadowBlur = 0; // Reset shadow
  }
  
  function drawBullets() {
    ctx.fillStyle = 'rgba(126, 200, 255, 0.8)';
    for (let i = 0; i < bullets.length; i++) {
      const bullet = bullets[i];
      ctx.beginPath();
      ctx.arc(bullet.x, bullet.y, 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  function drawBombs() {
    const allPlayers = window.getAllPlayers ? window.getAllPlayers() : {};
    const currentPlayerId = window.getMyPlayerId ? window.getMyPlayerId() : null;
    
    bombs.forEach(bomb => {
      // Pulsing animation
      bomb.pulsePhase = (bomb.pulsePhase || 0) + 0.1;
      const pulse = Math.sin(bomb.pulsePhase) * 0.3 + 0.7;
      const size = 8 * pulse;
      
      // Outer glow
      ctx.shadowColor = 'rgba(255, 50, 50, 0.8)';
      ctx.shadowBlur = 15 * pulse;
      
      // Get owner color if available
      let bombColor = 'rgba(255, 50, 50, 0.9)';
      const getPlayerColor = window.getPlayerColor;
      if (bomb.owner && getPlayerColor) {
        const ownerColor = getPlayerColor(bomb.owner);
        if (ownerColor && ownerColor.primary) {
          bombColor = ownerColor.primary.replace('0.7)', '0.9)');
        }
      } else if (bomb.owner && allPlayers[bomb.owner]) {
        const playerColor = allPlayers[bomb.owner].color || 0;
        const playerColorsArray = window.getPlayerColors ? window.getPlayerColors() : [];
        if (playerColorsArray.length > 0) {
          const colors = playerColorsArray[playerColor % playerColorsArray.length];
          bombColor = colors.primary;
        }
      }
      
      // Draw bomb circle
      ctx.fillStyle = bombColor;
      ctx.beginPath();
      ctx.arc(bomb.x, bomb.y, size, 0, Math.PI * 2);
      ctx.fill();
      
      // Inner core
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      ctx.beginPath();
      ctx.arc(bomb.x, bomb.y, size * 0.4, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.shadowBlur = 0;
      
      // Draw countdown timer
      if (bomb.createdAt) {
        const elapsed = Date.now() - bomb.createdAt;
        const remaining = Math.max(0, 10 - Math.floor(elapsed / 1000));
        
        // Draw countdown with outline for visibility
        ctx.font = 'bold 20px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Black outline
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)';
        ctx.lineWidth = 4;
        ctx.strokeText(remaining.toString(), bomb.x, bomb.y);
        
        // White fill
        ctx.fillStyle = 'rgba(255, 255, 255, 1)';
        ctx.fillText(remaining.toString(), bomb.x, bomb.y);
      }
    });
  }
  
  function drawUfoBullets() {
    ctx.fillStyle = 'rgba(255, 107, 107, 0.8)';
    ctx.shadowColor = 'rgba(255, 107, 107, 0.5)';
    ctx.shadowBlur = 10;
    ufoBullets.forEach(bullet => {
      ctx.beginPath();
      ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.shadowBlur = 0;
  }
  
  function drawParticles() {
    for (let i = 0; i < particles.length; i++) {
      const particle = particles[i];
      ctx.fillStyle = `rgba(255, 255, 255, ${particle.life * 0.6})`;
      ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
    }
  }
  
  // Draw HUD (score and lives)
  function drawHUD() {
    ctx.save();
    ctx.shadowBlur = 0;
    
    // Score (top left) - or Kills in VS mode, or Kills/Deaths in anyplayer mode
    ctx.fillStyle = 'rgba(126, 240, 163, 0.9)';
    ctx.font = 'bold 24px system-ui';
    ctx.textAlign = 'left';
    const hudGameMode = window.getGameMode ? window.getGameMode() : 'solo';
    let hudDisplayText = '';
    if (hudGameMode === 'anyplayer') {
      const currentKills = window.getPlayerKills ? window.getPlayerKills() : 0;
      hudDisplayText = `Kills: ${currentKills}`;
    } else if (hudGameMode === 'vs') {
      hudDisplayText = `Kills: ${vsKills}`;
    } else {
      hudDisplayText = `Score: ${score}`;
    }
    ctx.fillText(hudDisplayText, 20, 40);
    
    // Game mode indicator
    if (window.isMultiplayerActive && window.isMultiplayerActive()) {
      const labelGameMode = window.getGameMode ? window.getGameMode() : 'coop';
      
      if (labelGameMode === 'coop') {
        ctx.fillStyle = 'rgba(100, 200, 255, 0.9)';
        ctx.font = 'bold 24px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('CO-OP', canvas.width / 2, 40);
      } else if (labelGameMode === 'vs') {
        ctx.fillStyle = 'rgba(255, 107, 107, 0.9)';
        ctx.font = 'bold 14px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('‚öîÔ∏è VS MODE', 20, 65);
      } else if (labelGameMode === 'anyplayer') {
        ctx.fillStyle = 'rgba(255, 165, 50, 0.9)';
        ctx.font = 'bold 14px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('‚öîÔ∏è BATTLE ROYALE', 20, 65);
        
        // Bomb count
        ctx.fillStyle = 'rgba(255, 100, 100, 0.9)';
        ctx.font = 'bold 16px system-ui';
        ctx.fillText(`üí£ Bombs: ${bombCount}/${MAX_BOMBS}`, 20, 87);
        
        // Q to Quit instruction
        ctx.fillStyle = 'rgba(200, 200, 200, 0.8)';
        ctx.font = 'bold 12px system-ui';
        ctx.fillText('Press Q to Quit', 20, 107);
      }
    }
    
    // Lives/Deaths (top right) - show deaths in anyplayer mode, lives otherwise
    ctx.textAlign = 'right';
    const hudGameModeRight = window.getGameMode ? window.getGameMode() : 'solo';
    if (hudGameModeRight === 'anyplayer') {
      const currentDeaths = window.getPlayerDeaths ? window.getPlayerDeaths() : 0;
      ctx.fillStyle = 'rgba(255, 107, 107, 0.9)';
      ctx.font = 'bold 24px system-ui';
      ctx.fillText(`Deaths: ${currentDeaths}/50`, canvas.width - 20, 40);
    } else {
      ctx.fillText('Lives:', canvas.width - 100, 40);
      // Draw life indicators only in non-anyplayer modes
      for (let i = 0; i < lives; i++) {
        const x = canvas.width - 70 + (i * 25);
        const y = 30;
        
        ctx.save();
        ctx.translate(x, y);
        ctx.strokeStyle = 'rgba(126, 240, 163, 0.8)';
        ctx.fillStyle = 'rgba(126, 240, 163, 0.3)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.lineTo(-8, -6);
        ctx.lineTo(-8, 6);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.restore();
      }
    }
    
    // Powerup indicators
    let powerupY = 70;
    if (tripleCannon) {
      ctx.fillStyle = 'rgba(255, 100, 255, 0.9)';
      ctx.font = 'bold 18px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText('‚ö° TRIPLE CANNON (2X RANGE)', 20, powerupY);
      powerupY += 30;
    } else if (dualCannon) {
      ctx.fillStyle = 'rgba(255, 200, 50, 0.9)';
      ctx.font = 'bold 18px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText('‚ö° DUAL CANNON', 20, powerupY);
      powerupY += 30;
    }
    if (dualThruster) {
      const powerText = thrusterPower === 4 ? '4X POWER' : '2X POWER';
      ctx.fillStyle = thrusterPower === 4 ? 'rgba(255, 50, 150, 0.9)' : 'rgba(255, 140, 50, 0.9)';
      ctx.font = 'bold 18px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText(`üî• SUPER THRUSTER (${powerText})`, 20, powerupY);
      powerupY += 30;
    }
    if (energyForcefield) {
      const forcefieldText = largerForcefield ? 'LARGER FORCEFIELD' : 'ENERGY FORCEFIELD';
      ctx.fillStyle = largerForcefield ? 'rgba(255, 100, 255, 0.9)' : 'rgba(100, 180, 255, 0.9)';
      ctx.font = 'bold 18px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText(`üõ°Ô∏è ${forcefieldText}`, 20, powerupY);
    }
    
    // Game Over message
    if (gameOver) {
      const currentGameMode = window.getGameMode ? window.getGameMode() : 'solo';
      
      ctx.fillStyle = 'rgba(255, 107, 107, 0.95)';
      ctx.font = 'bold 64px system-ui';
      ctx.textAlign = 'center';
      ctx.shadowColor = 'rgba(255, 107, 107, 0.8)';
      ctx.shadowBlur = 20;
      ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
      
      // Show appropriate message based on game mode
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.font = 'bold 24px system-ui';
      ctx.shadowBlur = 10;
      
      if (currentGameMode === 'anyplayer') {
        ctx.fillText(`Battle Royale - Kills: ${playerKills} | Deaths: ${playerDeaths}`, canvas.width / 2, canvas.height / 2 + 50);
      } else if (currentGameMode === 'vs') {
        ctx.fillText(`VS Mode - Final Kills: ${vsKills}`, canvas.width / 2, canvas.height / 2 + 50);
      } else if (currentGameMode === 'coop') {
        ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 50);
      } else {
        ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 50);
      }
      
      // Draw 'Play Again' button
      const btnX = canvas.width / 2;
      const btnY = canvas.height / 2 + 90;
      const btnWidth = 200;
      const btnHeight = 50;
      
      // Check if mouse is hovering
      const isHovering = window.playAgainHover || false;
      
      // Button background (red theme)
      ctx.fillStyle = isHovering ? 'rgba(255, 107, 107, 1)' : 'rgba(220, 80, 80, 0.9)';
      ctx.shadowBlur = isHovering ? 25 : 15;
      ctx.shadowColor = isHovering ? 'rgba(255, 107, 107, 0.9)' : 'rgba(220, 80, 80, 0.7)';
      ctx.fillRect(btnX - btnWidth / 2, btnY - btnHeight / 2, btnWidth, btnHeight);
      
      // Button border
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
      ctx.lineWidth = 3;
      ctx.strokeRect(btnX - btnWidth / 2, btnY - btnHeight / 2, btnWidth, btnHeight);
      
      // Button text
      ctx.fillStyle = 'rgba(255, 255, 255, 1)';
      ctx.font = 'bold 22px system-ui';
      ctx.textAlign = 'center';
      ctx.shadowBlur = 0;
      ctx.fillText('PLAY AGAIN', btnX, btnY + 8);
    }
    
    ctx.restore();
  }
  
  // Main game loop
  function gameLoop() {
    // Clear canvas - use clearRect for better performance
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (!gamePaused) {
      // Check game mode - adjust spawning based on mode
      const gameMode = window.getGameMode ? window.getGameMode() : 'solo';
      const isVsMode = gameMode === 'vs';
      const isAnyPlayerMode = gameMode === 'anyplayer';
      
      if (!isVsMode) {
        const now = Date.now();
        
        // Refresh bomb count every 20 seconds in anyplayer and vs modes
        if ((isAnyPlayerMode || isVsMode) && now - lastBombRefreshTime >= BOMB_REFRESH_INTERVAL) {
          bombCount = 0; // Reset bomb count
          lastBombRefreshTime = now;
          console.log('üí£ Bomb count refreshed! You have 5 bombs available.');
        }
        
        // Reduced spawning in anyplayer mode (battle royale focuses on PvP)
        const asteroidMultiplier = isAnyPlayerMode ? 2.5 : 1; // 2.5x slower in anyplayer
        const ufoMultiplier = isAnyPlayerMode ? 3 : 1; // 3x slower in anyplayer
        const alienMultiplier = isAnyPlayerMode ? 4 : 1; // 4x slower in anyplayer
        
        // Spawn huge asteroid periodically
        if (now - lastHugeAsteroidTime >= HUGE_ASTEROID_INTERVAL * asteroidMultiplier) {
          spawnHugeAsteroid();
          lastHugeAsteroidTime = now;
        }
        
        // Spawn UFO randomly
        if (now - lastUfoTime >= nextUfoInterval * ufoMultiplier) {
          spawnUfo();
          lastUfoTime = now;
          nextUfoInterval = 20000 + Math.random() * 15000; // New random interval for next UFO
        }
        
        // Spawn Alien rarely
        if (now - lastAlienTime >= nextAlienInterval * alienMultiplier) {
          spawnAlien();
          lastAlienTime = now;
          nextAlienInterval = 45000 + Math.random() * 30000; // 45-75 seconds
        }
      }
      
      // Update
      updateShipAI();
      updateAsteroids();
      updateAliens();
      updateUfos();
      updateUfoBullets();
      updateBullets();
      updateBombs();
      updateParticles();
      
      // Check for extra life milestone
      if (score >= nextExtraLifeAt) {
        lives++;
        nextExtraLifeAt += 1000; // Next life at +1000 points
        playSound('powerup');
        console.log('üéâ EXTRA LIFE! Total lives: ' + lives);
      }
    }
    
    // Draw (always draw even when paused)
    drawStars();
    drawAsteroids();
    drawAliens();
    drawUfos();
    drawUfoBullets();
    drawBombs();
    drawShip();
    drawBullets();
    drawParticles();
    drawHUD();
    
    // Draw multiplayer elements (other players)
    const isMultiplayerActive = window.isMultiplayerActive && window.isMultiplayerActive();
    if (isMultiplayerActive) {
      const gameMode = window.getGameMode ? window.getGameMode() : 'solo';
      if (gameMode === 'anyplayer') {
        // Draw all players in battle royale
        if (window.drawAllPlayers) {
          window.drawAllPlayers();
        }
      } else {
        // Draw single other player in 2-player modes
        if (window.drawOtherPlayerShip) {
          window.drawOtherPlayerShip();
        }
      }
    }
    
    requestAnimationFrame(gameLoop);
  }
  
  // Start the game
  gameLoop();
  
  // Expose pause state to global scope
  window.getGamePaused = () => gamePaused;
  window.setGamePaused = (paused) => { gamePaused = paused; };
  window.getSoundEnabled = () => soundEnabled;
  window.setSoundEnabled = (enabled) => { soundEnabled = enabled; };
  window.getGameOver = () => gameOver;
  window.getGameCanvas = () => canvas; // Expose canvas for Play Again button
  window.getLives = () => lives;
  window.getScore = () => score;
  window.getKills = () => vsKills;
  window.incrementKills = () => { vsKills++; };
  window.getPlayerKills = () => playerKills;
  window.setPlayerKills = (kills) => { playerKills = kills; };
  window.getPlayerDeaths = () => playerDeaths;
  window.setPlayerDeaths = (deaths) => { playerDeaths = deaths; };
  window.incrementPlayerKills = () => { playerKills++; };
  window.incrementPlayerDeaths = () => { playerDeaths++; };
  
  // Expose game objects for radar and multiplayer
  window.getShip = () => ship;
  window.getAsteroids = () => asteroids;
  window.getUfos = () => ufos;
  window.getAliens = () => aliens;
  window.getBullets = () => bullets;
  window.getUfoBullets = () => ufoBullets;
  window.getBombs = () => bombs;
  window.getBombCount = () => bombCount;
  window.setBombCount = (count) => { bombCount = count; };
  window.addBomb = (bomb) => { bombs.push(bomb); };
  window.clearBombs = () => { bombs.length = 0; };
  window.removeBomb = (index) => { bombs.splice(index, 1); };
})();

// ===== PAUSE AND SOUND CONTROLS =====
(function() {
  const pauseBtn = document.getElementById('pauseBtn');
  const soundBtn = document.getElementById('soundBtn');
  const pauseOverlay = document.getElementById('pauseOverlay');
  
  // Pause button click
  pauseBtn.addEventListener('click', function() {
    togglePause();
  });
  
  // Sound button click
  soundBtn.addEventListener('click', function() {
    toggleSound();
  });
  
  // Play Again button (on game over)
  window.playAgainHover = false;
  
  const gameCanvas = document.getElementById('asteroidCanvas');
  
  gameCanvas.addEventListener('mousemove', function(e) {
    const rect = gameCanvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    const gameOver = window.getGameOver ? window.getGameOver() : false;
    if (gameOver) {
      const btnX = gameCanvas.width / 2;
      const btnY = gameCanvas.height / 2 + 90;
      const btnWidth = 200;
      const btnHeight = 50;
      
      const isInBounds = mouseX >= btnX - btnWidth / 2 && mouseX <= btnX + btnWidth / 2 &&
                         mouseY >= btnY - btnHeight / 2 && mouseY <= btnY + btnHeight / 2;
      
      window.playAgainHover = isInBounds;
      gameCanvas.style.cursor = isInBounds ? 'pointer' : 'default';
    } else {
      gameCanvas.style.cursor = 'default';
    }
  });
  
  gameCanvas.addEventListener('click', function(e) {
    const rect = gameCanvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    const gameOver = window.getGameOver ? window.getGameOver() : false;
    console.log('Canvas clicked. GameOver:', gameOver, 'Mouse:', mouseX, mouseY);
    
    if (gameOver) {
      const btnX = gameCanvas.width / 2;
      const btnY = gameCanvas.height / 2 + 90;
      const btnWidth = 200;
      const btnHeight = 50;
      
      console.log('Button bounds:', {
        x: btnX - btnWidth / 2, 
        y: btnY - btnHeight / 2,
        width: btnWidth,
        height: btnHeight,
        mouseX: mouseX,
        mouseY: mouseY
      });
      
      const isInBounds = mouseX >= btnX - btnWidth / 2 && mouseX <= btnX + btnWidth / 2 &&
                         mouseY >= btnY - btnHeight / 2 && mouseY <= btnY + btnHeight / 2;
      
      console.log('Is in bounds:', isInBounds);
      
      if (isInBounds) {
        console.log('Play Again button clicked - reloading...');
        e.preventDefault();
        e.stopPropagation();
        window.location.reload(true);
      }
    }
  });
  
  // Alternative Play Again handler - listen for clicks anywhere when game over
  document.addEventListener('click', function(e) {
    const gameOver = window.getGameOver ? window.getGameOver() : false;
    if (!gameOver) return;
    
    // Get canvas position
    const canvas = document.getElementById('asteroidCanvas');
    const rect = canvas.getBoundingClientRect();
    
    // Check if click is within canvas bounds
    if (e.clientX < rect.left || e.clientX > rect.right || 
        e.clientY < rect.top || e.clientY > rect.bottom) {
      return; // Click outside canvas
    }
    
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    const btnX = canvas.width / 2;
    const btnY = canvas.height / 2 + 90;
    const btnWidth = 200;
    const btnHeight = 50;
    
    const isInBounds = mouseX >= btnX - btnWidth / 2 && mouseX <= btnX + btnWidth / 2 &&
                       mouseY >= btnY - btnHeight / 2 && mouseY <= btnY + btnHeight / 2;
    
    if (isInBounds) {
      console.log('Play Again clicked via document handler');
      e.preventDefault();
      e.stopPropagation();
      window.location.reload(true);
    }
  }, true); // Use capture phase to catch before other handlers
  
  // Keyboard pause toggle (P key when not in hyperspace mode)
  let lastPauseKeyTime = 0;
  const PAUSE_KEY_COOLDOWN = 300; // ms
  
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
      e.preventDefault();
      togglePause();
    }
    
    // Q key to quit Battle Royale back to lobby
    if ((e.key === 'q' || e.key === 'Q')) {
      const gameMode = window.getGameMode ? window.getGameMode() : 'solo';
      const gameOver = window.getGameOver ? window.getGameOver() : false;
      
      // Allow quitting only in Battle Royale mode
      if (gameMode === 'anyplayer') {
        e.preventDefault();
        
        // Reset game state and show lobby
        if (window.setGameOver) {
          window.setGameOver(true);
        }
        
        // Reload page to return to lobby
        window.location.reload(true);
      }
    }
  });
  
  function togglePause() {
    const currentPaused = window.getGamePaused();
    window.setGamePaused(!currentPaused);
    
    if (!currentPaused) {
      // Pausing
      pauseOverlay.classList.add('active');
      pauseBtn.classList.add('active');
      pauseBtn.textContent = '‚ñ∂';
      pauseBtn.title = 'Resume Game';
    } else {
      // Resuming
      pauseOverlay.classList.remove('active');
      pauseBtn.classList.remove('active');
      pauseBtn.textContent = '‚è∏';
      pauseBtn.title = 'Pause Game';
    }
  }
  
  function toggleSound() {
    const currentSound = window.getSoundEnabled();
    window.setSoundEnabled(!currentSound);
    
    if (!currentSound) {
      // Enabling sound
      soundBtn.classList.remove('muted');
      soundBtn.textContent = 'üîä';
      soundBtn.title = 'Mute Sound Effects';
    } else {
      // Muting sound
      soundBtn.classList.add('muted');
      soundBtn.textContent = 'üîá';
      soundBtn.title = 'Enable Sound Effects';
    }
  }
  
  // P key for pause only (H is hyperspace)
  document.addEventListener('keyup', function(e) {
    const now = Date.now();
    if ((e.key === 'p' || e.key === 'P') && now - lastPauseKeyTime > PAUSE_KEY_COOLDOWN) {
      lastPauseKeyTime = now;
      togglePause();
    }
  });
})();

// ===== RADAR SYSTEM =====
(function() {
  const radarCanvas = document.getElementById('radarCanvas');
  const radarCtx = radarCanvas.getContext('2d');
  const radarRadius = 100; // pixels
  const radarRange = 400; // game units
  let radarSweepAngle = 0;
  
  function drawRadar() {
    const centerX = radarCanvas.width / 2;
    const centerY = radarCanvas.height / 2;
    
    // Clear radar
    radarCtx.fillStyle = 'rgba(8, 16, 26, 0.3)';
    radarCtx.fillRect(0, 0, radarCanvas.width, radarCanvas.height);
    
    // Draw radar grid circles
    radarCtx.strokeStyle = 'rgba(126, 200, 255, 0.2)';
    radarCtx.lineWidth = 1;
    for (let i = 1; i <= 3; i++) {
      radarCtx.beginPath();
      radarCtx.arc(centerX, centerY, (radarRadius * i) / 3, 0, Math.PI * 2);
      radarCtx.stroke();
    }
    
    // Draw crosshairs
    radarCtx.beginPath();
    radarCtx.moveTo(centerX, 0);
    radarCtx.lineTo(centerX, radarCanvas.height);
    radarCtx.moveTo(0, centerY);
    radarCtx.lineTo(radarCanvas.width, centerY);
    radarCtx.stroke();
    
    // Draw radar sweep
    radarCtx.save();
    radarCtx.translate(centerX, centerY);
    radarCtx.rotate(radarSweepAngle);
    
    const gradient = radarCtx.createLinearGradient(0, 0, radarRadius, 0);
    gradient.addColorStop(0, 'rgba(126, 240, 163, 0.6)');
    gradient.addColorStop(1, 'rgba(126, 240, 163, 0)');
    
    radarCtx.fillStyle = gradient;
    radarCtx.beginPath();
    radarCtx.moveTo(0, 0);
    radarCtx.arc(0, 0, radarRadius, 0, Math.PI / 6);
    radarCtx.closePath();
    radarCtx.fill();
    
    radarCtx.restore();
    radarSweepAngle += 0.05;
    
    // Get game objects from exposed functions
    const ship = window.getShip ? window.getShip() : null;
    const asteroids = window.getAsteroids ? window.getAsteroids() : [];
    const ufos = window.getUfos ? window.getUfos() : [];
    const aliens = window.getAliens ? window.getAliens() : [];
    
    if (!ship) {
      requestAnimationFrame(drawRadar);
      return;
    }
    
    // Draw ship at center (player) - only if not exploded
    if (!ship.exploded) {
      radarCtx.fillStyle = 'rgba(126, 240, 163, 0.9)';
      radarCtx.beginPath();
      radarCtx.arc(centerX, centerY, 3, 0, Math.PI * 2);
      radarCtx.fill();
    }
    
    // Draw red asteroids (prize asteroids)
    asteroids.forEach(asteroid => {
      if (!asteroid.isRed) return;
        
      const dx = asteroid.x - ship.x;
      const dy = asteroid.y - ship.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > radarRange) return;
      
      const radarX = centerX + (dx / radarRange) * radarRadius;
      const radarY = centerY + (dy / radarRange) * radarRadius;
      
      // Pulsing red dot for prize asteroids
      const pulse = 0.6 + Math.sin(Date.now() / 200) * 0.4;
      radarCtx.fillStyle = `rgba(255, 107, 107, ${pulse})`;
      radarCtx.shadowColor = 'rgba(255, 107, 107, 0.8)';
      radarCtx.shadowBlur = 8;
      radarCtx.beginPath();
      radarCtx.arc(radarX, radarY, 4, 0, Math.PI * 2);
      radarCtx.fill();
      radarCtx.shadowBlur = 0;
    });
    
    // Draw blue asteroids (forcefield powerup)
    asteroids.forEach(asteroid => {
      if (!asteroid.isBlue) return;
      
      const dx = asteroid.x - ship.x;
      const dy = asteroid.y - ship.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > radarRange) return;
      
      const radarX = centerX + (dx / radarRange) * radarRadius;
      const radarY = centerY + (dy / radarRange) * radarRadius;
      
      // Pulsing blue dot for forcefield asteroids
      const pulse = 0.6 + Math.sin(Date.now() / 200 + 1) * 0.4;
      radarCtx.fillStyle = `rgba(100, 180, 255, ${pulse})`;
      radarCtx.shadowColor = 'rgba(100, 180, 255, 0.8)';
      radarCtx.shadowBlur = 8;
      radarCtx.beginPath();
      radarCtx.arc(radarX, radarY, 4, 0, Math.PI * 2);
      radarCtx.fill();
      radarCtx.shadowBlur = 0;
    });
    
    // Draw UFOs (incoming craft)
    ufos.forEach(ufo => {
      const dx = ufo.x - ship.x;
      const dy = ufo.y - ship.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > radarRange) return;
      
      const radarX = centerX + (dx / radarRange) * radarRadius;
      const radarY = centerY + (dy / radarRange) * radarRadius;
      
      // Blinking yellow triangle for UFOs
      const blink = Math.sin(Date.now() / 300) > 0;
      if (blink) {
        radarCtx.fillStyle = 'rgba(255, 200, 50, 0.9)';
        radarCtx.shadowColor = 'rgba(255, 200, 50, 0.8)';
        radarCtx.shadowBlur = 10;
        radarCtx.beginPath();
        radarCtx.moveTo(radarX, radarY - 5);
        radarCtx.lineTo(radarX - 4, radarY + 3);
        radarCtx.lineTo(radarX + 4, radarY + 3);
        radarCtx.closePath();
        radarCtx.fill();
        radarCtx.shadowBlur = 0;
      }
    });
    
    // Draw Aliens (rare powerful targets)
    aliens.forEach(alien => {
      const dx = alien.x - ship.x;
      const dy = alien.y - ship.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > radarRange) return;
      
      const radarX = centerX + (dx / radarRange) * radarRadius;
      const radarY = centerY + (dy / radarRange) * radarRadius;
      
      // Pulsing purple/magenta star for aliens
      const alienPulse = 0.7 + Math.sin(Date.now() / 150) * 0.3;
      radarCtx.fillStyle = `rgba(255, 100, 255, ${alienPulse})`;
      radarCtx.shadowColor = 'rgba(255, 100, 255, 0.9)';
      radarCtx.shadowBlur = 12;
      
      // Draw star shape
      radarCtx.beginPath();
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const r = i % 2 === 0 ? 6 : 3;
        const x = radarX + Math.cos(angle) * r;
        const y = radarY + Math.sin(angle) * r;
        if (i === 0) radarCtx.moveTo(x, y);
        else radarCtx.lineTo(x, y);
      }
      radarCtx.closePath();
      radarCtx.fill();
      radarCtx.shadowBlur = 0;
    });
    
    // Draw large asteroids (threats)
    asteroids.forEach(asteroid => {
      if (asteroid.isRed || asteroid.isBlue || asteroid.size < 60) return; // Skip special and small asteroids
        
        const dx = asteroid.x - ship.x;
        const dy = asteroid.y - ship.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist > radarRange) return;
        
        const radarX = centerX + (dx / radarRange) * radarRadius;
        const radarY = centerY + (dy / radarRange) * radarRadius;
        
        // Orange dot for large threatening asteroids
        radarCtx.fillStyle = 'rgba(255, 160, 80, 0.7)';
        radarCtx.beginPath();
        radarCtx.arc(radarX, radarY, 3, 0, Math.PI * 2);
        radarCtx.fill();
    });
    
    // Draw other players in multiplayer modes
    const gameMode = window.getGameMode ? window.getGameMode() : 'solo';
    const isMultiplayer = window.isMultiplayerActive ? window.isMultiplayerActive() : false;
    
    if (isMultiplayer) {
      if (gameMode === 'anyplayer') {
        // Draw all players in anyplayer mode with their unique colors
        const allPlayers = window.getAllPlayers ? window.getAllPlayers() : {};
        const getPlayerColor = window.getPlayerColor;
        
        Object.entries(allPlayers).forEach(([playerId, player]) => {
          if (player.exploded) return;
          
          const dx = player.x - ship.x;
          const dy = player.y - ship.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist > radarRange) return;
          
          const radarX = centerX + (dx / radarRange) * radarRadius;
          const radarY = centerY + (dy / radarRange) * radarRadius;
          
          // Get player's unique color
          const color = getPlayerColor ? getPlayerColor(playerId) : { primary: 'rgba(255, 107, 107, 0.7)' };
          const colorStr = color.primary.replace('0.7)', '0.9)');
          
          // Draw triangle for other players
          radarCtx.fillStyle = colorStr;
          radarCtx.strokeStyle = colorStr;
          radarCtx.lineWidth = 1.5;
          radarCtx.shadowColor = colorStr;
          radarCtx.shadowBlur = 6;
          radarCtx.beginPath();
          radarCtx.moveTo(radarX, radarY - 4);
          radarCtx.lineTo(radarX - 3.5, radarY + 3);
          radarCtx.lineTo(radarX + 3.5, radarY + 3);
          radarCtx.closePath();
          radarCtx.fill();
          radarCtx.stroke();
          radarCtx.shadowBlur = 0;
        });
      } else {
        // Draw single other player in 2-player modes
        const otherShip = window.getOtherPlayerShip ? window.getOtherPlayerShip() : null;
        
        if (otherShip && !otherShip.exploded) {
          const dx = otherShip.x - ship.x;
          const dy = otherShip.y - ship.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist <= radarRange) {
            const radarX = centerX + (dx / radarRange) * radarRadius;
            const radarY = centerY + (dy / radarRange) * radarRadius;
            
            // Color based on mode (red for VS, yellow for coop)
            const playerColor = gameMode === 'vs' ? 'rgba(255, 107, 107, 0.9)' : 'rgba(255, 200, 100, 0.9)';
            
            radarCtx.fillStyle = playerColor;
            radarCtx.strokeStyle = playerColor;
            radarCtx.lineWidth = 1.5;
            radarCtx.shadowColor = playerColor;
            radarCtx.shadowBlur = 6;
            radarCtx.beginPath();
            radarCtx.moveTo(radarX, radarY - 4);
            radarCtx.lineTo(radarX - 3.5, radarY + 3);
            radarCtx.lineTo(radarX + 3.5, radarY + 3);
            radarCtx.closePath();
            radarCtx.fill();
            radarCtx.stroke();
            radarCtx.shadowBlur = 0;
          }
        }
      }
    }
    
    requestAnimationFrame(drawRadar);
  }
  
  // Start radar
  drawRadar();
})();

// ===== SCREEN SAVER SYSTEM =====
(function() {
  const IDLE_TIME_MS = 300000; // 5 minutes
  const overlay = document.getElementById('screenSaverOverlay');
  const particlesContainer = document.getElementById('screensaverParticles');
  const statusEl = document.getElementById('screensaverStatus');
  
  let idleTimer = null;
  let isScreenSaverActive = false;
  let lastActivityTime = Date.now();
  
  // Create floating particles for screen saver
  function createParticles() {
    particlesContainer.innerHTML = '';
    for (let i = 0; i < 30; i++) {
      const particle = document.createElement('div');
      particle.className = 'screensaver-particle';
      
      const x = Math.random() * 100;
      const y = Math.random() * 100;
      const duration = 8 + Math.random() * 12;
      const delay = Math.random() * 5;
      const size = 1 + Math.random() * 3;
      
      particle.style.left = x + '%';
      particle.style.top = y + '%';
      particle.style.width = size + 'px';
      particle.style.height = size + 'px';
      particle.style.animation = `float ${duration}s linear ${delay}s infinite`;
      
      particlesContainer.appendChild(particle);
    }
  }
  
  // Update screen saver status with live data
  function updateScreenSaverStatus() {
    const magEl = document.getElementById('currentMag');
    const distEl = document.getElementById('distanceValue');
    
    if (magEl && distEl) {
      const mag = magEl.textContent;
      const dist = distEl.textContent;
      statusEl.textContent = `Magnitude: ${mag} | Distance: ${dist} km`;
    }
  }
  
  // Activate screen saver
  function activateScreenSaver() {
    if (isScreenSaverActive) return;
    
    isScreenSaverActive = true;
    overlay.classList.add('active');
    createParticles();
    updateScreenSaverStatus();
    
    // Update status every 10 seconds
    const statusInterval = setInterval(() => {
      if (isScreenSaverActive) {
        updateScreenSaverStatus();
      } else {
        clearInterval(statusInterval);
      }
    }, 10000);
    
    console.log('Screen saver activated');
  }
  
  // Deactivate screen saver
  function deactivateScreenSaver() {
    if (!isScreenSaverActive) return;
    
    isScreenSaverActive = false;
    overlay.classList.remove('active');
    particlesContainer.innerHTML = '';
    
    console.log('Screen saver deactivated');
  }
  
  // Reset idle timer
  function resetIdleTimer() {
    lastActivityTime = Date.now();
    
    if (isScreenSaverActive) {
      deactivateScreenSaver();
    }
    
    clearTimeout(idleTimer);
    idleTimer = setTimeout(() => {
      activateScreenSaver();
    }, IDLE_TIME_MS);
  }
  
  // Activity listeners
  const activityEvents = ['mousedown', 'mousemove', 'keydown', 'touchstart', 'click', 'scroll'];
  
  activityEvents.forEach(event => {
    document.addEventListener(event, resetIdleTimer, true);
  });
  
  // Initialize timer on page load
  resetIdleTimer();
  
  // Expose screen saver control to window for manual toggling
  window.screenSaver = {
    activate: activateScreenSaver,
    deactivate: deactivateScreenSaver,
    toggle: () => {
      if (isScreenSaverActive) {
        deactivateScreenSaver();
      } else {
        activateScreenSaver();
      }
    },
    isActive: () => isScreenSaverActive,
    setIdleTime: (ms) => {
      IDLE_TIME_MS = ms;
      resetIdleTimer();
    }
  };
  
  console.log('Screen saver system initialized. Idle timeout: ' + (IDLE_TIME_MS / 1000 / 60) + ' minutes');
})();

// ===== MULTIPLAYER SYSTEM (CO-OP, VS, ANY PLAYER) =====
(function() {
  let ws = null;
  let myPlayerId = null;
  let otherPlayerId = null;
  let isMultiplayer = false;
  let isHost = false;
  let gameMode = 'solo'; // 'solo', 'coop', 'vs', 'anyplayer'
  let allPlayers = {}; // For anyplayer mode: { playerId: shipState }
  let otherPlayerShip = null;
  let otherPlayerTargetState = null; // Target state for interpolation
  let lastUpdateTime = Date.now();
  
  // Color palette for different players (bright, distinct colors)
  const playerColors = [
    { name: 'Red', primary: 'rgba(255, 107, 107, 0.7)', fill: 'rgba(255, 107, 107, 0.15)' },
    { name: 'Cyan', primary: 'rgba(100, 200, 255, 0.7)', fill: 'rgba(100, 200, 255, 0.15)' },
    { name: 'Green', primary: 'rgba(126, 240, 163, 0.7)', fill: 'rgba(126, 240, 163, 0.15)' },
    { name: 'Orange', primary: 'rgba(255, 165, 50, 0.7)', fill: 'rgba(255, 165, 50, 0.15)' },
    { name: 'Purple', primary: 'rgba(200, 100, 255, 0.7)', fill: 'rgba(200, 100, 255, 0.15)' },
    { name: 'Yellow', primary: 'rgba(255, 240, 100, 0.7)', fill: 'rgba(255, 240, 100, 0.15)' },
    { name: 'Pink', primary: 'rgba(255, 150, 200, 0.7)', fill: 'rgba(255, 150, 200, 0.15)' },
    { name: 'Teal', primary: 'rgba(80, 220, 200, 0.7)', fill: 'rgba(80, 220, 200, 0.15)' }
  ];
  
  // Cache for assigned colors to ensure consistency
  const playerColorMap = {};
  
  // Assign colors to players - consistently across all game modes
  function getPlayerColor(playerId) {
    // If already assigned, return it
    if (playerColorMap[playerId]) {
      return playerColorMap[playerId];
    }
    
    // For anyplayer mode, assign based on sorted player list
    if (gameMode === 'anyplayer') {
      const playerIds = Object.keys(allPlayers).sort();
      const index = playerIds.indexOf(playerId);
      const color = playerColors[index % playerColors.length];
      playerColorMap[playerId] = color;
      return color;
    }
    
    // For 2-player modes (coop, vs), use a different approach
    // Local player gets green, other player gets their mode-appropriate color
    if (playerId === myPlayerId) {
      // Local player - always green
      const color = { name: 'Green', primary: 'rgba(126, 240, 163, 0.7)', fill: 'rgba(126, 240, 163, 0.15)' };
      playerColorMap[playerId] = color;
      return color;
    } else if (playerId === otherPlayerId || gameMode !== 'anyplayer') {
      // Other player in 2-player mode
      const color = gameMode === 'vs' 
        ? { name: 'Red', primary: 'rgba(255, 107, 107, 0.7)', fill: 'rgba(255, 107, 107, 0.15)' }
        : { name: 'Orange', primary: 'rgba(255, 165, 50, 0.7)', fill: 'rgba(255, 165, 50, 0.15)' };
      playerColorMap[playerId] = color;
      return color;
    }
    
    // Fallback
    const index = Object.keys(playerColorMap).length % playerColors.length;
    const color = playerColors[index];
    playerColorMap[playerId] = color;
    return color;
  }
  
  const lobbyOverlay = document.getElementById('lobbyOverlay');
  const lobbyStatus = document.getElementById('lobbyStatus');
  const soloPlayBtn = document.getElementById('soloPlayBtn');
  const coopPlayBtn = document.getElementById('coopPlayBtn');
  const anyPlayerBtn = document.getElementById('anyPlayerBtn');
  const joinRequestOverlay = document.getElementById('joinRequestOverlay');
  const acceptJoinBtn = document.getElementById('acceptJoinBtn');
  const declineJoinBtn = document.getElementById('declineJoinBtn');
  
  let pendingJoinRequest = null;
  
  // Connect to WebSocket server
  function connectWebSocket() {
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const host = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
      ? 'localhost:3000' 
      : window.location.host;
    
    ws = new WebSocket(`${protocol}//${host}`);
    
    ws.onopen = () => {
      console.log('WebSocket connected');
      lobbyStatus.textContent = 'Connected to multiplayer server';
    };
    
    ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      handleWebSocketMessage(data);
    };
    
    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
      console.error('WebSocket error details:', error.message || error);
      lobbyStatus.textContent = 'Connection error - Playing solo';
    };
    
    ws.onclose = () => {
      console.log('WebSocket disconnected');
      console.log(`WebSocket close code: ${ws.code}, reason: ${ws.reason}`);
      if (isMultiplayer) {
        // Show notification that other player left
        console.log('Multiplayer session ended');
        isMultiplayer = false;
        otherPlayerShip = null;
      }
    };
  }
  
  function handleWebSocketMessage(data) {
    switch(data.type) {
      case 'connected':
        myPlayerId = data.playerId;
        isHost = data.isFirstPlayer;
        console.log(`Connected as ${myPlayerId} (${isHost ? 'Host' : 'Guest'})`);
        console.log(`Other players available: ${data.otherPlayers ? data.otherPlayers.length : 0}`);
        
        if (data.otherPlayers && data.otherPlayers.length > 0) {
          lobbyStatus.textContent = 'Another player is online!';
          coopPlayBtn.disabled = false;
          vsPlayBtn.disabled = false;
          otherPlayerId = data.otherPlayers[0];
        } else {
          lobbyStatus.textContent = 'Waiting for other players...';
          coopPlayBtn.disabled = true;
          vsPlayBtn.disabled = true;
        }
        break;
        
      case 'player_available':
        if (!isMultiplayer) {
          otherPlayerId = data.playerId;
          lobbyStatus.textContent = 'Another player is online!';
          coopPlayBtn.disabled = false;
          vsPlayBtn.disabled = false;
        }
        break;
        
      case 'join_request':
        // Another player wants to join our game
        if (!isMultiplayer) {
          pendingJoinRequest = data.playerId;
          const mode = data.mode || 'coop';
          console.log(`Received join_request from ${data.playerId} with mode: ${mode}`);
          const joinRequestMessage = document.getElementById('joinRequestMessage');
          const joinRequestMode = document.getElementById('joinRequestMode');
          
          if (mode === 'vs') {
            joinRequestMessage.textContent = 'Another player wants to battle you!';
            joinRequestMode.textContent = '‚öîÔ∏è VS MODE (PvP)';
            joinRequestMode.style.color = '#ff6b6b';
          } else {
            joinRequestMessage.textContent = 'Another player wants to join your game!';
            joinRequestMode.textContent = 'ü§ù CO-OP MODE';
            joinRequestMode.style.color = '#7ef0a3';
          }
          
          pendingJoinRequestMode = mode;
          console.log(`Set pendingJoinRequestMode to: ${pendingJoinRequestMode}`);
          joinRequestOverlay.classList.add('active');
        }
        break;
        
      case 'join_response':
        console.log(`Received join_response: accepted=${data.accepted}, mode=${data.mode}`);
        if (data.accepted) {
          console.log(`Calling startMultiplayerGame with mode: ${data.mode || 'coop'}`);
          startMultiplayerGame(data.playerId, data.mode || 'coop');
          // Store the other player's ID with their mode to ensure proper routing
          otherPlayerId = data.playerId;
        } else {
          alert('Join request declined');
          lobbyOverlay.classList.add('active');
          coopPlayBtn.disabled = false;
          vsPlayBtn.disabled = false;
          soloPlayBtn.disabled = false;
        }
        break;
        
      case 'player_state':
        // Update other player's ship with interpolation
        if (data.playerId !== myPlayerId && isMultiplayer) {
          console.log(`Received player_state from ${data.playerId}: x=${data.state.x.toFixed(0)}, y=${data.state.y.toFixed(0)}, gameMode=${gameMode}`);
          if (gameMode === 'anyplayer') {
            // In anyplayer mode, track all players
            if (!allPlayers[data.playerId]) {
              allPlayers[data.playerId] = {
                x: data.state.x,
                y: data.state.y,
                angle: data.state.angle,
                velocity: data.state.velocity,
                exploded: data.state.exploded,
                size: 15,
                thrust: data.state.thrust || false,
                lives: data.state.lives || 3,
                score: data.state.score || 0,
                kills: data.state.kills || 0,
                deaths: data.state.deaths || 0
              };
              console.log(`  Created new player entry in anyplayer mode: ${data.playerId}`);
            } else {
              // Update existing player
              Object.assign(allPlayers[data.playerId], data.state);
            }
          } else {
            // Regular 2-player mode
            console.log(`  Updating 2-player mode: otherPlayerId=${otherPlayerId}, incomingPlayerId=${data.playerId}`);
            if (!otherPlayerShip) {
              otherPlayerShip = {
                x: data.state.x,
                y: data.state.y,
                angle: data.state.angle,
                velocity: data.state.velocity,
                exploded: data.state.exploded,
                size: 15,
                thrust: data.state.thrust || false
              };
              otherPlayerTargetState = { ...data.state };
              console.log(`  Created otherPlayerShip at (${data.state.x.toFixed(0)}, ${data.state.y.toFixed(0)})`);
            } else {
              // Set target state for smooth interpolation
              otherPlayerTargetState = { ...data.state };
              lastUpdateTime = Date.now();
              console.log(`  Updated otherPlayerShip target to (${data.state.x.toFixed(0)}, ${data.state.y.toFixed(0)})`);
            }
          }
        } else {
          if (data.playerId === myPlayerId) {
            console.log(`  Ignoring player_state from self (${myPlayerId})`);
          } else if (!isMultiplayer) {
            console.log(`  Ignoring player_state because isMultiplayer=${isMultiplayer}`);
          }
        }
        break;
        
      case 'game_state':
        // Sync game state from host (if we're not host)
        if (!isHost && isMultiplayer) {
          // Update asteroids, bullets, etc. from host
          const gameAsteroids = window.getAsteroids();
          const gameBullets = window.getBullets ? window.getBullets() : [];
          
          if (gameAsteroids && data.gameState.asteroids) {
            gameAsteroids.length = 0;
            gameAsteroids.push(...data.gameState.asteroids);
          }
        }
        break;
        
      case 'bullet_fired':
        // Another player fired a bullet
        if (data.playerId !== myPlayerId && isMultiplayer) {
          const gameBullets = window.getBullets ? window.getBullets() : [];
          if (gameBullets && data.bullet) {
            // Mark bullet as from other player for VS mode collision detection
            data.bullet.owner = 'other';
            gameBullets.push(data.bullet);
            playSound('shoot'); // Play sound for other player's shots
          }
        }
        break;
        
      case 'powerup_sync':
        // Sync powerups in co-op mode
        if (gameMode === 'coop' && data.playerId !== myPlayerId) {
          if (window.syncPowerups) {
            window.syncPowerups(data.powerups);
          }
        }
        break;
        
      case 'player_hit':
        // In VS or anyplayer mode, other player hit us
        if ((gameMode === 'vs' || gameMode === 'anyplayer') && data.targetId === myPlayerId) {
          if (window.handlePlayerHit) {
            window.handlePlayerHit();
          }
        }
        break;

      case 'player_killed':
        // Other player was killed by us
        if (gameMode === 'vs') {
          vsKills++;
          console.log(`üíÄ Got a kill! Total kills: ${vsKills}`);
        }
        break;
        
      case 'bomb_dropped':
        // Another player dropped a bomb
        if ((gameMode === 'anyplayer' || gameMode === 'vs') && data.bomb && window.addBomb) {
          // Ensure bomb has all required properties
          const bomb = {
            x: data.bomb.x,
            y: data.bomb.y,
            owner: data.bomb.owner,
            life: data.bomb.life || Infinity,
            pulsePhase: data.bomb.pulsePhase || 0,
            createdAt: data.bomb.createdAt || Date.now()
          };
          window.addBomb(bomb);
          const bombsArray = window.getBombs ? window.getBombs() : [];
          console.log(`üí£ Received bomb from ${bomb.owner} at (${Math.round(bomb.x)}, ${Math.round(bomb.y)}). Total bombs: ${bombsArray.length}`);
        } else {
          console.log('‚ö†Ô∏è Bomb received but not added:', { gameMode, hasBomb: !!data.bomb, hasAddBomb: !!window.addBomb });
        }
        break;
        
      case 'bomb_destroyed':
        // A bomb was destroyed
        if ((gameMode === 'anyplayer' || gameMode === 'vs') && data.bombIndex !== undefined && window.getBombs && window.removeBomb) {
          const bombs = window.getBombs();
          const currentPlayerId = window.getMyPlayerId ? window.getMyPlayerId() : null;
          if (data.bombIndex < bombs.length) {
            const bomb = bombs[data.bombIndex];
            if (bomb && bomb.owner === currentPlayerId && window.getBombCount && window.setBombCount) {
              window.setBombCount(window.getBombCount() - 1);
            }
            window.removeBomb(data.bombIndex);
          }
        }
        break;
        
      case 'bomb_kill':
        // Someone hit a bomb and died
        if (gameMode === 'anyplayer' || gameMode === 'vs') {
          const currentPlayerId = window.getMyPlayerId ? window.getMyPlayerId() : null;
          if (data.bomber === currentPlayerId) {
            // Our bomb got a kill!
            score += 2000;
            if (gameMode === 'anyplayer') {
              playerKills++;
            }
            console.log(`üí£ Your bomb eliminated player ${data.victim}! +2000`);
          }
        }
        break;
        
      case 'player_disconnected':
        if (gameMode === 'anyplayer') {
          // Remove from all players list
          delete allPlayers[data.playerId];
          
          // Remove their bombs
          if (window.getBombs && window.removeBomb) {
            const bombs = window.getBombs();
            for (let i = bombs.length - 1; i >= 0; i--) {
              if (bombs[i].owner === data.playerId) {
                window.removeBomb(i);
              }
            }
          }
          
          console.log('Player disconnected from battle royale:', data.playerId);
        } else if (data.playerId === otherPlayerId) {
          console.log('Other player disconnected');
          isMultiplayer = false;
          otherPlayerShip = null;
          otherPlayerId = null;
        }
        break;
        
      case 'anyplayer_players':
        // Receive list of all players in anyplayer mode
        if (gameMode === 'anyplayer') {
          console.log('Received player list:', data.players);
          // Initialize all other players
          data.players.forEach(playerId => {
            if (playerId !== myPlayerId && !allPlayers[playerId]) {
              const gameCanvas = document.getElementById('asteroidCanvas');
              allPlayers[playerId] = {
                x: Math.random() * (gameCanvas ? gameCanvas.width : 800),
                y: Math.random() * (gameCanvas ? gameCanvas.height : 600),
                angle: Math.random() * Math.PI * 2,
                velocity: { x: 0, y: 0 },
                exploded: false,
                size: 15,
                thrust: false,
                lives: 3,
                score: 0
              };
            }
          });
        }
        break;
    }
  }
  
  function startMultiplayerGame(partnerPlayerId, mode) {
    console.log(`startMultiplayerGame called: partnerPlayerId=${partnerPlayerId}, mode=${mode}`);
    isMultiplayer = true;
    gameMode = mode || 'coop';
    console.log(`Set gameMode to: ${gameMode}, isMultiplayer to: ${isMultiplayer}`);
    otherPlayerId = partnerPlayerId;
    lobbyOverlay.classList.remove('active');
    joinRequestOverlay.classList.remove('active');
    console.log(`Starting ${gameMode.toUpperCase()} game with ${partnerPlayerId}`);
    
    // Initialize other player ship
    const gameCanvas = document.getElementById('asteroidCanvas');
    otherPlayerShip = {
      x: (gameCanvas ? gameCanvas.width : 800) / 2 + 100,
      y: (gameCanvas ? gameCanvas.height : 600) / 2,
      angle: Math.PI,
      velocity: { x: 0, y: 0 },
      exploded: false,
      size: 15,
      thrust: false,
      lives: 3,
      score: 0
    };
  }
  
  // Button handlers
  const vsPlayBtn = document.getElementById('vsPlayBtn');
  let pendingJoinRequestMode = 'coop';
  
  soloPlayBtn.addEventListener('click', () => {
    gameMode = 'solo';
    lobbyOverlay.classList.remove('active');
    console.log('Starting solo game');
  });
  
  coopPlayBtn.addEventListener('click', () => {
    if (otherPlayerId && ws && ws.readyState === WebSocket.OPEN) {
      // Send join request for co-op
      ws.send(JSON.stringify({
        type: 'join_request',
        targetPlayerId: otherPlayerId,
        mode: 'coop'
      }));
      lobbyStatus.textContent = 'Sending co-op request...';
      coopPlayBtn.disabled = true;
      vsPlayBtn.disabled = true;
      soloPlayBtn.disabled = true;
    }
  });
  
  vsPlayBtn.addEventListener('click', () => {
    if (otherPlayerId && ws && ws.readyState === WebSocket.OPEN) {
      // Send join request for VS mode
      ws.send(JSON.stringify({
        type: 'join_request',
        targetPlayerId: otherPlayerId,
        mode: 'vs'
      }));
      lobbyStatus.textContent = 'Sending VS challenge...';
      coopPlayBtn.disabled = true;
      vsPlayBtn.disabled = true;
      soloPlayBtn.disabled = true;
    }
  });
  
  anyPlayerBtn.addEventListener('click', () => {
    if (ws && ws.readyState === WebSocket.OPEN) {
      // Join or create an open game
      ws.send(JSON.stringify({
        type: 'join_anyplayer',
        playerId: myPlayerId
      }));
      lobbyStatus.textContent = 'Joining battle royale...';
      gameMode = 'anyplayer';
      isMultiplayer = true;
      lobbyOverlay.classList.remove('active');
      console.log('Starting Any Player mode (Battle Royale)');
      
      // Initialize all players tracking
      allPlayers = {};
      
      // Randomize spawn position for battle royale
      const ship = window.getShip ? window.getShip() : null;
      const gameCanvas = document.getElementById('asteroidCanvas');
      if (ship && gameCanvas) {
        ship.x = Math.random() * gameCanvas.width;
        ship.y = Math.random() * gameCanvas.height;
        ship.velocity = { x: 0, y: 0 };
        ship.angle = Math.random() * Math.PI * 2;
        console.log(`Spawned at random position: (${Math.round(ship.x)}, ${Math.round(ship.y)})`);
      }
      
      // Clear bombs from previous games
      if (window.clearBombs) {
        window.clearBombs();
        window.setBombCount(0);
      }
    }
  });
  
  acceptJoinBtn.addEventListener('click', () => {
    console.log(`Accept button clicked. pendingJoinRequest=${pendingJoinRequest}, pendingJoinRequestMode=${pendingJoinRequestMode}`);
    if (pendingJoinRequest && ws && ws.readyState === WebSocket.OPEN) {
      console.log(`Sending join_response with accepted=true, mode=${pendingJoinRequestMode}`);
      ws.send(JSON.stringify({
        type: 'join_response',
        requestingPlayerId: pendingJoinRequest,
        accepted: true,
        mode: pendingJoinRequestMode
      }));
      console.log(`Calling startMultiplayerGame with mode: ${pendingJoinRequestMode}`);
      startMultiplayerGame(pendingJoinRequest, pendingJoinRequestMode);
      pendingJoinRequest = null;
    }
  });
  
  declineJoinBtn.addEventListener('click', () => {
    if (pendingJoinRequest && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'join_response',
        requestingPlayerId: pendingJoinRequest,
        accepted: false
      }));
      joinRequestOverlay.classList.remove('active');
      pendingJoinRequest = null;
    }
  });
  
  // Send state updates periodically
  setInterval(() => {
    if (isMultiplayer && ws && ws.readyState === WebSocket.OPEN) {
      const ship = window.getShip ? window.getShip() : null;
      const lives = window.getLives ? window.getLives() : 3;
      const score = window.getScore ? window.getScore() : 0;
      const kills = window.getPlayerKills ? window.getPlayerKills() : 0;
      const deaths = window.getPlayerDeaths ? window.getPlayerDeaths() : 0;
      
      if (ship) {
        try {
          ws.send(JSON.stringify({
            type: 'state_update',
            state: {
              x: ship.x,
              y: ship.y,
              angle: ship.angle,
              velocity: ship.velocity,
              exploded: ship.exploded,
              thrust: ship.thrust,
              lives: lives,
              score: score,
              kills: kills,
              deaths: deaths
            }
          }));
        } catch (e) {
          console.error('Error sending state_update:', e.message);
        }
      }
      
      // Sync powerups in co-op mode
      if (gameMode === 'coop') {
        const powerups = window.getPowerups ? window.getPowerups() : null;
        if (powerups) {
          try {
            ws.send(JSON.stringify({
              type: 'powerup_sync',
              powerups: powerups
            }));
          } catch (e) {
            console.error('Error sending powerup_sync:', e.message);
          }
        }
      }
      
      // If host, sync game state
      if (isHost) {
        const asteroids = window.getAsteroids ? window.getAsteroids() : [];
        try {
          ws.send(JSON.stringify({
            type: 'game_sync',
            gameState: {
              asteroids: asteroids
            }
          }));
        } catch (e) {
          console.error('Error sending game_sync:', e.message);
        }
      }
    }
  }, 50); // 20 times per second for smoother sync
  
  // Interpolate other player's position for smooth movement
  setInterval(() => {
    if (isMultiplayer && gameMode !== 'anyplayer') {
      // For 2-player modes, use interpolation
      if (otherPlayerShip && otherPlayerTargetState) {
        const lerpFactor = 0.6; // Faster interpolation (was 0.3, now 0.6 for less drag)
        
        // Lerp position
        otherPlayerShip.x += (otherPlayerTargetState.x - otherPlayerShip.x) * lerpFactor;
        otherPlayerShip.y += (otherPlayerTargetState.y - otherPlayerShip.y) * lerpFactor;
        
        // Lerp angle (handle wrapping)
        let angleDiff = otherPlayerTargetState.angle - otherPlayerShip.angle;
        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
        otherPlayerShip.angle += angleDiff * lerpFactor;
        
        // Update other properties
        otherPlayerShip.thrust = otherPlayerTargetState.thrust;
        otherPlayerShip.exploded = otherPlayerTargetState.exploded;
      }
    }
    
    // For anyplayer mode, positions are updated directly (no interpolation to reduce lag)
  }, 16); // ~60fps interpolation
  
  // Expose multiplayer functions
  window.getOtherPlayerShip = () => otherPlayerShip;
  window.getAllPlayers = () => allPlayers;
  window.isMultiplayerActive = () => isMultiplayer;
  window.getGameMode = () => {
    //console.log(`getGameMode called, returning: ${gameMode}`);
    return gameMode;
  };
  window.getMyPlayerId = () => myPlayerId;
  window.getOtherPlayerId = () => otherPlayerId;
  window.getPlayerColor = getPlayerColor;
  window.getPlayerColors = () => playerColors;
  
  // Broadcast bullet function
  window.broadcastBullet = (bullet) => {
    if (isMultiplayer && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'bullet_fired',
        bullet: bullet
      }));
    }
  };
  
  // Broadcast bomb operations
  window.broadcastBombDropped = (bomb) => {
    const currentGameMode = window.getGameMode ? window.getGameMode() : 'solo';
    const isMulti = window.isMultiplayerActive ? window.isMultiplayerActive() : false;
    console.log('üîç Broadcast check:', { isMulti, currentGameMode, hasWs: !!ws, wsState: ws ? ws.readyState : 'no ws' });
    if (isMulti && (currentGameMode === 'anyplayer' || currentGameMode === 'vs') && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'bomb_dropped',
        bomb: bomb
      }));
      console.log('‚úÖ Bomb broadcast sent to server');
    } else {
      console.log('‚ùå Bomb broadcast blocked:', { isMulti, currentGameMode, hasWs: !!ws, wsReady: ws && ws.readyState === WebSocket.OPEN });
    }
  };
  
  window.broadcastBombDestroyed = (bombIndex) => {
    const currentGameMode = window.getGameMode ? window.getGameMode() : 'solo';
    const isMulti = window.isMultiplayerActive ? window.isMultiplayerActive() : false;
    if (isMulti && (currentGameMode === 'anyplayer' || currentGameMode === 'vs') && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'bomb_destroyed',
        bombIndex: bombIndex
      }));
    }
  };
  
  window.broadcastBombKill = (victimId, bomberId) => {
    const currentGameMode = window.getGameMode ? window.getGameMode() : 'solo';
    const isMulti = window.isMultiplayerActive ? window.isMultiplayerActive() : false;
    if (isMulti && (currentGameMode === 'anyplayer' || currentGameMode === 'vs') && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'bomb_kill',
        victim: victimId,
        bomber: bomberId
      }));
    }
  };
  
  // Broadcast player hit in VS or anyplayer mode
  window.broadcastPlayerHit = (targetPlayerId) => {
    if (isMultiplayer && (gameMode === 'vs' || gameMode === 'anyplayer') && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'player_hit',
        targetId: targetPlayerId
      }));
    }
  };

  // Broadcast a kill in VS mode
  window.broadcastKill = () => {
    if (isMultiplayer && gameMode === 'vs' && ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'player_killed'
      }));
    }
  };
  
  // Show lobby on page load
  lobbyOverlay.classList.add('active');
  
  // Connect to WebSocket
  connectWebSocket();
})();

// ===== MODIFY GAME TO SUPPORT 2 PLAYERS =====
(function() {
  // Override the ship drawing function to draw both players
  const originalGameLoop = window.gameLoop;
  
  // Draw other player's ship (for 2-player modes)
  function drawOtherPlayerShip() {
    const otherShip = window.getOtherPlayerShip ? window.getOtherPlayerShip() : null;
    const isMultiplayer = window.isMultiplayerActive ? window.isMultiplayerActive() : false;
    if (!otherShip) {
      return;
    }
    if (!isMultiplayer) {
      return;
    }
    if (otherShip.exploded) {
      return;
    }
    
    const canvas = document.getElementById('asteroidCanvas');
    const ctx = canvas.getContext('2d');
    
    ctx.save();
    ctx.translate(otherShip.x, otherShip.y);
    ctx.rotate(otherShip.angle);
    
    // Get color based on game mode and player ID
    const gameMode = window.getGameMode ? window.getGameMode() : 'coop';
    const getPlayerColor = window.getPlayerColor;
    const otherPlayerId = window.getOtherPlayerId ? window.getOtherPlayerId() : null;
    
    // Use the color assignment function for consistency
    let shipColor = { primary: 'rgba(255, 107, 107, 0.6)', fill: 'rgba(255, 107, 107, 0.1)' };
    if (getPlayerColor && otherPlayerId) {
      const assignedColor = getPlayerColor(otherPlayerId);
      shipColor = {
        primary: assignedColor.primary.replace('0.7)', '0.6)'),
        fill: assignedColor.fill.replace('0.15)', '0.1)')
      };
    } else {
      // Fallback to mode-based colors
      shipColor = gameMode === 'vs'
        ? { primary: 'rgba(255, 107, 107, 0.6)', fill: 'rgba(255, 107, 107, 0.1)' }
        : { primary: 'rgba(255, 165, 50, 0.6)', fill: 'rgba(255, 165, 50, 0.1)' };
    }
    
    ctx.strokeStyle = shipColor.primary;
    ctx.fillStyle = shipColor.fill;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(otherShip.size, 0);
    ctx.lineTo(-otherShip.size, -otherShip.size / 2);
    ctx.lineTo(-otherShip.size, otherShip.size / 2);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Thrust flames
    if (otherShip.thrust) {
      ctx.fillStyle = shipColor.primary.replace('0.6)', '0.5)');
      ctx.beginPath();
      ctx.moveTo(-otherShip.size, -otherShip.size / 3);
      ctx.lineTo(-otherShip.size - 10, 0);
      ctx.lineTo(-otherShip.size, otherShip.size / 3);
      ctx.closePath();
      ctx.fill();
    }
    
    ctx.restore();
    
    // Draw player label
    const labelColor = shipColor.primary.replace('0.6)', '0.9)');
    ctx.fillStyle = labelColor;
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    const label = gameMode === 'vs' ? 'ENEMY' : 'P2';
    ctx.fillText(label, otherShip.x, otherShip.y - 25);
  }
  
  // Draw all players in anyplayer mode
  function drawAllPlayers() {
    const allPlayers = window.getAllPlayers ? window.getAllPlayers() : {};
    const getPlayerColor = window.getPlayerColor;
    const canvas = document.getElementById('asteroidCanvas');
    const ctx = canvas.getContext('2d');
    
    Object.entries(allPlayers).forEach(([playerId, player]) => {
      if (player.exploded) return;
      
      // Get unique color for this player
      const color = getPlayerColor ? getPlayerColor(playerId) : { primary: 'rgba(255, 107, 107, 0.7)', fill: 'rgba(255, 107, 107, 0.15)' };
      
      ctx.save();
      ctx.translate(player.x, player.y);
      ctx.rotate(player.angle);
      
      // Ship body - unique color for each player
      ctx.strokeStyle = color.primary;
      ctx.fillStyle = color.fill;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(player.size, 0);
      ctx.lineTo(-player.size, -player.size / 2);
      ctx.lineTo(-player.size, player.size / 2);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Thrust flames
      if (player.thrust) {
        ctx.fillStyle = color.primary.replace('0.7)', '0.6)');
        ctx.beginPath();
        ctx.moveTo(-player.size, -player.size / 3);
        ctx.lineTo(-player.size - 10, 0);
        ctx.lineTo(-player.size, player.size / 3);
        ctx.closePath();
        ctx.fill();
      }
      
      ctx.restore();
      
      // Draw player indicator with score
      ctx.fillStyle = color.primary.replace('0.7)', '0.9)');
      ctx.font = 'bold 11px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText(`${player.score || 0}`, player.x, player.y - 25);
    });
  }
  
  // Update player list UI
  function updatePlayerList() {
    const playerListEl = document.getElementById('playerList');
    const playerListContent = document.getElementById('playerListContent');
    const gameMode = window.getGameMode ? window.getGameMode() : 'solo';
    const myPlayerId = window.getMyPlayerId ? window.getMyPlayerId() : null;
    const allPlayers = window.getAllPlayers ? window.getAllPlayers() : {};
    const getPlayerColor = window.getPlayerColor;
    const getScore = window.getScore ? window.getScore() : 0;
    const getLives = window.getLives ? window.getLives() : 3;
    const getPlayerKills = window.getPlayerKills ? window.getPlayerKills() : 0;
    const getPlayerDeaths = window.getPlayerDeaths ? window.getPlayerDeaths() : 0;
    
    if (gameMode === 'anyplayer' && playerListEl && playerListContent) {
      playerListEl.classList.add('active');
      
      // Build player list HTML
      let html = '';
      
      // Add local player first
      const myColor = { primary: 'rgba(126, 240, 163, 0.7)', fill: 'rgba(126, 240, 163, 0.15)' };
      html += `
        <div class="player-item me">
          <div class="player-icon" style="background: ${myColor.primary};"></div>
          <div class="player-info">
            <div class="player-name">You</div>
            <div class="player-score">Kills: ${getPlayerKills} | Deaths: ${getPlayerDeaths}</div>
          </div>
        </div>
      `;
      
      // Add other players
      Object.entries(allPlayers).forEach(([playerId, player]) => {
        const color = getPlayerColor ? getPlayerColor(playerId) : { primary: 'rgba(255, 107, 107, 0.7)' };
        const shortId = playerId.substring(0, 6);
        html += `
          <div class="player-item" style="border-left-color: ${color.primary};">
            <div class="player-icon" style="background: ${color.primary};"></div>
            <div class="player-info">
              <div class="player-name">${shortId}</div>
              <div class="player-score">Kills: ${player.kills || 0} | Deaths: ${player.deaths || 0}</div>
            </div>
          </div>
        `;
      });
      
      playerListContent.innerHTML = html;
    } else {
      if (playerListEl) {
        playerListEl.classList.remove('active');
      }
    }
  }
  
  // Inject into game loop
  const canvas = document.getElementById('asteroidCanvas');
  const originalRequestAnimationFrame = window.requestAnimationFrame;
  
  // Expose drawing functions to be called from the game loop
  window.drawOtherPlayerShip = drawOtherPlayerShip;
  window.drawAllPlayers = drawAllPlayers;
  
  // Update player list more frequently
  setInterval(() => {
    updatePlayerList();
  }, 100); // 10 times per second
})();

</script>

</body>
</html>
